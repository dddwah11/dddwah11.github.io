<!DOCTYPE html>
<html lang="en">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/5.0.0-rc.3'>
  <meta name="generator" content="Hexo 6.1.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="https://dddwah11.github.io/2025/05/21/ssm/"/>
  <!-- 渲染优化 -->
  <!-- <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin> -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="61分" name="application-name">
  <meta content="61分" name="apple-mobile-web-app-title">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <link rel="preload" href="/css/style.css?time=1747798801074" as="style">
  <link rel="preload" href="/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- 页面元数据 -->
  <title>61分</title>
  <meta name="keywords" content="null">
  <meta name="description" content="MyBatis基本介绍ORM（Object Relational Mapping）： 对象关系映射，指的是持久化数据和实体对象的映射模式，解决面向对象与关系型数据库存在的互不匹配的现象  MyBatis：  MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 Statement 等过程">
<meta property="og:type" content="article">
<meta property="og:title" content="61分">
<meta property="og:url" content="https://dddwah11.github.io/2025/05/21/SSM/index.html">
<meta property="og:site_name" content="61分">
<meta property="og:description" content="MyBatis基本介绍ORM（Object Relational Mapping）： 对象关系映射，指的是持久化数据和实体对象的映射模式，解决面向对象与关系型数据库存在的互不匹配的现象  MyBatis：  MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 Statement 等过程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://dddwah11.github.io/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2025-05-20T16:25:06.362Z">
<meta property="article:modified_time" content="2023-04-07T03:39:44.000Z">
<meta property="article:author" content="小刘">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dddwah11.github.io/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <!-- feed -->
  <!-- import meta -->
  <!-- link -->
    <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  <!-- import link -->
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
/* 
  * Workaround for Chrome bug, part 1
  * Chunk rendering for all but the first article.
  * /layout/_partial/scripts/content-visibility-scroll-fix.ejs
*/
.post-story + .post-story,
article + article,
.post-wrapper + .post-wrapper {
  content-visibility: auto;
  contain-intrinsic-size: 10px 500px;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #36ac91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #44d7b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #1b79c4;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper.dock .menu,
.cover-wrapper.featured .menu,
.cover-wrapper.focus .menu {
  border-radius: 6px;
  -webkit-border-radius: 6px;
}
.cover-wrapper.dock .menu .list-h a,
.cover-wrapper.featured .menu .list-h a,
.cover-wrapper.focus .menu .list-h a {
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  line-height: 24px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  border-bottom: none;
  text-align: center;
  align-content: flex-end;
  color: rgba(68,68,68,0.7);
  font-size: 1.5rem;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h a,
  .cover-wrapper.featured .menu .list-h a,
  .cover-wrapper.focus .menu .list-h a {
    padding: 12px 8px;
  }
}
.cover-wrapper.dock .menu .list-h a i,
.cover-wrapper.featured .menu .list-h a i,
.cover-wrapper.focus .menu .list-h a i {
  margin: 8px;
}
.cover-wrapper.dock .menu .list-h a p,
.cover-wrapper.featured .menu .list-h a p,
.cover-wrapper.focus .menu .list-h a p {
  font-size: 0.875rem;
}
.cover-wrapper.dock .menu .list-h a.active,
.cover-wrapper.featured .menu .list-h a.active,
.cover-wrapper.focus .menu .list-h a.active {
  background: var(--color-card);
  backdrop-filter: none;
}
.cover-wrapper.dock .menu .list-h a.active i,
.cover-wrapper.featured .menu .list-h a.active i,
.cover-wrapper.focus .menu .list-h a.active i,
.cover-wrapper.dock .menu .list-h a.active i+p,
.cover-wrapper.featured .menu .list-h a.active i+p,
.cover-wrapper.focus .menu .list-h a.active i+p {
  color: #44d7b6;
}
.cover-wrapper.dock .menu .list-h a.active img+p,
.cover-wrapper.featured .menu .list-h a.active img+p,
.cover-wrapper.focus .menu .list-h a.active img+p {
  color: var(--color-text);
}
.cover-wrapper.dock .menu .list-h a:hover,
.cover-wrapper.featured .menu .list-h a:hover,
.cover-wrapper.focus .menu .list-h a:hover {
  background: var(--color-card);
}
.cover-wrapper.dock .top {
  margin-bottom: 48px;
}
.cover-wrapper.dock .menu {
  background: rgba(255,255,255,0.5);
  position: absolute;
  bottom: 0;
  max-width: 100%;
}
.cover-wrapper.dock .menu .list-h {
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  margin: 4px;
}
.cover-wrapper.dock .menu .list-h a+a {
  margin-left: 4px;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h {
    overflow-x: scroll;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar {
    height: 0;
    width: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-track-piece {
    background: transparent;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb {
    background: #44d7b6;
    cursor: pointer;
    border-radius: 0;
    -webkit-border-radius: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb:hover {
    background: #ff5722;
  }
}
@supports (backdrop-filter: blur(20px)) {
  .cover-wrapper.dock .menu {
    background: rgba(255,255,255,0.5);
    backdrop-filter: saturate(200%) blur(20px);
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #44d7b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #44d7b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #44d7b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css?time=1747798801074" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css?time=1747798801074"></noscript>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>Sorry, your browser cannot access this site</b></span><br/>`+
        `<span class="kill-c">Microsoft has terminated support for Internet Explorer (IE) 10 and earlier versions in 2016. <br/>There are great security risks to continue using it. Please use contemporary mainstream browsers to access.</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support"><strong>Learn more ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>Sorry, your browser cannot access this site</b></span><br/>
        <span class="kill-c">This page requires browser support (enable) JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>Learn more ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = false; // 开启调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    cdn: {"js":{"app":"/js/app.js?time=1747798801074","sites":"/js/plugins/sites.js?time=1747798801074","friends":"/js/plugins/friends.js?time=1747798801074","parallax":"/js/plugins/parallax.js?time=1747798801074","rightMenu":"/js/plugins/rightMenu.js?time=1747798801074","contributors":"/js/plugins/contributors.js?time=1747798801074","message":"/js/thirdparty/message.js?time=1747798801074","valine":"https://npm.elemecdn.com/valine@1.4/dist/Valine.min.js?time=1747798801074","search":"/js/search/hexo.js?time=1747798801074"},"css":{"style":"/css/style.css?time=1747798801074","message":"/css/message.css?time=1747798801074"}},
    default: {"avatar":"/media/placeholder/avatar/round/3442075.svg","link":"/media/placeholder/link/8f277b4ee0ecd.svg","cover":"/media/placeholder/cover/76b86c0226ffd.svg","image":"/media/placeholder/image/2659360.svg"},
    lastupdate: new Date('Wed May 21 2025 11:40:01 GMT+0800 (中国标准时间)'),
    sidebar: {
      for_page: ["blogger","category","tagcloud","donate"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2020/01/01",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"/libs/@fancyapps/ui/dist/fancybox.css","js":"/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      aplayer: {
        id: 3175833810,
        enable:null
      },
      rightmenu: {
        faicon: "fa",
        layout: ["home","hr","help","examples","contributors","hr","source_docs","source_theme","hr","print","darkmode","reading","music"],
        music_alwaysShow: true,
        customPicUrl: {"enable":false,"old":null,"new":null},
        print: true
      }
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = {
    ...volantis.pjax,
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  };
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = {
    ...volantis.dark,
    push: volantis.dark.method.toggle.push,
  };
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = {
    ...volantis.scroll,
    push: volantis.scroll.engine.push,
  };
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) =>{
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 25
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置 
    // 目前用于处理 toc 部分 lazyload 引起的 cls 导致的定位失败问题
    if (option.observer) {
      volantis.scroll.unengine.push(()=>{
        let me = ele.getBoundingClientRect().top
        if(!(me >= -option.observerDic && me <= option.observerDic)){
          volantis.scroll.to(ele, option)
        }else{
          volantis.scroll.unengine.remove("unengineObserver")
        }
      },"unengineObserver")
    }
  }
  /******************************************************************************/
  /******************************************************************************/
</script>
  <!-- Custom Files head begin-->
  
  <!-- Custom Files head end-->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='/media/org.volantis/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="none" class='cover-wrapper post dock' style="display: none;">
        
  <div class='cover-bg lazyload placeholder' data-bg="https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Volantis</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              active-action="action-v4getting-started">
              <img src='/media/twemoji/assets/svg/1f5c3.svg'><p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              active-action="action-faqs">
              <img src='/media/twemoji/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              active-action="action-examples">
              <img src='/media/twemoji/assets/svg/1f396.svg'><p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              active-action="action-contributors">
              <img src='/media/twemoji/assets/svg/1f389.svg'><p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              active-action="action-archives">
              <img src='/media/twemoji/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
            <a target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              active-action="action-https:githubcomvolantis-xhexo-theme-volantis">
              <img src='/media/twemoji/assets/svg/1f9ec.svg'><p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="https://dddwah11.github.io/2025/05/21/SSM/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="61分">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="61分">
    <meta itemprop="description" content="">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <span hidden itemprop="name headline">
        
      </span>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><div class="story post-story"><p>ORM（Object Relational Mapping）： 对象关系映射，指的是持久化数据和实体对象的映射模式，解决面向对象与关系型数据库存在的互不匹配的现象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-ORM%E4%BB%8B%E7%BB%8D.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-ORM%E4%BB%8B%E7%BB%8D.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p><strong>MyBatis</strong>：</p>
<ul>
<li><p>MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 Statement 等过程。</p>
</li>
<li><p>MyBatis 通过 XML 或注解的方式将要执行的各种 Statement 配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句。</p>
</li>
<li><p>MyBatis 框架执行 SQL 并将结果映射为 Java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC 底层 API 的调用细节，使我们不用操作 JDBC API，就可以完成对数据库的持久化操作。</p>
</li>
</ul>
<p>MyBatis 官网地址：<a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p>
<p>参考视频：<a target="_blank" rel="noopener" href="https://space.bilibili.com/37974444/">https://space.bilibili.com/37974444/</a></p>
<hr>
</div><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><div class="story post-story"><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>Resources：加载资源的工具类</p>
<ul>
<li><code>InputStream getResourceAsStream(String fileName)</code>：通过类加载器返回指定资源的字节流<ul>
<li>参数 fileName 是放在 src 的核心配置文件名：MyBatisConfig.xml</li>
</ul>
</li>
</ul>
<p>SqlSessionFactoryBuilder：构建器，用来获取 SqlSessionFactory 工厂对象</p>
<ul>
<li><code>SqlSessionFactory build(InputStream is)</code>：通过指定资源的字节输入流获取 SqlSession 工厂对象</li>
</ul>
<p>SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口</p>
<ul>
<li><code>SqlSession openSession()</code>：获取 SqlSession 构建者对象，并开启手动提交事务</li>
<li><code>SqlSession openSession(boolean)</code>：获取 SqlSession 构建者对象，参数为 true 开启自动提交事务</li>
</ul>
<p>SqlSession：构建者对象接口，用于执行 SQL、管理事务、接口代理</p>
<ul>
<li>SqlSession <strong>代表和数据库的一次会话</strong>，用完必须关闭</li>
<li>SqlSession 和 Connection 一样都是非线程安全，每次使用都应该去获取新的对象</li>
</ul>
<p>注：<strong>update 数据需要提交事务，或开启默认提交</strong></p>
<p>SqlSession 常用 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>List<E> selectList(String statement,Object parameter)</E></td>
<td>执行查询语句，返回List集合</td>
</tr>
<tr>
<td>T selectOne(String statement,Object parameter)</td>
<td>执行查询语句，返回一个结果对象</td>
</tr>
<tr>
<td>int insert(String statement,Object parameter)</td>
<td>执行新增语句，返回影响行数</td>
</tr>
<tr>
<td>int update(String statement,Object parameter)</td>
<td>执行删除语句，返回影响行数</td>
</tr>
<tr>
<td>int delete(String statement,Object parameter)</td>
<td>执行修改语句，返回影响行数</td>
</tr>
<tr>
<td>void commit()</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback()</td>
<td>回滚事务</td>
</tr>
<tr>
<td>T getMapper(Class<T> cls)</T></td>
<td>获取指定接口的代理实现类对象</td>
</tr>
<tr>
<td>void close()</td>
<td>释放资源</td>
</tr>
</tbody></table>
<hr>
<h3 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h3><p>映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句，放在 src 目录下</p>
<p>命名：StudentMapper.xml</p>
<ul>
<li><p>映射配置文件的文件头：</p>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
</code></pre>
</li>
<li><p>根标签：</p>
<ul>
<li><mapper>：核心根标签</mapper></li>
<li>namespace：属性，名称空间</li>
</ul>
</li>
<li><p>功能标签：</p>
<ul>
<li>&lt; select &gt;：查询功能标签</li>
<li><insert>：新增功能标签</insert></li>
<li><update>：修改功能标签</update></li>
<li><delete>：删除功能标签<ul>
<li>id：属性，唯一标识，配合名称空间使用</li>
<li>resultType：指定结果映射对象类型，和对应的方法的返回值类型（全限定名）保持一致，但是如果返回值是 List 则和其泛型保持一致</li>
<li>parameterType：指定参数映射对象类型，必须和对应的方法的参数类型（全限定名）保持一致</li>
<li><strong>statementType</strong>：可选 STATEMENT，PREPARED 或 CALLABLE，默认值：PREPARED<ul>
<li>STATEMENT：直接操作 SQL，使用 Statement 不进行预编译，获取数据：$</li>
<li>PREPARED：预处理参数，使用 PreparedStatement 进行预编译，获取数据：#</li>
<li>CALLABLE：执行存储过程，CallableStatement</li>
</ul>
</li>
</ul>
</delete></li>
</ul>
</li>
<li><p>参数获取方式：</p>
<ul>
<li><p>SQL 获取参数：<code>#&#123;属性名&#125;</code></p>
<pre><code class="xml-dtd">&lt;mapper namespace=&quot;StudentMapper&quot;&gt;
    &lt;select id=&quot;selectById&quot; resultType=&quot;student&quot; parameterType=&quot;int&quot;&gt;
        SELECT * FROM student WHERE id = #&#123;id&#125;
    &lt;/select&gt;
&lt;mapper/&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>强烈推荐官方文档：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p>
<hr>
<h3 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h3><p>核心配置文件包含了 MyBatis 最核心的设置和属性信息，如数据库的连接、事务、连接池信息等</p>
<p>命名：MyBatisConfig.xml</p>
<ul>
<li><p>核心配置文件的文件头：</p>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
</code></pre>
</li>
<li><p>根标签：</p>
<ul>
<li><configuration>：核心根标签</configuration></li>
</ul>
</li>
<li><p>引入连接配置文件：</p>
<ul>
<li><p><properties>： 引入数据库连接配置文件标签</properties></p>
<ul>
<li>resource：属性，指定配置文件名</li>
</ul>
<pre><code class="xml-dtd">&lt;properties resource=&quot;jdbc.properties&quot;/&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>调整设置</p>
<ul>
<li><settings>：可以改变 Mybatis 运行时行为</settings></li>
</ul>
</li>
<li><p>起别名：</p>
<ul>
<li><p><typeAliases>：为全类名起别名的父标签</typeAliases></p>
<ul>
<li><p><typeAlias>：为全类名起别名的子标签</typeAlias></p>
<ul>
<li>type：指定全类名      </li>
<li>alias：指定别名</li>
</ul>
</li>
<li><p><package>：为指定包下所有类起别名的子标签，别名就是类名，首字母小写</package></p>
</li>
</ul>
<pre><code class="xml-dtd">&lt;!--起别名--&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;bean.Student&quot; alias=&quot;student&quot;/&gt;
    &lt;package name=&quot;com.seazean.bean&quot;/&gt;
        &lt;!--二选一--&gt;
&lt;/typeAliase&gt;
</code></pre>
</li>
<li><p>自带别名：</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>java.lang.String</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Lang</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
</tr>
<tr>
<td>….</td>
<td>……</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>配置环境，可以配置多个标签</p>
<ul>
<li><environments>：配置数据库环境标签，default 属性指定哪个 environment</environments></li>
<li><environment>：配置数据库环境子标签，id 属性是唯一标识，与 default 对应</environment></li>
<li><transactionManager>：事务管理标签，type 属性默认 JDBC 事务</transactionManager></li>
<li><dataSoure>：数据源标签<ul>
<li>type 属性：POOLED 使用连接池（MyBatis 内置），UNPOOLED 不使用连接池</li>
</ul>
</dataSoure></li>
<li><property>：数据库连接信息标签。<ul>
<li>name 属性取值：driver，url，username，password</li>
<li>value 属性取值：与 name 对应</li>
</ul>
</property></li>
</ul>
</li>
<li><p>引入映射配置文件</p>
<ul>
<li><mappers>：引入映射配置文件标签</mappers></li>
<li><mapper>：引入映射配置文件子标签<ul>
<li>resource：属性指定映射配置文件的名称</li>
<li>url：引用网路路径或者磁盘路径下的 sql 映射文件</li>
<li>class：指定映射配置类</li>
</ul>
</mapper></li>
<li><package>：批量注册</package></li>
</ul>
</li>
</ul>
<p>参考官方文档：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html">https://mybatis.org/mybatis-3/zh/configuration.html</a></p>
<hr>
<h3 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h3><p><strong>#{}：</strong>占位符，传入的内容会作为字符串<strong>加上引号</strong>，以<strong>预编译</strong>的方式传入，将 sql 中的 #{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值，有效的防止 SQL 注入，提高系统安全性</p>
<p><strong>${}：</strong>拼接符，传入的内容会<strong>直接替换</strong>拼接，不会加上引号，可能存在 sql 注入的安全隐患</p>
<ul>
<li><p>能用 #{} 的地方就用 #{}，不用或少用 ${}</p>
</li>
<li><p>必须使用 ${} 的情况：</p>
<ul>
<li>表名作参数时，如：<code>SELECT * FROM $&#123;tableName&#125;</code></li>
<li>order by 时，如：<code>SELECT * FROM t_user ORDER BY $&#123;columnName&#125;</code></li>
</ul>
</li>
<li><p>sql 语句使用 #{}，properties 文件内容获取使用 ${}</p>
</li>
</ul>
<hr>
<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>在日常开发过程中，排查问题时需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，就可以借助 log4j 的功能来实现执行信息的输出。</p>
<ul>
<li><p>在核心配置文件根标签内配置 log4j</p>
<pre><code class="xml">&lt;!--配置LOG4J--&gt;
&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;log4j&quot;/&gt;
&lt;/settings&gt;
</code></pre>
</li>
<li><p>在 src 目录下创建 log4j.properties</p>
<pre><code class="properties"># Global logging configuration
log4j.rootLogger=DEBUG, stdout
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n

#输出到日志文件
  #log4j.appender.file=org.apache.log4j.FileAppender
  #log4j.appender.file.File=../logs/iask.log
  #log4j.appender.file.layout=org.apache.log4j.PatternLayout
  #log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125;  %l  %m%n
</code></pre>
</li>
<li><p>pom.xml</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.21&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;1.7.21&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
<hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><p>实体类</p>
<pre><code class="java">public class Student &#123;
    private Integer id;
    private String name;
    private Integer age;
    .....
&#125;
</code></pre>
</li>
<li><p>StudentMapper</p>
<pre><code class="java">public interface StudentMapper &#123;
    //查询全部
    public abstract List&lt;Student&gt; selectAll();

    //根据id查询
    public abstract Student selectById(Integer id);

    //新增数据
    public abstract Integer insert(Student stu);

    //修改数据
    public abstract Integer update(Student stu);

    //删除数据
    public abstract Integer delete(Integer id);
&#125;
</code></pre>
</li>
<li><p>config.properties</p>
<pre><code class="properties">driver=com.mysql.jdbc.Driver
url=jdbc:mysql://192.168.2.184:3306/db1
username=root
password=123456
</code></pre>
</li>
<li><p>MyBatisConfig.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;

&lt;!--核心根标签--&gt;
&lt;configuration&gt;
    &lt;!--引入数据库连接的配置文件--&gt;
    &lt;properties resource=&quot;jdbc.properties&quot;/&gt;
    
    &lt;!--配置LOG4J--&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;log4j&quot;/&gt;
    &lt;/settings&gt;
    
    &lt;!--起别名--&gt;
    &lt;typeAliases&gt;
        &lt;typeAlias type=&quot;bean.Student&quot; alias=&quot;student&quot;/&gt;
        &lt;!--&lt;package name=&quot;bean&quot;/&gt;--&gt;
    &lt;/typeAliases&gt;

    &lt;!--配置数据库环境，可以多个环境，default指定哪个--&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;!--id属性唯一标识--&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;!--事务管理，type属性，默认JDBC事务--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--数据源信息   type属性连接池--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!--property获取数据库连接的配置信息--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!--引入映射配置文件--&gt;
    &lt;mappers&gt;
        &lt;!--mapper引入指定的映射配置 resource属性执行的映射配置文件的名称--&gt;
        &lt;mapper resource=&quot;StudentMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
</li>
<li><p>StudentMapper.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;StudentMapper&quot;&gt;
    &lt;select id=&quot;selectAll&quot; resultType=&quot;student&quot;&gt;
        SELECT * FROM student
    &lt;/select&gt;

    &lt;select id=&quot;selectById&quot; resultType=&quot;student&quot; parameterType=&quot;int&quot;&gt;
        SELECT * FROM student WHERE id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;student&quot;&gt;
        INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;student&quot;&gt;
        UPDATE student SET name = #&#123;name&#125;, age = #&#123;age&#125; WHERE id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;delete id=&quot;delete&quot; parameterType=&quot;student&quot;&gt;
        DELETE FROM student WHERE id = #&#123;id&#125;
    &lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
</li>
<li><p>控制层测试代码：根据 id 查询</p>
<pre><code class="java">@Test
public void selectById() throws Exception&#123;
    //1.加载核心配置文件
    InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);

    //2.获取SqlSession工厂对象
    SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(is);

    //3.通过工厂对象获取SqlSession对象
    SqlSession sqlSession = ssf.openSession();

    //4.执行映射配置文件中的sql语句，并接收结果
    Student stu = sqlSession.selectOne(&quot;StudentMapper.selectById&quot;, 3);

    //5.处理结果
    System.out.println(stu);

    //6.释放资源
    sqlSession.close();
    is.close();
&#125;
</code></pre>
</li>
<li><p>控制层测试代码：新增功能</p>
<pre><code class="java">@Test
public void insert() throws Exception&#123;
    //1.加载核心配置文件
    //2.获取SqlSession工厂对象
    //3.通过工厂对象获取SqlSession对象
    SqlSession sqlSession = sqlSessionFactory.openSession(true);

    //4.执行映射配置文件中的sql语句，并接收结果
    Student stu = new Student(5, &quot;周七&quot;, 27);
    int result = sqlSession.insert(&quot;StudentMapper.insert&quot;, stu);

    //5.提交事务
    //sqlSession.commit();

    //6.处理结果
    System.out.println(result);

    //7.释放资源
    sqlSession.close();
    is.close();
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>三种方式实现批量操作：</p>
<ul>
<li><p><settings> 标签属性：这种方式属于<strong>全局批量</strong></settings></p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;BATCH&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>defaultExecutorType：配置默认的执行器</p>
<ul>
<li>SIMPLE 就是普通的执行器（默认，每次执行都要重新设置参数）</li>
<li>REUSE 执行器会重用预处理语句（只预设置一次参数，多次执行）</li>
<li>BATCH 执行器不仅重用语句还会执行批量更新（只针对<strong>修改操作</strong>）</li>
</ul>
</li>
<li><p>SqlSession <strong>会话内批量</strong>操作：</p>
<pre><code class="java">public void testBatch() throws IOException&#123;
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();

    // 可以执行批量操作的sqlSession
    SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
    long start = System.currentTimeMillis();
    try&#123;
        EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);
        for (int i = 0; i &lt; 10000; i++) &#123;
            mapper.addEmp(new Employee(UUID.randomUUID().toString().substring(0, 5), &quot;b&quot;, &quot;1&quot;));
        &#125;
        openSession.commit();
        long end = System.currentTimeMillis();
        // 批量：（预编译sql一次==&gt;设置参数===&gt;10000次===&gt;执行1次（类似管道））
        // 非批量：（预编译sql=设置参数=执行）==》10000   耗时更多
        System.out.println(&quot;执行时长：&quot; + (end - start));
    &#125;finally&#123;
        openSession.close();
    &#125;
&#125;
</code></pre>
</li>
<li><p>Spring 配置文件方式（applicationContext.xml）：</p>
<pre><code class="xml">&lt;!--配置一个可以进行批量执行的sqlSession  --&gt;
&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
    &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactoryBean&quot;/&gt;
    &lt;constructor-arg name=&quot;executorType&quot; value=&quot;BATCH&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="java">@Autowired
private SqlSession sqlSession;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="代理开发"><a href="#代理开发" class="headerlink" title="代理开发"></a>代理开发</h2><div class="story post-story"><h3 id="代理规则"><a href="#代理规则" class="headerlink" title="代理规则"></a>代理规则</h3><p>分层思想：控制层（controller）、业务层（service）、持久层（dao）</p>
<p>调用流程：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>传统方式实现 DAO 层，需要写接口和实现类。采用 Mybatis 的代理开发方式实现 DAO 层的开发，只需要编写 Mapper 接口（相当于 Dao 接口），由 Mybatis 框架根据接口定义创建接口的<strong>动态代理对象</strong></p>
<p>接口开发方式：</p>
<ol>
<li>定义接口</li>
<li>操作数据库，MyBatis 框架根据接口，通过动态代理的方式生成代理对象，负责数据库的操作</li>
</ol>
<p>Mapper 接口开发需要遵循以下规范：</p>
<ul>
<li><p>Mapper.xml 文件中的 namespace 与 DAO 层 mapper 接口的全类名相同</p>
</li>
<li><p>Mapper.xml 文件中的增删改查标签的id属性和 DAO 层 Mapper 接口方法名相同</p>
</li>
<li><p>Mapper.xml 文件中的增删改查标签的 parameterType 属性和 DAO 层 Mapper 接口方法的参数相同</p>
</li>
<li><p>Mapper.xml 文件中的增删改查标签的 resultType 属性和 DAO 层 Mapper 接口方法的返回值相同</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0DAO%E5%B1%82.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0DAO%E5%B1%82.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
</ul>
<hr>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过动态代理开发模式，只编写一个接口不写实现类，通过 <strong>getMapper()</strong> 方法最终获取到 MapperProxy 代理对象，而这个代理对象是 MyBatis 使用了 JDK 的动态代理技术生成的</p>
<p>动态代理实现类对象在执行方法时最终调用了 <strong>MapperMethod.execute()</strong> 方法，这个方法中通过 switch case 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 <strong>SqlSession 方式来执行增删改查</strong></p>
<ul>
<li><p>代码实现：</p>
<pre><code class="java">public Student selectById(Integer id) &#123;
    Student stu = null;
    SqlSession sqlSession = null;
    InputStream is = null;
    try&#123;
        //1.加载核心配置文件
        is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);

        //2.获取SqlSession工厂对象
        SqlSessionFactory s = new SqlSessionFactoryBuilder().build(is);

        //3.通过工厂对象获取SqlSession对象
        sqlSession = s.openSession(true);

        //4.获取StudentMapper接口的实现类对象
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); 

        //5.通过实现类对象调用方法，接收结果
        stu = mapper.selectById(id);
    &#125; catch (Exception e) &#123;
        e.getMessage();
    &#125; finally &#123;
        //6.释放资源
        if(sqlSession != null) &#123;
            sqlSession.close();
        &#125;
        if(is != null) &#123;
            try &#123;
                is.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    //7.返回结果
    return stu;
&#125;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h2><div class="story post-story"><h3 id="相关标签"><a href="#相关标签" class="headerlink" title="相关标签"></a>相关标签</h3><p><resultType>：返回结果映射对象类型，和对应方法的返回值类型保持一致，但是如果返回值是 List 则和其泛型保持一致</resultType></p>
<p><resultMap>：返回一条记录的 Map，key 是列名，value 是对应的值，用来配置<strong>字段和对象属性</strong>的映射关系标签，结果映射（和 resultType 二选一）</resultMap></p>
<ul>
<li>id 属性：唯一标识</li>
<li>type 属性：实体对象类型</li>
<li>autoMapping 属性：结果自动映射</li>
</ul>
<p><resultMap> 内的核心配置文件标签：</resultMap></p>
<ul>
<li><p><id>：配置主键映射关系标签</id></p>
</li>
<li><p><result>：配置非主键映射关系标签</result></p>
<ul>
<li>column 属性：表中字段名称</li>
<li>property 属性： 实体对象变量名称</li>
</ul>
</li>
<li><p><association>：配置被包含<strong>单个对象</strong>的映射关系标签，嵌套封装结果集（多对一、一对一）</association></p>
<ul>
<li>property 属性：被包含对象的变量名，要进行映射的属性名</li>
<li>javaType 属性：被包含对象的数据类型，要进行映射的属性的类型（Java 中的 Bean 类）</li>
<li>select 属性：加载复杂类型属性的映射语句的 ID，会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句</li>
</ul>
</li>
<li><p><collection>：配置被包含<strong>集合对象</strong>的映射关系标签，嵌套封装结果集（一对多、多对多）</collection></p>
<ul>
<li>property 属性：被包含集合对象的变量名</li>
<li>ofType 属性：集合中保存的对象数据类型</li>
</ul>
</li>
<li><p><discriminator>：鉴别器，用来判断某列的值，根据得到某列的不同值做出不同自定义的封装行为</discriminator></p>
</li>
</ul>
<p>自定义封装规则可以将数据库中比较复杂的数据类型映射为 JavaBean 中的属性</p>
<hr>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>子查询：</p>
<pre><code class="java">public class Blog &#123;
    private int id;
    private String msg;
    private Author author;
    // set + get
&#125;
</code></pre>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot; autoMapping = &quot;true&quot;&gt;
    &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
    SELECT * FROM BLOG WHERE ID = #&#123;id&#125;
&lt;/select&gt;

&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt;
    SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>循环引用：通过缓存解决</p>
<pre><code class="xml">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot; autoMapping = &quot;true&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;collection property=&quot;comment&quot; ofType=&quot;Comment&quot;&gt;
        &lt;association property=&quot;blog&quot; javaType=&quot;Blog&quot; resultMap=&quot;blogResult&quot;/&gt;&lt;!--y--&gt;
    &lt;/collection&gt;
&lt;/resultMap
</code></pre>
<hr>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一实现：</p>
<ul>
<li><p>数据准备</p>
<pre><code class="mysql">CREATE TABLE person(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(20),
    age INT
);
INSERT INTO person VALUES (NULL,&#39;张三&#39;,23),(NULL,&#39;李四&#39;,24),(NULL,&#39;王五&#39;,25);

CREATE TABLE card(
    id INT PRIMARY KEY AUTO_INCREMENT,
    number VARCHAR(30),
    pid INT,
    CONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id)
);
INSERT INTO card VALUES (NULL,&#39;12345&#39;,1),(NULL,&#39;23456&#39;,2),(NULL,&#39;34567&#39;,3);
</code></pre>
</li>
<li><p>bean 类</p>
<pre><code class="java">public class Card &#123;
    private Integer id;     //主键id
    private String number;  //身份证号
    private Person p;       //所属人的对象
    ......
&#125;

public class Person &#123;
    private Integer id;     //主键id
    private String name;    //人的姓名
    private Integer age;    //人的年龄
&#125;
</code></pre>
</li>
<li><p>配置文件 OneToOneMapper.xml，MyBatisConfig.xml 需要引入（可以把 bean 包下起别名）</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;OneToOneMapper&quot;&gt;

    &lt;!--配置字段和实体对象属性的映射关系--&gt;
    &lt;resultMap id=&quot;oneToOne&quot; type=&quot;card&quot;&gt;
           &lt;!--column 表中字段名称，property 实体对象变量名称--&gt;
        &lt;id column=&quot;cid&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;number&quot; property=&quot;number&quot; /&gt;
        &lt;!--
            association：配置被包含对象的映射关系
            property：被包含对象的变量名
            javaType：被包含对象的数据类型
        --&gt;
        &lt;association property=&quot;p&quot; javaType=&quot;bean.Person&quot;&gt;
            &lt;id column=&quot;pid&quot; property=&quot;id&quot; /&gt;
            &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
            &lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;selectAll&quot; resultMap=&quot;oneToOne&quot;&gt; &lt;!--SQL--&gt;
        SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>核心配置文件 MyBatisConfig.xml</p>
<pre><code class="xml">&lt;!-- mappers引入映射配置文件 --&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;one_to_one/OneToOneMapper.xml&quot;/&gt;
    &lt;mapper resource=&quot;one_to_many/OneToManyMapper.xml&quot;/&gt;
    &lt;mapper resource=&quot;many_to_many/ManyToManyMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">public class Test01 &#123;
    @Test
    public void selectAll() throws Exception&#123;
        //1.加载核心配置文件
        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);

        //2.获取SqlSession工厂对象
        SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(is);

        //3.通过工厂对象获取SqlSession对象
        SqlSession sqlSession = ssf.openSession(true);

        //4.获取OneToOneMapper接口的实现类对象
        OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class);

        //5.调用实现类的方法，接收结果
        List&lt;Card&gt; list = mapper.selectAll();

        //6.处理结果
        for (Card c : list) &#123;
            System.out.println(c);
        &#125;

        //7.释放资源
        sqlSession.close();
        is.close();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>一对多实现：</p>
<ul>
<li><p>数据准备</p>
<pre><code class="mysql">CREATE TABLE classes(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(20)
);
INSERT INTO classes VALUES (NULL,&#39;程序一班&#39;),(NULL,&#39;程序二班&#39;)

CREATE TABLE student(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(30),
    age INT,
    cid INT,
    CONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id)
);
INSERT INTO student VALUES (NULL,&#39;张三&#39;,23,1),(NULL,&#39;李四&#39;,24,1),(NULL,&#39;王五&#39;,25,2);
</code></pre>
</li>
<li><p>bean 类</p>
<pre><code class="java">public class Classes &#123;
    private Integer id;     //主键id
    private String name;    //班级名称
    private List&lt;Student&gt; students; //班级中所有学生对象
    ........
&#125;
public class Student &#123;
    private Integer id;     //主键id
    private String name;    //学生姓名
    private Integer age;    //学生年龄
&#125;
</code></pre>
</li>
<li><p>映射配置文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;OneToManyMapper&quot;&gt;
    &lt;resultMap id=&quot;oneToMany&quot; type=&quot;bean.Classes&quot;&gt;
        &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;

        &lt;!--collection：配置被包含的集合对象映射关系--&gt;
        &lt;collection property=&quot;students&quot; ofType=&quot;bean.Student&quot;&gt;
            &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectAll&quot; resultMap=&quot;oneToMany&quot;&gt; &lt;!--SQL--&gt;
        SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>代码实现片段</p>
<pre><code class="java">//4.获取OneToManyMapper接口的实现类对象
OneToManyMapper mapper = sqlSession.getMapper(OneToManyMapper.class);

//5.调用实现类的方法，接收结果
List&lt;Classes&gt; classes = mapper.selectAll();

//6.处理结果
for (Classes cls : classes) &#123;
    System.out.println(cls.getId() + &quot;,&quot; + cls.getName());
    List&lt;Student&gt; students = cls.getStudents();
    for (Student student : students) &#123;
        System.out.println(&quot;\t&quot; + student);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>学生课程例子，中间表不需要 bean 实体类</p>
<ul>
<li><p>数据准备</p>
<pre><code class="mysql">CREATE TABLE course(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(20)
);
INSERT INTO course VALUES (NULL,&#39;语文&#39;),(NULL,&#39;数学&#39;);

CREATE TABLE stu_cr(
    id INT PRIMARY KEY AUTO_INCREMENT,
    sid INT,
    cid INT,
    CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),
    CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)
);
INSERT INTO stu_cr VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);
</code></pre>
</li>
<li><p>bean类</p>
<pre><code class="java">public class Student &#123;
    private Integer id;     //主键id
    private String name;    //学生姓名
    private Integer age;    //学生年龄
    private List&lt;Course&gt; courses;   // 学生所选择的课程集合
&#125;
public class Course &#123;
    private Integer id;     //主键id
    private String name;    //课程名称
&#125;
</code></pre>
</li>
<li><p>配置文件</p>
<pre><code class="xml">&lt;mapper namespace=&quot;ManyToManyMapper&quot;&gt;
    &lt;resultMap id=&quot;manyToMany&quot; type=&quot;Bean.Student&quot;&gt;
        &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt;
        &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt;

        &lt;collection property=&quot;courses&quot; ofType=&quot;Bean.Course&quot;&gt;
            &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectAll&quot; resultMap=&quot;manyToMany&quot;&gt; &lt;!--SQL--&gt;
        SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ul>
<hr>
<h3 id="鉴别器"><a href="#鉴别器" class="headerlink" title="鉴别器"></a>鉴别器</h3><p>需求：如果查询结果是女性，则把部门信息查询出来，否则不查询 ；如果是男性，把 last_name 这一列的值赋值</p>
<pre><code class="xml">&lt;!-- 
    column：指定要判断的列名 
    javaType：列值对应的java类型
   --&gt;
&lt;discriminator javaType=&quot;string&quot; column=&quot;gender&quot;&gt;
    &lt;!-- 女生 --&gt;
    &lt;!-- resultType不可缺少，也可以使用resutlMap --&gt;
    &lt;case value=&quot;0&quot; resultType=&quot;com.bean.Employee&quot;&gt;
        &lt;association property=&quot;dept&quot;
                     select=&quot;com.dao.DepartmentMapper.getDeptById&quot;
                     column=&quot;d_id&quot;&gt;
        &lt;/association&gt;
    &lt;/case&gt;
    &lt;!-- 男生 --&gt;
    &lt;case value=&quot;1&quot; resultType=&quot;com.bean.Employee&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;
        &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;
    &lt;/case&gt;
&lt;/discriminator&gt;
</code></pre>
<hr>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><h4 id="两种加载"><a href="#两种加载" class="headerlink" title="两种加载"></a>两种加载</h4><p>立即加载：只要调用方法，马上发起查询</p>
<p>延迟加载：在需要用到数据时才进行加载，不需要用到数据时就不加载数据，延迟加载也称懒加载</p>
<p>优点： 先从单表查询，需要时再从关联表去关联查询，提高数据库性能，因为查询单表要比关联查询多张表速度要快，节省资源</p>
<p>坏处：只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降</p>
<p>核心配置文件：</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载，特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td>
<td>false</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td>开启时，任一方法的调用都会加载该对象的所有延迟加载属性。否则每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods）</td>
<td>false</td>
</tr>
</tbody></table>
<pre><code class="xml">&lt;settings&gt; 
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; 
    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; 
&lt;/settings&gt;
</code></pre>
<hr>
<h4 id="assocation"><a href="#assocation" class="headerlink" title="assocation"></a>assocation</h4><p>分布查询：先按照身份 id 查询所属人的 id、然后根据所属人的 id 去查询人的全部信息，这就是分步查询</p>
<ul>
<li><p>映射配置文件 OneToOneMapper.xml </p>
<p>一对一映射：</p>
<ul>
<li>column 属性表示给要调用的其它的 select 标签传入的参数</li>
<li>select 属性表示调用其它的 select 标签</li>
<li>fetchType&#x3D;”lazy” 表示延迟加载（局部配置，只有配置了这个的地方才会延迟加载）</li>
</ul>
<pre><code class="xml">&lt;mapper namespace=&quot;OneToOneMapper&quot;&gt;
    &lt;!--配置字段和实体对象属性的映射关系--&gt;
    &lt;resultMap id=&quot;oneToOne&quot; type=&quot;card&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;
        &lt;result column=&quot;number&quot; property=&quot;number&quot; /&gt;
        &lt;association property=&quot;p&quot; javaType=&quot;bean.Person&quot;
                     column=&quot;pid&quot; 
                     select=&quot;one_to_one.PersonMapper.findPersonByid&quot;
                     fetchType=&quot;lazy&quot;&gt;
                    &lt;!--需要配置新的映射文件--&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;selectAll&quot; resultMap=&quot;oneToOne&quot;&gt; 
        SELECT * FROM card &lt;!--查询全部，负责根据条件直接全部加载--&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>PersonMapper.xml</p>
<pre><code class="xml">&lt;mapper namespace=&quot;one_to_one.PersonMapper&quot;&gt;
    &lt;select id=&quot;findPersonByid&quot; parameterType=&quot;int&quot; resultType=&quot;person&quot;&gt;
        SELECT * FROM person WHERE id=#&#123;pid&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>PersonMapper.java</p>
<pre><code class="java">public interface PersonMapper &#123;
    User findPersonByid(int id);
&#125;
</code></pre>
</li>
<li><p>测试文件</p>
<pre><code class="java">public class Test01 &#123;
    @Test
    public void selectAll() throws Exception&#123;
        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);
        SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = ssf.openSession(true);
        OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class);
        // 调用实现类的方法，接收结果
        List&lt;Card&gt; list = mapper.selectAll();
        
          // 不能遍历，遍历就是相当于使用了该数据，需要加载，不遍历就是没有使用。
        
        // 释放资源
        sqlSession.close();
        is.close();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><p>同样在一对多关系配置的 <collection> 结点中配置延迟加载策略，<collection> 结点中也有 select 属性和 column 属性</collection></collection></p>
<ul>
<li><p>映射配置文件 OneToManyMapper.xml</p>
<p>一对多映射：</p>
<ul>
<li>column 是用于指定使用哪个字段的值作为条件查询</li>
<li>select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称）</li>
</ul>
<pre><code class="xml">&lt;mapper namespace=&quot;OneToManyMapper&quot;&gt;
    &lt;resultMap id=&quot;oneToMany&quot; type=&quot;bean.Classes&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;

        &lt;!--collection：配置被包含的集合对象映射关系--&gt;
        &lt;collection property=&quot;students&quot; ofType=&quot;bean.Student&quot;
                    column=&quot;id&quot; 
                    select=&quot;one_to_one.StudentMapper.findStudentByCid&quot;&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;selectAll&quot; resultMap=&quot;oneToMany&quot;&gt;
      SELECT * FROM classes
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>StudentMapper.xml</p>
<pre><code class="xml">&lt;mapper namespace=&quot;one_to_one.StudentMapper&quot;&gt;
    &lt;select id=&quot;findPersonByCid&quot; parameterType=&quot;int&quot; resultType=&quot;student&quot;&gt;
        SELECT * FROM person WHERE cid=#&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><div class="story post-story"><h3 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h3><p>注解可以简化开发操作，省略映射配置文件的编写</p>
<p>常用注解：</p>
<ul>
<li>@Select(“查询的 SQL 语句”)：执行查询操作注解</li>
<li>@Insert(“插入的 SQL 语句”)：执行新增操作注解</li>
<li>@Update(“修改的 SQL 语句”)：执行修改操作注解</li>
<li>@Delete(“删除的 SQL 语句”)：执行删除操作注解</li>
</ul>
<p>参数注解：</p>
<ul>
<li>@Param：当 SQL 语句需要<strong>多个（大于1）参数</strong>时，用来指定参数的对应规则</li>
</ul>
<p>核心配置文件配置映射关系：</p>
<pre><code class="xml">&lt;mappers&gt;
    &lt;package name=&quot;使用了注解的Mapper接口所在包&quot;/&gt;
&lt;/mappers&gt;
&lt;!--或者--&gt;
&lt;mappers&gt;
     &lt;mapper class=&quot;包名.Mapper名&quot;&gt;&lt;/mapper&gt;
&lt;/mappers&gt;
</code></pre>
<p>基本增删改查：</p>
<ul>
<li><p>创建 Mapper 接口</p>
<pre><code class="java">package mapper;
public interface StudentMapper &#123;
    //查询全部
    @Select(&quot;SELECT * FROM student&quot;)
    public abstract List&lt;Student&gt; selectAll();

    //新增数据
    @Insert(&quot;INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&quot;)
    public abstract Integer insert(Student student);

    //修改操作
    @Update(&quot;UPDATE student SET name=#&#123;name&#125;,age=#&#123;age&#125; WHERE id=#&#123;id&#125;&quot;)
    public abstract Integer update(Student student);

    //删除操作
    @Delete(&quot;DELETE FROM student WHERE id=#&#123;id&#125;&quot;)
    public abstract Integer delete(Integer id);

&#125;
</code></pre>
</li>
<li><p>修改 MyBatis 的核心配置文件</p>
<pre><code class="xml">&lt;mappers&gt;
    &lt;package name=&quot;mapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
</li>
<li><p>bean类</p>
<pre><code class="java">public class Student &#123;
    private Integer id;
    private String name;
    private Integer age;
&#125;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">@Test
public void selectAll() throws Exception&#123;
    //1.加载核心配置文件
    InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);

    //2.获取SqlSession工厂对象
    SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(is);

    //3.通过工厂对象获取SqlSession对象
    SqlSession sqlSession = ssf.openSession(true);

    //4.获取StudentMapper接口的实现类对象
    StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);

    //5.调用实现类对象中的方法，接收结果
    List&lt;Student&gt; list = mapper.selectAll();

    //6.处理结果
    for (Student student : list) &#123;
        System.out.println(student);
    &#125;
    
    //7.释放资源
    sqlSession.close();
    is.close();
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><h4 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h4><p>实现复杂关系映射之前我们可以在映射文件中通过配置 <resultMap> 来实现，使用注解开发后，可以使用 @Results 注解，@Result 注解，@One 注解，@Many 注解组合完成复杂关系的配置</resultMap></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Results</td>
<td>代替 <resultMap> 标签，注解中使用单个 @Result 注解或者 @Result 集合<br>使用格式：@Results({ @Result(), @Result() })或@Results({ @Result() })</resultMap></td>
</tr>
<tr>
<td>@Result</td>
<td>代替&lt; id&gt; 和 <result> 标签，@Result 中属性介绍：<br>column：数据库的列名      property：封装类的变量名<br>one：需要使用 @One 注解（@Result(one &#x3D; @One)）<br>Many：需要使用 @Many 注解（@Result(many&#x3D; @Many)）</result></td>
</tr>
<tr>
<td>@One(一对一)</td>
<td>代替 <association> 标签，多表查询的关键，用来指定子查询返回单一对象<br>select：指定调用 Mapper 接口中的某个方法<br>使用格式：@Result(column&#x3D;””, property&#x3D;””, one&#x3D;@One(select&#x3D;””))</association></td>
</tr>
<tr>
<td>@Many(多对一)</td>
<td>代替 <collection> 标签，多表查询的关键，用来指定子查询返回对象集合<br>select：指定调用 Mapper 接口中的某个方法<br>使用格式：@Result(column&#x3D;””, property&#x3D;””, many&#x3D;@Many(select&#x3D;””))</collection></td>
</tr>
</tbody></table>
<hr>
<h4 id="一对一-1"><a href="#一对一-1" class="headerlink" title="一对一"></a>一对一</h4><p>身份证对人</p>
<ul>
<li><p>PersonMapper 接口</p>
<pre><code class="java">public interface PersonMapper &#123;
    //根据id查询
    @Select(&quot;SELECT * FROM person WHERE id=#&#123;id&#125;&quot;)
    public abstract Person selectById(Integer id);
&#125;
</code></pre>
</li>
<li><p>CardMapper接口</p>
<pre><code class="java">public interface CardMapper &#123;
    //查询全部
    @Select(&quot;SELECT * FROM card&quot;)
    @Results(&#123;
            @Result(column = &quot;id&quot;,property = &quot;id&quot;),
            @Result(column = &quot;number&quot;,property = &quot;number&quot;),
            @Result(
                    property = &quot;p&quot;,             // 被包含对象的变量名
                    javaType = Person.class,    // 被包含对象的实际数据类型
                    column = &quot;pid&quot;,  // 根据查询出的card表中的pid字段来查询person表
                     /* 
                         one、@One 一对一固定写法
                        select属性：指定调用哪个接口中的哪个方法
                     */
                    one = @One(select = &quot;one_to_one.PersonMapper.selectById&quot;)
            )
    &#125;)
    public abstract List&lt;Card&gt; selectAll();
&#125;
</code></pre>
</li>
<li><p>测试类（详细代码参考单表操作）</p>
<pre><code class="java">//1.加载核心配置文件
//2.获取SqlSession工厂对象
//3.通过工厂对象获取SqlSession对象

//4.获取StudentMapper接口的实现类对象
CardMapper mapper = sqlSession.getMapper(CardMapper.class);
//5.调用实现类对象中的方法，接收结果
List&lt;Card&gt; list = mapper.selectAll();
</code></pre>
</li>
</ul>
<hr>
<h4 id="一对多-1"><a href="#一对多-1" class="headerlink" title="一对多"></a>一对多</h4><p>班级和学生</p>
<ul>
<li><p>StudentMapper接口</p>
<pre><code class="java">public interface StudentMapper &#123;
    //根据cid查询student表  cid是外键约束列
    @Select(&quot;SELECT * FROM student WHERE cid=#&#123;cid&#125;&quot;)
    public abstract List&lt;Student&gt; selectByCid(Integer cid);
&#125;
</code></pre>
</li>
<li><p>ClassesMapper接口</p>
<pre><code class="java">public interface ClassesMapper &#123;
    //查询全部
    @Select(&quot;SELECT * FROM classes&quot;)
    @Results(&#123;
            @Result(column = &quot;id&quot;, property = &quot;id&quot;),
            @Result(column = &quot;name&quot;, property = &quot;name&quot;),
            @Result(
                    property = &quot;students&quot;,  //被包含对象的变量名
                    javaType = List.class,  //被包含对象的实际数据类型
                    column = &quot;id&quot;,          //根据id字段查询student表
                    many = @Many(select = &quot;one_to_many.StudentMapper.selectByCid&quot;)
            )
    &#125;)
    public abstract List&lt;Classes&gt; selectAll();
&#125;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">//4.获取StudentMapper接口的实现类对象
ClassesMapper mapper = sqlSession.getMapper(ClassesMapper.class);
//5.调用实现类对象中的方法，接收结果
List&lt;Classes&gt; classes = mapper.selectAll();
</code></pre>
</li>
</ul>
<hr>
<h4 id="多对多-1"><a href="#多对多-1" class="headerlink" title="多对多"></a>多对多</h4><p>学生和课程</p>
<ul>
<li><p>SQL 查询语句</p>
<pre><code class="mysql">SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id
SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;
</code></pre>
</li>
<li><p>CourseMapper 接口</p>
<pre><code class="java">public interface CourseMapper &#123;
    //根据学生id查询所选课程
    @Select(&quot;SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;&quot;)
    public abstract List&lt;Course&gt; selectBySid(Integer id);
&#125;
</code></pre>
</li>
<li><p>StudentMapper 接口</p>
<pre><code class="java">public interface StudentMapper &#123;
    //查询全部
    @Select(&quot;SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id&quot;)
    @Results(&#123;
            @Result(column = &quot;id&quot;,property = &quot;id&quot;),
            @Result(column = &quot;name&quot;,property = &quot;name&quot;),
            @Result(column = &quot;age&quot;,property = &quot;age&quot;),
            @Result(
                    property = &quot;courses&quot;,    //被包含对象的变量名
                    javaType = List.class,  //被包含对象的实际数据类型
                    column = &quot;id&quot;, //根据查询出的student表中的id字段查询中间表和课程表
                    many = @Many(select = &quot;many_to_many.CourseMapper.selectBySid&quot;)
            )
    &#125;)
    public abstract List&lt;Student&gt; selectAll();
&#125;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">//4.获取StudentMapper接口的实现类对象
StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
//5.调用实现类对象中的方法，接收结果
List&lt;Student&gt; students = mapper.selectAll();
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><div class="story post-story"><h3 id="缓存概述"><a href="#缓存概述" class="headerlink" title="缓存概述"></a>缓存概述</h3><p>缓存：缓存就是一块内存空间，保存临时数据</p>
<p>作用：将数据源（数据库或者文件）中的数据读取出来存放到缓存中，再次获取时直接从缓存中获取，可以减少和数据库交互的次数，提升程序的性能</p>
<p>缓存适用：</p>
<ul>
<li>适用于缓存的：经常查询但不经常修改的，数据的正确与否对最终结果影响不大的</li>
<li>不适用缓存的：经常改变的数据 , 敏感数据（例如：股市的牌价，银行的汇率，银行卡里面的钱）等等</li>
</ul>
<p>缓存类别：</p>
<ul>
<li>一级缓存：SqlSession 级别的缓存，又叫本地会话缓存，自带的（不需要配置），一级缓存的生命周期与 SqlSession 一致。在操作数据库时需要构造 SqlSession 对象，<strong>在对象中有一个数据结构（HashMap）用于存储缓存数据</strong>，不同的 SqlSession 之间的缓存数据区域是互相不影响的</li>
<li>二级缓存：mapper（namespace）级别的缓存，二级缓存的使用，需要手动开启（需要配置）。多个 SqlSession 去操作同一个 Mapper 的 SQL 可以共用二级缓存，二级缓存是跨 SqlSession 的</li>
</ul>
<p>开启缓存：配置核心配置文件中 <settings> 标签</settings></p>
<ul>
<li>cacheEnabled：true 表示全局性地开启所有映射器配置文件中已配置的任何缓存，默认 true</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/7342498.html">https://www.cnblogs.com/ysocean/p/7342498.html</a></p>
<hr>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是 SqlSession 级别的缓存</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-一级缓存.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-一级缓存.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom: 67%;">

<p>工作流程：第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息，得到用户信息，将用户信息存储到一级缓存中；第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。</p>
<p>一级缓存的失效：</p>
<ul>
<li>SqlSession 不同</li>
<li>SqlSession 相同，查询条件不同时（还未缓存该数据）</li>
<li>SqlSession 相同，手动清除了一级缓存，调用 <code>sqlSession.clearCache()</code></li>
<li>SqlSession 相同，执行 commit 操作或者执行插入、更新、删除，清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，<strong>避免脏读</strong></li>
</ul>
<p>Spring 整合 MyBatis 后，一级缓存作用：</p>
<ul>
<li>未开启事务的情况，每次查询 Spring 都会创建新的 SqlSession，因此一级缓存失效</li>
<li>开启事务的情况，Spring 使用 ThreadLocal 获取当前资源绑定同一个 SqlSession，因此此时一级缓存是有效的</li>
</ul>
<p>测试一级缓存存在</p>
<pre><code class="java">public void testFirstLevelCache()&#123;
    //1. 获取sqlSession对象
    SqlSession sqlSession = SqlSessionFactoryUtils.openSession();
    //2. 通过sqlSession对象获取UserDao接口的代理对象
    UserDao userDao1 = sqlSession.getMapper(UserDao.class);
    //3. 调用UserDao接口的代理对象的findById方法获取信息
    User user1 = userDao1.findById(1);
    System.out.println(user1);
    
    //sqlSession.clearCache() 清空缓存
    
       UserDao userDao2 = sqlSession.getMapper(UserDao.class);
    User user = userDao.findById(1);
    System.out.println(user2);
    
    //4.测试两次结果是否一样
    System.out.println(user1 == user2);//true
    
    //5. 提交事务关闭资源
    SqlSessionFactoryUtils.commitAndClose(sqlSession);
&#125;
</code></pre>
<hr>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>二级缓存是 mapper 的缓存，只要是同一个命名空间（namespace）的 SqlSession 就共享二级缓存的内容，并且可以操作二级缓存</p>
<p>作用：作用范围是整个应用，可以跨线程使用，适合缓存一些修改较少的数据</p>
<p>工作流程：一个会话查询数据，这个数据就会被放在当前会话的一级缓存中，如果<strong>会话关闭或提交</strong>一级缓存中的数据会保存到二级缓存</p>
<p>二级缓存的基本使用：</p>
<ol>
<li><p>在 MyBatisConfig.xml 文件开启二级缓存，<strong>cacheEnabled 默认值为 true</strong>，所以这一步可以省略不配置</p>
<pre><code class="xml">&lt;!--配置开启二级缓存--&gt;
&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre>
</li>
<li><p>配置 Mapper 映射文件</p>
<p><code>&lt;cache&gt;</code> 标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值</p>
<pre><code class="xml">&lt;mapper namespace=&quot;dao.UserDao&quot;&gt;
    &lt;!--开启user支持二级缓存--&gt;
       &lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;6000&quot; readOnly=&quot;&quot; size=&quot;1024&quot;/&gt;
    &lt;cache&gt;&lt;/cache&gt; &lt;!--则表示所有属性使用默认值--&gt;
&lt;/mapper&gt;
</code></pre>
<p>eviction（清除策略）：</p>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象，默认</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象</li>
</ul>
<p>flushInterval（刷新间隔）：可以设置为任意的正整数， 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新</p>
<p>size（引用数目）：缓存存放多少元素，默认值是 1024</p>
<p>readOnly（只读）：可以被设置为 true 或 false</p>
<ul>
<li>只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，促进了性能提升</li>
<li>可读写的缓存会（通过序列化）返回缓存对象的拷贝， 速度上会慢一些，但是更安全，因此默认值是 false</li>
</ul>
<p>type：指定自定义缓存的全类名，实现 Cache 接口即可</p>
</li>
<li><p>要进行二级缓存的类必须实现 java.io.Serializable 接口，可以使用序列化方式来保存对象。</p>
<pre><code class="java">public class User implements Serializable&#123;&#125;
</code></pre>
</li>
</ol>
<hr>
<h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><ol>
<li><p>select 标签的 useCache 属性</p>
<p>映射文件中的 <code>&lt;select&gt;</code> 标签中设置 <code>useCache=&quot;true&quot;</code> 代表当前 statement 要使用二级缓存（默认）</p>
<p>注意：如果每次查询都需要最新的数据 sql，要设置成 useCache&#x3D;false，禁用二级缓存</p>
<pre><code class="xml">&lt;select id=&quot;findAll&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
</li>
<li><p>每个增删改标签都有 flushCache 属性，默认为 true，代表在<strong>执行增删改之后就会清除一、二级缓存</strong>，保证缓存的一致性；而查询标签默认值为 false，所以查询不会清空缓存</p>
</li>
<li><p>localCacheScope：本地缓存作用域，<settings> 中的配置项，默认值为 SESSION，当前会话的所有数据保存在会话缓存中，设置为 STATEMENT 禁用一级缓存</settings></p>
</li>
</ol>
<hr>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>事务提交二级缓存才生效：DefaultSqlSession 调用 commit() 时会回调 <code>executor.commit()</code></p>
<ul>
<li><p>CachingExecutor#query()：执行查询方法，查询出的数据会先放入 entriesToAddOnCommit 集合暂存</p>
<pre><code class="java">// 从二缓存中获取数据，获取不到去一级缓存获取
List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);
if (list == null) &#123;
    // 回调 BaseExecutor#query
    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    // 将数据放入 entriesToAddOnCommit 集合暂存，此时还没放入二级缓存
    tcm.putObject(cache, key, list);
&#125;
</code></pre>
</li>
<li><p>commit()：事务提交，<strong>清空一级缓存，放入二级缓存</strong>，二级缓存使用 TransactionalCacheManager（tcm）管理</p>
<pre><code class="java">public void commit(boolean required) throws SQLException &#123;
    // 首先调用 BaseExecutor#commit 方法，【清空一级缓存】
    delegate.commit(required);
    tcm.commit();
&#125;
</code></pre>
</li>
<li><p>TransactionalCacheManager#commit：查询出的数据放入二级缓存</p>
<pre><code class="java">public void commit() &#123;
    // 获取所有的缓存事务，挨着进行提交
    for (TransactionalCache txCache : transactionalCaches.values()) &#123;
        txCache.commit();
    &#125;
&#125;
</code></pre>
<pre><code class="java">public void commit() &#123;
    if (clearOnCommit) &#123;
        delegate.clear();
    &#125;
    // 将 entriesToAddOnCommit 中的数据放入二级缓存
    flushPendingEntries();
    // 清空相关集合
    reset();
&#125;
</code></pre>
<pre><code class="java">private void flushPendingEntries() &#123;
    for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;
        // 将数据放入二级缓存
        delegate.putObject(entry.getKey(), entry.getValue());
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>增删改操作会清空缓存：</p>
<ul>
<li><p>update()：CachingExecutor 的更新操作</p>
<pre><code class="java">public int update(MappedStatement ms, Object parameterObject) throws SQLException &#123;
    flushCacheIfRequired(ms);
    // 回调 BaseExecutor#update 方法，也会清空一级缓存
    return delegate.update(ms, parameterObject);
&#125;
</code></pre>
</li>
<li><p>flushCacheIfRequired()：判断是否需要清空二级缓存</p>
<pre><code class="java">private void flushCacheIfRequired(MappedStatement ms) &#123;
    Cache cache = ms.getCache();
    // 判断二级缓存是否存在，然后判断标签的 flushCache 的值，增删改操作的 flushCache 属性默认为 true
    if (cache != null &amp;&amp; ms.isFlushCacheRequired()) &#123;
        // 清空二级缓存
        tcm.clear(cache);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>自定义缓存</p>
<pre><code class="xml">&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt;
</code></pre>
<p>type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器</p>
<pre><code class="java">public interface Cache &#123;
  String getId();
  int getSize();
  void putObject(Object key, Object value);
  Object getObject(Object key);
  boolean hasKey(Object key);
  Object removeObject(Object key);
  void clear();
&#125;
</code></pre>
<p>缓存的配置，只需要在缓存实现中添加公有的 JavaBean 属性，然后通过 cache 元素传递属性值，例如在缓存实现上调用一个名为 <code>setCacheFile(String file)</code> 的方法：</p>
<pre><code class="xml">&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;&gt;
  &lt;property name=&quot;cacheFile&quot; value=&quot;/tmp/my-custom-cache.tmp&quot;/&gt;
&lt;/cache&gt;
</code></pre>
<ul>
<li>可以使用所有简单类型作为 JavaBean 属性的类型，MyBatis 会进行转换。</li>
<li>可以使用占位符（如 <code>$&#123;cache.file&#125;</code>），以便替换成在配置文件属性中定义的值</li>
</ul>
<p>MyBatis 支持在所有属性设置完毕之后，调用一个初始化方法， 如果想要使用这个特性，可以在自定义缓存类里实现 <code>org.apache.ibatis.builder.InitializingObject</code> 接口</p>
<pre><code class="java">public interface InitializingObject &#123;
  void initialize() throws Exception;
&#125;
</code></pre>
<p>注意：对缓存的配置（如清除策略、可读或可读写等），不能应用于自定义缓存</p>
<p>对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新，在多个命名空间中共享相同的缓存配置和实例，可以使用 cache-ref 元素来引用另一个缓存</p>
<pre><code class="xml">&lt;cache-ref namespace=&quot;com.someone.application.data.SomeMapper&quot;/&gt;
</code></pre>
<hr>
</div><h2 id="构造语句"><a href="#构造语句" class="headerlink" title="构造语句"></a>构造语句</h2><div class="story post-story"><h3 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>动态 SQL 是 MyBatis 强大特性之一，逻辑复杂时，MyBatis 映射配置文件中，SQL 是动态变化的，所以引入动态 SQL 简化拼装 SQL 的操作</p>
<p>DynamicSQL 包含的标签：</p>
<ul>
<li>if</li>
<li>where</li>
<li>set</li>
<li>choose (when、otherwise)</li>
<li>trim</li>
<li>foreach</li>
</ul>
<p>各个标签都可以进行灵活嵌套和组合</p>
<p>OGNL：Object Graphic Navigation Language（对象图导航语言），用于对数据进行访问</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/7289529.html">https://www.cnblogs.com/ysocean/p/7289529.html</a></p>
<hr>
<h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p><where>：条件标签，有动态条件则使用该标签代替 WHERE 关键字，封装查询条件</where></p>
<p>作用：如果标签返回的内容是以 AND 或 OR 开头的，标签内会剔除掉</p>
<p>表结构：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E5%8A%A8%E6%80%81sql%E7%94%A8%E6%88%B7%E8%A1%A8.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E5%8A%A8%E6%80%81sql%E7%94%A8%E6%88%B7%E8%A1%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<hr>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>基本格式：</p>
<pre><code class="xml">&lt;if test=“条件判断”&gt;
    查询条件拼接
&lt;/if&gt;
</code></pre>
<p>我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果username 不同空时还要加入用户名作为条件，这种情况在我们的多条件组合查询中经常会碰到。</p>
<ul>
<li><p>UserMapper.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;selectCondition&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt;
        SELECT * FROM user
        &lt;where&gt;
            &lt;if test=&quot;id != null &quot;&gt;
                id = #&#123;id&#125;
            &lt;/if&gt;
            &lt;if test=&quot;username != null &quot;&gt;
                AND username = #&#123;username&#125;
            &lt;/if&gt;
            &lt;if test=&quot;sex != null &quot;&gt;
                AND sex = #&#123;sex&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;    

&lt;/mapper&gt;
</code></pre>
</li>
<li><p>MyBatisConfig.xml，引入映射配置文件</p>
<pre><code class="xml">&lt;mappers&gt;
    &lt;!--mapper引入指定的映射配置 resource属性执行的映射配置文件的名称--&gt;
    &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
</li>
<li><p>DAO 层 Mapper 接口</p>
<pre><code class="java">public interface UserMapper &#123;
    //多条件查询
    public abstract List&lt;User&gt; selectCondition(Student stu);
&#125;
</code></pre>
</li>
<li><p>实现类</p>
<pre><code class="java">public class DynamicTest &#123;
    @Test
    public void selectCondition() throws Exception&#123;
        //1.加载核心配置文件
        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);

        //2.获取SqlSession工厂对象
        SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(is);

        //3.通过工厂对象获取SqlSession对象
        SqlSession sqlSession = ssf.openSession(true);

        //4.获取StudentMapper接口的实现类对象
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        User user = new User();
        user.setId(2);
        user.setUsername(&quot;李四&quot;);
        //user.setSex(男); AND 后会自动剔除

        //5.调用实现类的方法，接收结果
        List&lt;Student&gt; list = mapper.selectCondition(user);

        //6.处理结果
        for (User user : list) &#123;
            System.out.println(user);
        &#125;
        
        //7.释放资源
        sqlSession.close();
        is.close();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><set>：进行更新操作的时候，含有 set 关键词，使用该标签</set></p>
<pre><code class="xml">&lt;!-- 根据 id 更新 user 表的数据 --&gt;
&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;
    UPDATE user u
        &lt;set&gt;
            &lt;if test=&quot;username != null and username != &#39;&#39;&quot;&gt;
                u.username = #&#123;username&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;sex != null and sex != &#39;&#39;&quot;&gt;
                u.sex = #&#123;sex&#125;
            &lt;/if&gt;
        &lt;/set&gt;
     WHERE id=#&#123;id&#125;
&lt;/update&gt;
</code></pre>
<ul>
<li>如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex&#x3D;? where id&#x3D;?</li>
<li>如果第一个条件不为空，那么 sql 语句为：update user u set u.username &#x3D; ? ,u.sex &#x3D; ? where id&#x3D;?</li>
</ul>
<hr>
<h4 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h4><p>假如不想用到所有的查询条件，只要查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p>
<p>标签：<when>，<otherwise></otherwise></when></p>
<pre><code class="xml">&lt;select id=&quot;selectUserByChoose&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt;
    SELECT * FROM user
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test=&quot;id !=&#39;&#39; and id != null&quot;&gt;
                id=#&#123;id&#125;
            &lt;/when&gt;
            &lt;when test=&quot;username !=&#39;&#39; and username != null&quot;&gt;
                AND username=#&#123;username&#125;
            &lt;/when&gt;
            &lt;otherwise&gt;
                AND sex=#&#123;sex&#125;
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>有三个条件，id、username、sex，只能选择一个作为查询条件</p>
<ul>
<li><p>如果 id 不为空，那么查询语句为：select * from user where  id&#x3D;?</p>
</li>
<li><p>如果 id 为空，那么看 username 是否为空</p>
<ul>
<li>如果不为空，那么语句为：select * from user where username&#x3D;?</li>
<li>如果 username 为空，那么查询语句为 select * from user where sex&#x3D;?</li>
</ul>
</li>
</ul>
<hr>
<h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>trim 标记是一个格式化的标记，可以完成 set 或者是 where 标记的功能，自定义字符串截取</p>
<ul>
<li>prefix：给拼串后的整个字符串加一个前缀，trim 标签体中是整个字符串拼串后的结果</li>
<li>prefixOverrides：去掉整个字符串前面多余的字符</li>
<li>suffix：给拼串后的整个字符串加一个后缀</li>
<li>suffixOverrides：去掉整个字符串后面多余的字符</li>
</ul>
<p>改写 if + where 语句：</p>
<pre><code class="xml">&lt;select id=&quot;selectUserByUsernameAndSex&quot; resultType=&quot;user&quot; parameterType=&quot;com.ys.po.User&quot;&gt;
    SELECT * FROM user
    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&gt;
        &lt;if test=&quot;username != null&quot;&gt;
            AND username=#&#123;username&#125;
        &lt;/if&gt;
        &lt;if test=&quot;sex != null&quot;&gt;
            AND sex=#&#123;sex&#125;
        &lt;/if&gt;
    &lt;/trim&gt;
&lt;/select&gt;
</code></pre>
<p>改写 if + set 语句：</p>
<pre><code class="xml">&lt;!-- 根据 id 更新 user 表的数据 --&gt;
&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;
    UPDATE user u
    &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;
        &lt;if test=&quot;username != null and username != &#39;&#39;&quot;&gt;
            u.username = #&#123;username&#125;,
        &lt;/if&gt;
        &lt;if test=&quot;sex != null and sex != &#39;&#39;&quot;&gt;
            u.sex = #&#123;sex&#125;,
        &lt;/if&gt;
    &lt;/trim&gt;
    WHERE id=#&#123;id&#125;
&lt;/update&gt;
</code></pre>
<hr>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>基本格式：</p>
<pre><code class="xml">&lt;foreach&gt;：循环遍历标签。适用于多个参数或者的关系。
    &lt;foreach collection=“”open=“”close=“”item=“”separator=“”&gt;
        获取参数
&lt;/foreach&gt;
</code></pre>
<p>属性：</p>
<ul>
<li>collection：参数容器类型， (list-集合， array-数组)</li>
<li>open：开始的 SQL 语句</li>
<li>close：结束的 SQL 语句</li>
<li>item：参数变量名</li>
<li>separator：分隔符</li>
</ul>
<p>需求：循环执行 sql 的拼接操作，<code>SELECT * FROM user WHERE id IN (1,2,5)</code></p>
<ul>
<li><p>UserMapper.xml片段</p>
<pre><code class="xml">&lt;select id=&quot;selectByIds&quot; resultType=&quot;user&quot; parameterType=&quot;list&quot;&gt;
    SELECT * FROM student
    &lt;where&gt;
        &lt;foreach collection=&quot;list&quot; open=&quot;id IN(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
            #&#123;id&#125;
        &lt;/foreach&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
</li>
<li><p>测试代码片段</p>
<pre><code class="java">//4.获取StudentMapper接口的实现类对象
UserMapper mapper = sqlSession.getMapper(UserMapper.class);

List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();
Collections.addAll(list, 1, 2);
//5.调用实现类的方法，接收结果
List&lt;User&gt; list = mapper.selectByIds(ids);

for (User user : list) &#123;
    System.out.println(user);
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h4><p>将一些重复性的 SQL 语句进行抽取，以达到复用的效果</p>
<p>格式：</p>
<pre><code class="xml">&lt;sql id=“片段唯一标识”&gt;抽取的SQL语句&lt;/sql&gt;        &lt;!--抽取标签--&gt;
&lt;include refid=“片段唯一标识”/&gt;                &lt;!--引入标签--&gt;
</code></pre>
<p>使用：</p>
<pre><code class="xml">&lt;sql id=&quot;select&quot;&gt;SELECT * FROM user&lt;/sql&gt;

&lt;select id=&quot;selectByIds&quot; resultType=&quot;user&quot; parameterType=&quot;list&quot;&gt;
    &lt;include refid=&quot;select&quot;/&gt;
    &lt;where&gt;
        &lt;foreach collection=&quot;list&quot; open=&quot;id IN(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
            #&#123;id&#125;
        &lt;/foreach&gt;
    &lt;/where&gt;
 &lt;/select&gt;
</code></pre>
<hr>
<h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>MyBatis 逆向工程，可以针对<strong>单表</strong>自动生成 MyBatis 执行所需要的代码（mapper.java、mapper.xml、pojo…）</p>
<p>generatorConfig.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
 
&lt;generatorConfiguration&gt;
    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
        &lt;commentGenerator&gt;
            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;
            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;
        &lt;/commentGenerator&gt;
        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;
        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatisrelation&quot; userId=&quot;root&quot;
            password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;
 
        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --&gt;
        &lt;javaTypeResolver&gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;
        &lt;/javaTypeResolver&gt;
 
        &lt;!-- targetProject:生成PO类的位置！！ --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.ys.po&quot;
            targetProject=&quot;.\src&quot;&gt;
            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;
        &lt;/javaModelGenerator&gt;
        &lt;!-- targetProject:mapper映射文件生成的位置！！ --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;com.ys.mapper&quot;
            targetProject=&quot;.\src&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
        &lt;/sqlMapGenerator&gt;
        &lt;!-- targetPackage：mapper接口生成的位置，重要！！ --&gt;
        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;
            targetPackage=&quot;com.ys.mapper&quot;
            targetProject=&quot;.\src&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
        &lt;/javaClientGenerator&gt;
        &lt;!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --&gt;
        &lt;table tableName=&quot;items&quot;&gt;&lt;/table&gt;
        &lt;table tableName=&quot;orders&quot;&gt;&lt;/table&gt;
        &lt;table tableName=&quot;orderdetail&quot;&gt;&lt;/table&gt;
        &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt;       
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<p>生成代码：</p>
<pre><code class="java">public void testGenerator() throws Exception&#123;
    List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
    boolean overwrite = true;
    //指向逆向工程配置文件
    File configFile = new File(GeneratorTest.class.
                               getResource(&quot;/generatorConfig.xml&quot;).getFile());
    ConfigurationParser cp = new ConfigurationParser(warnings);
    Configuration config = cp.parseConfiguration(configFile);
    DefaultShellCallback callback = new DefaultShellCallback(overwrite);
    MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                                                             callback, warnings);
    myBatisGenerator.generate(null);

&#125;
</code></pre>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/7360409.html">https://www.cnblogs.com/ysocean/p/7360409.html</a></p>
<hr>
<h3 id="构建-SQL"><a href="#构建-SQL" class="headerlink" title="构建 SQL"></a>构建 SQL</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p>MyBatis 提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句    </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT(String… columns)</td>
<td>根据字段拼接查询语句</td>
</tr>
<tr>
<td>FROM(String… tables)</td>
<td>根据表名拼接语句</td>
</tr>
<tr>
<td>WHERE(String… conditions)</td>
<td>根据条件拼接语句</td>
</tr>
<tr>
<td>INSERT_INTO(String tableName)</td>
<td>根据表名拼接新增语句</td>
</tr>
<tr>
<td>INTO_VALUES(String… values)</td>
<td>根据值拼接新增语句</td>
</tr>
<tr>
<td>UPDATE(String table)</td>
<td>根据表名拼接修改语句</td>
</tr>
<tr>
<td>DELETE_FROM(String table)</td>
<td>根据表名拼接删除语句</td>
</tr>
</tbody></table>
<p>增删改查注解：</p>
<ul>
<li>@SelectProvider：生成查询用的 SQL 语句</li>
<li>@InsertProvider：生成新增用的 SQL 语句</li>
<li>@UpdateProvider：生成修改用的 SQL 语句注解</li>
<li>@DeleteProvider：生成删除用的 SQL 语句注解。<ul>
<li>type 属性：生成 SQL 语句功能类对象 </li>
<li>method 属性：指定调用方法</li>
</ul>
</li>
</ul>
<hr>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>MyBatisConfig.xml 配置</p>
<pre><code class="xml"> &lt;!-- mappers引入映射配置文件 --&gt;
&lt;mappers&gt;
    &lt;package name=&quot;mapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
</li>
<li><p>Mapper 类</p>
<pre><code class="java">public interface StudentMapper &#123;
    //查询全部
    @SelectProvider(type = ReturnSql.class, method = &quot;getSelectAll&quot;)
    public abstract List&lt;Student&gt; selectAll();

    //新增数据
    @InsertProvider(type = ReturnSql.class, method = &quot;getInsert&quot;)
    public abstract Integer insert(Student student);

    //修改操作
    @UpdateProvider(type = ReturnSql.class, method = &quot;getUpdate&quot;)
    public abstract Integer update(Student student);

    //删除操作
    @DeleteProvider(type = ReturnSql.class, method = &quot;getDelete&quot;)
    public abstract Integer delete(Integer id);

&#125;
</code></pre>
</li>
<li><p>ReturnSQL 类</p>
<pre><code class="java">public class ReturnSql &#123;
    //定义方法，返回查询的sql语句
    public String getSelectAll() &#123;
        return new SQL() &#123;
            &#123;
                SELECT(&quot;*&quot;);
                FROM(&quot;student&quot;);
            &#125;
        &#125;.toString();
    &#125;

    //定义方法，返回新增的sql语句
    public String getInsert(Student stu) &#123;
        return new SQL() &#123;
            &#123;
                INSERT_INTO(&quot;student&quot;);
                INTO_VALUES(&quot;#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;&quot;);
            &#125;
        &#125;.toString();
    &#125;

    //定义方法，返回修改的sql语句
    public String getUpdate(Student stu) &#123;
        return new SQL() &#123;
            &#123;
                UPDATE(&quot;student&quot;);
                SET(&quot;name=#&#123;name&#125;&quot;,&quot;age=#&#123;age&#125;&quot;);
                WHERE(&quot;id=#&#123;id&#125;&quot;);
            &#125;
        &#125;.toString();
    &#125;

    //定义方法，返回删除的sql语句
    public String getDelete(Integer id) &#123;
        return new SQL() &#123;
            &#123;
                DELETE_FROM(&quot;student&quot;);
                WHERE(&quot;id=#&#123;id&#125;&quot;);
            &#125;
        &#125;.toString();
    &#125;
&#125;
</code></pre>
</li>
<li><p>功能实现类</p>
<pre><code class="java">public class SqlTest &#123;    
    @Test  //查询全部
    public void selectAll() throws Exception&#123;
        //1.加载核心配置文件
        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);

        //2.获取SqlSession工厂对象
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);

        //3.通过工厂对象获取SqlSession对象
        SqlSession sqlSession = sqlSessionFactory.openSession(true);

        //4.获取StudentMapper接口的实现类对象
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);

        //5.调用实现类对象中的方法，接收结果
        List&lt;Student&gt; list = mapper.selectAll();

        //6.处理结果
        for (Student student : list) &#123;
            System.out.println(student);
        &#125;

        //7.释放资源
        sqlSession.close();
        is.close();
    &#125;
    
    @Test  //新增
    public void insert() throws Exception&#123;
        //1 2 3 4获取StudentMapper接口的实现类对象
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);

        //5.调用实现类对象中的方法，接收结果 -&gt;6 7
        Student stu = new Student(4,&quot;赵六&quot;,26);
        Integer result = mapper.insert(stu);
    &#125;
    
    @Test //修改
    public void update() throws Exception&#123;
        //1 2 3 4 5调用实现类对象中的方法，接收结果 -&gt;6 7 
        Student stu = new Student(4,&quot;赵六wq&quot;,36);
        Integer result = mapper.update(stu);
    &#125;
    @Test //删除
    public void delete() throws Exception&#123;
        //1 2 3 4 5 6 7
        Integer result = mapper.delete(4);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><div class="story post-story"><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>MyBatis 运行过程：</p>
<ol>
<li><p>加载 MyBatis 全局配置文件，通过 XPath 方式解析 XML 配置文件，首先解析核心配置文件，<settings> 标签中配置属性项有 defaultExecutorType，用来配置指定 Executor 类型，将配置文件的信息填充到 Configuration对象。最后解析映射器配置的映射文件，并<strong>构建 MappedStatement 对象填充至 Configuration</strong>，将解析后的映射器添加到 mapperRegistry 中，用于获取代理</settings></p>
</li>
<li><p>创建一个 DefaultSqlSession 对象，<strong>根据参数创建指定类型的 Executor</strong>，二级缓存默认开启，把 Executor 包装成缓存执行器</p>
</li>
<li><p>DefaulSqlSession 调用 getMapper()，通过 JDK 动态代理获取 Mapper 接口的代理对象 MapperProxy </p>
</li>
<li><p>执行 SQL 语句：</p>
<ul>
<li>MapperProxy.invoke() 执行代理方法，通过 MapperMethod#execute 判断执行的是增删改查中的哪个方法</li>
<li>查询方法调用 sqlSession.selectOne()，从 Configuration 中获取执行者对象 MappedStatement，然后 Executor 调用 executor.query 开始执行查询方法</li>
<li>首先通过 CachingExecutor 去二级缓存查询，查询不到去一级缓存查询，<strong>最后去数据库查询并放入一级缓存</strong></li>
<li>Configuration 对象根据 <select> 标签的 statementType 属性创建 StatementHandler 对象，在 StatementHandler 的构造方法中，创建了 ParameterHandler 和 ResultSetHandler 对象</select></li>
<li>最后获取 <strong>JDBC 原生的</strong> Connection 数据库连接对象，创建 Statement 执行者对象，然后通过 ParameterHandler 设置预编译参数，底层是 TypeHandler#setParameter 方法，然后通过 StatementHandler 回调执行者对象执行增删改查，最后调用 ResultsetHandler 处理查询结果</li>
</ul>
</li>
</ol>
<p><strong>四大对象</strong>：</p>
<ul>
<li>StatementHandler：执行 SQL 语句的对象</li>
<li>ParameterHandler：设置预编译参数用的</li>
<li>ResultHandler：处理结果集</li>
<li>Executor：执行器，真正进行 Java 与数据库交互的对象</li>
</ul>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mW411M737?p=71">https://www.bilibili.com/video/BV1mW411M737?p=71</a></p>
<hr>
<h3 id="获取工厂"><a href="#获取工厂" class="headerlink" title="获取工厂"></a>获取工厂</h3><p>SqlSessionFactoryBuilder.build(InputStream, String,  Properties)：构建工厂</p>
<p>XMLConfigBuilder.parse()：解析核心配置文件每个标签的信息（<strong>XPath</strong>）</p>
<ul>
<li><p><code>parseConfiguration(parser.evalNode(&quot;/configuration&quot;))</code>：读取节点内数据，<configuration> 是 MyBatis 配置文件中的顶层标签</configuration></p>
<p><code>settings = settingsAsProperties(root.evalNode(&quot;settings&quot;))</code>：读取核心配置文件中的 <settings> 标签</settings></p>
<p><code>settingsElement(settings)</code>：设置框架相关的属性</p>
<ul>
<li><code>configuration.setCacheEnabled()</code>：<strong>设置缓存属性，默认是 true</strong></li>
<li><code>configuration.setDefaultExecutorType()</code>：<strong>设置 Executor 类型到 configuration，默认是 SIMPLE</strong></li>
</ul>
<p><code>mapperElement(root.evalNode(&quot;mappers&quot;))</code>：解析 mappers 信息，分为 package 和 单个注册两种</p>
<ul>
<li><p><code>if...else...</code>：根据映射方法选择合适的读取方式</p>
</li>
<li><p><code>XMLMapperBuilder.parse()</code>：解析 mapper 的标签的信息</p>
<ul>
<li><p><code>configurationElement(parser.evalNode(&quot;/mapper&quot;))</code>：解析 mapper 文件，顶层节点 <mapper></mapper></p>
<ul>
<li><p><code>buildStatementFromContext(context.evalNodes(&quot;select...&quot;))</code>：解析<strong>每个操作标签</strong></p>
<p><code>XMLStatementBuilder.parseStatementNode()</code>：解析<strong>操作标签</strong>的所有的属性</p>
<p><code>builderAssistant.addMappedStatement(...)</code>：<strong>封装成 MappedStatement 对象加入 Configuration 对象</strong>，代表一个增删改查的标签</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass)</code>：加载 Mapper 接口</p>
</li>
<li><p><code>Configuration.addMappers()</code>：将核心配置文件配置的映射器添加到 mapperRegistry 中，用来<strong>获取代理对象</strong></p>
<ul>
<li><p><code>MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type)</code>：创建<strong>注解</strong>解析器</p>
</li>
<li><p><code>parser.parse()</code>：解析 Mapper 接口</p>
<ul>
<li><p><code>SqlSource sqlSource = getSqlSourceFromAnnotations()</code>：获取 SQL 的资源对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-SQL%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-SQL%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
<li><p><code>builderAssistant.addMappedStatement(...)</code>：封装成 MappedStatement 对象加入 Configuration 对象</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>return configuration</code>：返回配置完成的 configuration 对象</p>
</li>
</ul>
<p>return new DefaultSqlSessionFactory(config)：返回工厂对象，包含 Configuration 对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%8E%82%E5%AF%B9%E8%B1%A1.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%8E%82%E5%AF%B9%E8%B1%A1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>总结：解析 XML 是对 Configuration 中的属性进行填充，那么可以在一个类中创建 Configuration 对象，自定义其中属性的值来达到配置的效果</p>
<hr>
<h3 id="获取会话"><a href="#获取会话" class="headerlink" title="获取会话"></a>获取会话</h3><p>DefaultSqlSessionFactory.openSession()：获取 Session 对象，并且创建 Executor 对象</p>
<p>DefaultSqlSessionFactory.openSessionFromDataSource(…)：ExecutorType 为 Executor 的类型，TransactionIsolationLevel 为事务隔离级别，autoCommit 是否开启事务</p>
<ul>
<li><p><code>transactionFactory.newTransaction(DataSource, IsolationLevel, boolean</code>：事务对象</p>
</li>
<li><p><code>configuration.newExecutor(tx, execType)</code>：<strong>根据参数创建指定类型的 Executor</strong></p>
<ul>
<li>批量操作笔记的部分有讲解到 <setting> 的属性 defaultExecutorType，根据配置创建对象</setting></li>
<li><strong>二级缓存默认开启</strong>，会包装 Executor 对象 <code>new CachingExecutor(executor)</code></li>
</ul>
</li>
</ul>
<p> return new DefaultSqlSession(configuration, executor, autoCommit)：返回 DefaultSqlSession 对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E4%BC%9A%E8%AF%9D%E5%AF%B9%E8%B1%A1.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E4%BC%9A%E8%AF%9D%E5%AF%B9%E8%B1%A1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<hr>
<h3 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h3><p>Configuration.getMapper(Class, SqlSession)：获取代理的 mapper 对象</p>
<p>MapperRegistry.getMapper(Class, SqlSession)：MapperRegistry 是 Configuration 属性，在获取工厂对象时初始化</p>
<ul>
<li><code>(MapperProxyFactory&lt;T&gt;) knownMappers.get(type)</code>：获取接口信息封装为 MapperProxyFactory 对象</li>
<li><code>mapperProxyFactory.newInstance(sqlSession)</code>：<strong>创建代理对象</strong><ul>
<li><code>new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache)</code>：包装对象<ul>
<li>methodCache 是并发安全的 ConcurrentHashMap 集合，存放要执行的方法</li>
<li><code>MapperProxy&lt;T&gt; implements InvocationHandler</code> 说明 MapperProxy 默认是一个 InvocationHandler 对象</li>
</ul>
</li>
<li><code>Proxy.newProxyInstance()</code>：<strong>JDK 动态代理</strong>创建 MapperProxy 对象</li>
</ul>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<hr>
<h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><p>MapperProxy.invoke()：执行 SQL 语句，Object 类的方法直接执行</p>
<pre><code class="java">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
    try &#123;
        // 当前方法是否是属于 Object 类中的方法
        if (Object.class.equals(method.getDeclaringClass())) &#123;
            return method.invoke(this, args);
            // 当前方法是否是默认方法
        &#125; else if (isDefaultMethod(method)) &#123;
            return invokeDefaultMethod(proxy, method, args);
        &#125;
    &#125; catch (Throwable t) &#123;
        throw ExceptionUtil.unwrapThrowable(t);
    &#125;
    // 包装成一个 MapperMethod 对象并初始化该对象
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    // 【根据 switch-case 判断使用的什么类型的 SQL 进行逻辑处理】，此处分析查询语句的查询操作
    return mapperMethod.execute(sqlSession, args);
&#125;
</code></pre>
<p>sqlSession.selectOne(String, Object)：查询数据</p>
<pre><code class="java">public Object execute(SqlSession sqlSession, Object[] args) &#123;
    //.....
    // 解析传入的参数
    Object param = method.convertArgsToSqlCommandParam(args);
    result = sqlSession.selectOne(command.getName(), param);
&#125;
// DefaultSqlSession.selectList(String, Object)
public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;
    // 获取执行者对象
    MappedStatement ms = configuration.getMappedStatement(statement);
    // 开始执行查询语句，参数通过 wrapCollection() 包装成集合类
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
&#125;
</code></pre>
<p>Executor#query()：</p>
<ul>
<li><p><code>CachingExecutor.query()</code>：先执行 CachingExecutor 去二级缓存获取数据</p>
<pre><code class="java">public class CachingExecutor implements Executor &#123;
  private final Executor delegate;        // 包装了 BaseExecutor，二级缓存不存在数据调用 BaseExecutor 查询
&#125;
</code></pre>
<ul>
<li><p><code>MappedStatement.getBoundSql(parameterObject)</code>：<strong>把 parameterObject 封装成 BoundSql</strong></p>
<p>构造函数中有：<code>this.parameterObject = parameterObject</code></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-boundSql%E5%AF%B9%E8%B1%A1.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-boundSql%E5%AF%B9%E8%B1%A1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
<li><p><code>CachingExecutor.createCacheKey()</code>：创建缓存对象</p>
</li>
<li><p><code>ms.getCache()</code>：获取二级缓存</p>
</li>
<li><p><code>tcm.getObject(cache, key)</code>：尝试从<strong>二级缓存</strong>中获取数据</p>
</li>
</ul>
</li>
<li><p><code>BaseExecutor.query()</code>：二级缓存不存在该数据，调用该方法</p>
<ul>
<li><code>localCache.getObject(key) </code>：尝试从<strong>本地缓存（一级缓存</strong>）获取数据</li>
</ul>
</li>
<li><p><code>BaseExecutor.queryFromDatabase()</code>：缓存获取数据失败，<strong>开始从数据库获取数据，并放入本地缓存</strong></p>
<ul>
<li><p><code>SimpleExecutor.doQuery()</code>：执行 query</p>
<ul>
<li><p><code>configuration.newStatementHandler()</code>：创建 StatementHandler 对象</p>
<ul>
<li>根据 <select> 标签的 statementType 属性，根据属性选择创建哪种对象</select></li>
<li>判断 BoundSql 是否被创建，没有创建会重新封装参数信息到 BoundSql</li>
<li><strong>StatementHandler 的构造方法中，创建了 ParameterHandler 和 ResultSetHandler 对象</strong></li>
<li><code>interceptorChain.pluginAll(statementHandler)</code>：拦截器链</li>
</ul>
</li>
<li><p><code>prepareStatement()</code>：通过 StatementHandler 创建 JDBC 原生的 Statement 对象</p>
<ul>
<li><code>getConnection()</code>：<strong>获取 JDBC 的 Connection 对象</strong></li>
<li><code>handler.prepare()</code>：初始化 Statement 对象<ul>
<li><code>instantiateStatement(Connection connection)</code>：Connection  中的方法实例化对象<ul>
<li>获取普通执行者对象：<code>Connection.createStatement()</code></li>
<li><strong>获取预编译执行者对象</strong>：<code>Connection.prepareStatement()</code></li>
</ul>
</li>
</ul>
</li>
<li><code>handler.parameterize()</code>：进行参数的设置<ul>
<li><code>ParameterHandler.setParameters()</code>：<strong>通过 ParameterHandler 设置参数</strong><ul>
<li><code>typeHandler.setParameter()</code>：底层通过 TypeHandler 实现，回调 JDBC 的接口进行设置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>StatementHandler.query()</code>：<strong>调用 JDBC 原生的 PreparedStatement 执行 SQL</strong></p>
<pre><code class="java">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) &#123;
    // 获取 SQL 语句
    String sql = boundSql.getSql();
    statement.execute(sql);
    // 通过 ResultSetHandler 对象封装结果集，映射成 JavaBean
    return resultSetHandler.handleResultSets(statement);
  &#125;
</code></pre>
<p><code>resultSetHandler.handleResultSets(statement)</code>：处理结果集</p>
<ul>
<li><p><code>handleResultSet(rsw, resultMap, multipleResults, null)</code>：底层回调</p>
<ul>
<li><p><code>handleRowValues()</code>：逐行处理数据，根据是否配置了 <resultMap> 属性选择是否使用简单结果集映射</resultMap></p>
<ul>
<li><p>首先判断数据是否被限制行数，然后进行结果集的映射</p>
</li>
<li><p>最后将数据存入 ResultHandler 对象，底层就是 List 集合</p>
<pre><code class="java">public class DefaultResultHandler implements ResultHandler&lt;Object&gt; &#123;
    private final List&lt;Object&gt; list;
      public void handleResult(ResultContext&lt;?&gt; context) &#123;
        list.add(context.getResultObject());
      &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>return collapseSingleResultList(multipleResults)</code>：可能存在多个结果集的情况</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>localCache.putObject(key, list)</code>：<strong>放入一级（本地）缓存</strong></p>
</li>
</ul>
</li>
</ul>
<p><code>return list.get(0)</code>：返回结果集的第一个数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E6%89%A7%E8%A1%8CSQL%E8%BF%87%E7%A8%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E6%89%A7%E8%A1%8CSQL%E8%BF%87%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<hr>
</div><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><div class="story post-story"><h3 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h3><p>实现原理：插件是按照插件配置顺序创建层层包装对象，执行目标方法的之后，按照逆向顺序执行（栈）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-插件原理.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-插件原理.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:50%;">

<p>在四大对象创建时：</p>
<ul>
<li>每个创建出来的对象不是直接返回的，而是 <code>interceptorChain.pluginAll(parameterHandler)</code></li>
<li>获取到所有 Interceptor（插件需要实现的接口），调用 <code>interceptor.plugin(target)</code>返回 target 包装后的对象</li>
<li>插件机制可以使用插件为目标对象创建一个代理对象，代理对象可以<strong>拦截到四大对象的每一个执行</strong></li>
</ul>
<pre><code class="java">@Intercepts(
        &#123;
        @Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)
        &#125;)
public class MyFirstPlugin implements Interceptor&#123;

    //intercept：拦截目标对象的目标方法的执行
    @Override
    public Object intercept(Invocation invocation) throws Throwable &#123;
        System.out.println(&quot;MyFirstPlugin...intercept:&quot; + invocation.getMethod());
        //动态的改变一下sql运行的参数：以前1号员工，实际从数据库查询11号员工
        Object target = invocation.getTarget();
        System.out.println(&quot;当前拦截到的对象：&quot; + target);
        //拿到：StatementHandler==&gt;ParameterHandler===&gt;parameterObject
        //拿到target的元数据
        MetaObject metaObject = SystemMetaObject.forObject(target);
        Object value = metaObject.getValue(&quot;parameterHandler.parameterObject&quot;);
        System.out.println(&quot;sql语句用的参数是：&quot; + value);
        //修改完sql语句要用的参数
        metaObject.setValue(&quot;parameterHandler.parameterObject&quot;, 11);
        //执行目标方法
        Object proceed = invocation.proceed();
        //返回执行后的返回值
        return proceed;
    &#125;

    // plugin：包装目标对象的，为目标对象创建一个代理对象
    @Override
    public Object plugin(Object target) &#123;
        //可以借助 Plugin 的 wrap 方法来使用当前 Interceptor 包装我们目标对象
        System.out.println(&quot;MyFirstPlugin...plugin:mybatis将要包装的对象&quot; + target);
        Object wrap = Plugin.wrap(target, this);
        //返回为当前target创建的动态代理
        return wrap;
    &#125;

    // setProperties：将插件注册时的property属性设置进来
    @Override
    public void setProperties(Properties properties) &#123;
        System.out.println(&quot;插件配置的信息：&quot; + properties);
    &#125;
&#125;
</code></pre>
<p>核心配置文件：</p>
<pre><code class="xml">&lt;!--plugins：注册插件  --&gt;
&lt;plugins&gt;
    &lt;plugin interceptor=&quot;mybatis.dao.MyFirstPlugin&quot;&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<hr>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E5%88%86%E9%A1%B5%E4%BB%8B%E7%BB%8D.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E5%88%86%E9%A1%B5%E4%BB%8B%E7%BB%8D.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ul>
<li>分页可以将很多条结果进行分页显示。如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页，需要明确当前是第几页，这一页中显示多少条结果。  </li>
<li>MyBatis 是不带分页功能的，如果想实现分页功能，需要手动编写 LIMIT 语句，不同的数据库实现分页的 SQL 语句也是不同，手写分页 成本较高。</li>
<li>PageHelper：第三方分页助手，将复杂的分页操作进行封装，从而让分页功能变得非常简单</li>
</ul>
<hr>
<h3 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h3><p>开发步骤：</p>
<ol>
<li><p>导入 PageHelper 的 Maven 坐标</p>
</li>
<li><p>在 MyBatis 核心配置文件中配置 PageHelper 插件</p>
<p>注意：分页助手的插件配置在通用 Mapper 之前</p>
<pre><code class="xml">&lt;plugins&gt;
    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
        &lt;!-- 指定方言 --&gt;
        &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;
    &lt;/plugin&gt; 
&lt;/plugins&gt;
&lt;mappers&gt;.........&lt;/mappers&gt;
</code></pre>
</li>
<li><p>与 MySQL 分页查询页数计算公式不同</p>
<p><code>static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize)</code>：pageNum第几页，pageSize页面大小</p>
<pre><code class="java">@Test
public void selectAll() &#123;
    //第一页：显示2条数据
    PageHelper.startPage(1,2);
    List&lt;Student&gt; students = sqlSession.selectList(&quot;StudentMapper.selectAll&quot;);
    for (Student student : students) &#123;
        System.out.println(student);
    &#125;
&#125;
</code></pre>
</li>
</ol>
<hr>
<h3 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h3><p>PageInfo构造方法：</p>
<ul>
<li><code>PageInfo&lt;Student&gt; info = new PageInfo&lt;&gt;(list)</code> : list 是 SQL 执行返回的结果集合，参考上一节</li>
</ul>
<p>PageInfo相关API：</p>
<ol>
<li>startPage()：设置分页参数 </li>
<li>PageInfo：分页相关参数功能类。 </li>
<li>getTotal()：获取总条数 </li>
<li>getPages()：获取总页数</li>
<li>getPageNum()：获取当前页</li>
<li>getPageSize()：获取每页显示条数</li>
<li>getPrePage()：获取上一页 </li>
<li>getNextPage()：获取下一页 </li>
<li>isIsFirstPage()：获取是否是第一页 </li>
<li>isIsLastPage()：获取是否是最后一页</li>
</ol>
<hr>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1></div><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><div class="story post-story"><p>Spring 是分层的 JavaSE&#x2F;EE 应用 full-stack 轻量级开源框架</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>Spring 优点：</p>
<ul>
<li>方便解耦，简化开发</li>
<li>方便集成各种框架</li>
<li>方便程序测试</li>
<li>AOP 编程难过的支持</li>
<li>声明式事务的支持</li>
<li>降低 JavaEE API 的使用难度</li>
</ul>
<p>体系结构：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>参考视频：<a target="_blank" rel="noopener" href="https://space.bilibili.com/37974444">https://space.bilibili.com/37974444</a></p>
<hr>
</div><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><div class="story post-story"><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><ul>
<li>IoC（Inversion Of Control）控制反转，Spring 反向控制应用程序所需要使用的外部资源</li>
<li><strong>Spring 控制的资源全部放置在 Spring 容器中，该容器称为 IoC 容器</strong>（存放实例对象）</li>
<li>官方网站：<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/</a> → Projects → spring-framework → LEARN → Reference Doc</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E4%BB%8B%E7%BB%8D.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E4%BB%8B%E7%BB%8D.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ul>
<li>耦合（Coupling）：代码编写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度</li>
<li>内聚（Cohesion）：代码编写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系</li>
<li>代码编写的目标：高内聚，低耦合。同一个模块内的各个元素之间要高度紧密，各个模块之间的相互依存度不紧密</li>
</ul>
<hr>
<h3 id="入门项目"><a href="#入门项目" class="headerlink" title="入门项目"></a>入门项目</h3><p>模拟三层架构中表现层调用业务层功能</p>
<ul>
<li><p>表现层：UserApp 模拟 UserServlet（使用 main 方法模拟）</p>
</li>
<li><p>业务层：UserService</p>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>导入 spring 坐标（5.1.9.release）</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>编写业务层与表现层（模拟）接口与实现类 service.UserService，service.impl.UserServiceImpl</p>
<pre><code class="java">public interface UserService &#123;
    //业务方法  
    void save();
&#125;
</code></pre>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    public void save() &#123;
        System.out.println(&quot;user service running...&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>建立 Spring 配置文件：resources.<strong>applicationContext</strong>.xml (名字一般使用该格式)</p>
</li>
<li><p>配置所需资源（Service）为 Spring 控制的资源</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!-- 1.创建spring控制的资源--&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li><p>表现层（App）通过 Spring 获取资源（Service 实例）</p>
<pre><code class="java">public class UserApp &#123;
    public static void main(String[] args) &#123;
        //2.加载配置文件
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //3.获取资源
        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);
        userService.save();//user service running...
    &#125;
&#125;
</code></pre>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E5%AE%9E%E7%8E%B0.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E5%AE%9E%E7%8E%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
</ol>
<hr>
<h3 id="XML开发"><a href="#XML开发" class="headerlink" title="XML开发"></a>XML开发</h3><h4 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h4><h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><p>标签：<bean> 标签，<beans> 的子标签</beans></bean></p>
<p>作用：定义 Spring 中的资源，受此标签定义的资源将受到 Spring 控制</p>
<p>格式：</p>
<pre><code class="xml">&lt;beans&gt;
    &lt;bean /&gt;
&lt;/beans&gt;
</code></pre>
<p>基本属性</p>
<ul>
<li>id：bean 的名称，通过 id 值获取 bean (首字母小写)</li>
<li>class：bean 的类型，使用完全限定类名</li>
<li>name：bean 的名称，可以通过 name 值获取 bean，用于多人配合时给 bean 起别名</li>
</ul>
<pre><code class="xml">&lt;bean id=&quot;beanId&quot; name=&quot;beanName1,beanName2&quot; class=&quot;ClassName&quot;&gt;&lt;/bean&gt;
</code></pre>
<pre><code class="java">ctx.getBean(&quot;beanId&quot;) == ctx.getBean(&quot;beanName1&quot;) == ctx.getBean(&quot;beanName2&quot;)
</code></pre>
<hr>
<h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><p>作用：定义 bean 的作用范围</p>
<p>格式：</p>
<pre><code class="xml">&lt;bean scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>取值：</p>
<ul>
<li>singleton：设定创建出的对象保存在 Spring 容器中，是一个单例的对象</li>
<li>prototype：设定创建出的对象保存在 Spring 容器中，是一个非单例（原型）的对象</li>
<li>request、session、application、 websocket ：设定创建出的对象放置在 web 容器对应的位置</li>
</ul>
<p>Spring 容器中 Bean 的<strong>线程安全</strong>问题：</p>
<ul>
<li><p>原型 Bean，每次创建一个新对象，线程之间并不存在 Bean 共享，所以不会有线程安全的问题</p>
</li>
<li><p>单例 Bean，所有线程共享一个单例实例 Bean，因此是存在资源的竞争，如果单例 Bean是一个<strong>无状态 Bean</strong>，也就是线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例 Bean 是线程安全的</p>
<p>解决方法：开发人员来进行线程安全的保证，最简单的办法就是把 Bean 的作用域 singleton 改为 protopyte</p>
</li>
</ul>
<hr>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>作用：定义 bean 对象在初始化或销毁时完成的工作</p>
<p>格式：</p>
<pre><code class="xml">&lt;bean init-method=&quot;init&quot; destroy-method=&quot;destroy&gt;&lt;/bean&gt;
</code></pre>
<p>取值：bean 对应的类中对应的具体方法名</p>
<p>实现接口的方式实现初始化，无需配置文件配置 init-method：</p>
<ul>
<li>实现 InitializingBean，定义初始化逻辑</li>
<li>实现 DisposableBean，定义销毁逻辑</li>
</ul>
<p>注意事项：</p>
<ul>
<li>当 scope&#x3D;“singleton” 时，Spring 容器中有且仅有一个对象，init 方法在创建容器时仅执行一次</li>
<li>当 scope&#x3D;“prototype” 时，Spring 容器要创建同一类型的多个对象，init 方法在每个对象创建时均执行一次</li>
<li>当 scope&#x3D;“singleton” 时，关闭容器（<code>.close()</code>）会导致 bean 实例的销毁，调用 destroy 方法一次</li>
<li>当 scope&#x3D;“prototype” 时，对象的销毁由垃圾回收机制 GC 控制，destroy 方法将不会被执行</li>
</ul>
<p>bean 配置：</p>
<pre><code class="xml">&lt;!--init-method和destroy-method用于控制bean的生命周期--&gt;
&lt;bean id=&quot;userService3&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; class=&quot;service.impl.UserServiceImpl&quot;/&gt;
</code></pre>
<p>业务层实现类：</p>
<pre><code class="java">public class UserServiceImpl implements UserService&#123;
    public UserServiceImpl()&#123;
        System.out.println(&quot; constructor is running...&quot;);
    &#125;

    public void init()&#123;
        System.out.println(&quot;init....&quot;);
    &#125;

    public void destroy()&#123;
        System.out.println(&quot;destroy....&quot;);
    &#125;

    public void save() &#123;
        System.out.println(&quot;user service running...&quot;);
    &#125;
&#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">UserService userService = (UserService)ctx.getBean(&quot;userService3&quot;);
</code></pre>
<hr>
<h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><ul>
<li><p>静态工厂</p>
<p>作用：定义 bean 对象创建方式，使用静态工厂的形式创建 bean，兼容早期遗留系统的升级工作</p>
<p>格式：</p>
<pre><code class="xml">&lt;bean class=&quot;FactoryClassName&quot; factory-method=&quot;factoryMethodName&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>取值：工厂 bean 中用于获取对象的静态方法名</p>
<p>注意事项：class 属性必须配置成静态工厂的类名</p>
<p>bean 配置：</p>
<pre><code class="xml">&lt;!--静态工厂创建 bean--&gt;
&lt;bean id=&quot;userService4&quot; class=&quot;service.UserServiceFactory&quot; factory-method=&quot;getService&quot;/&gt;
</code></pre>
<p>工厂类：</p>
<pre><code class="java">public class UserServiceFactory &#123;
    public static UserService getService()&#123;
        System.out.println(&quot;factory create object...&quot;);
        return new UserServiceImpl();
    &#125;
&#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">UserService userService = (UserService)ctx.getBean(&quot;userService4&quot;);
</code></pre>
</li>
<li><p>实例工厂</p>
<p>作用：定义 bean 对象创建方式，使用实例工厂的形式创建 bean，兼容早期遗留系统的升级工作</p>
<p>格式：</p>
<pre><code class="xml">&lt;bean factory-bean=&quot;factoryBeanId&quot; factory-method=&quot;factoryMethodName&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>注意事项：</p>
<ul>
<li><p>使用实例工厂创建 bean 首先需要将实例工厂配置 bean，交由 Spring 进行管理</p>
</li>
<li><p>factory-bean 是实例工厂的 Id</p>
</li>
</ul>
<p>bean 配置：</p>
<pre><code class="xml">&lt;!--实例工厂创建 bean，依赖工厂对象对应的 bean--&gt;
&lt;bean id=&quot;factoryBean&quot; class=&quot;service.UserServiceFactory2&quot;/&gt;
&lt;bean id=&quot;userService5&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;getService&quot;/&gt;
</code></pre>
<p>工厂类：</p>
<pre><code class="java">public class UserServiceFactory2 &#123;
    public UserService getService()&#123;
        System.out.println(&quot; instance factory create object...&quot;);
        return new UserServiceImpl();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="获取Bean"><a href="#获取Bean" class="headerlink" title="获取Bean"></a>获取Bean</h5><p>ApplicationContext 子类相关API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String[] getBeanDefinitionNames()</td>
<td>获取 Spring 容器中定义的所有 JavaBean 的名称</td>
</tr>
<tr>
<td>BeanDefinition getBeanDefinition(String beanName)</td>
<td>返回给定 bean 名称的 BeanDefinition</td>
</tr>
<tr>
<td>String[] getBeanNamesForType(Class&lt;?&gt; type)</td>
<td>获取 Spring 容器中指定类型的所有 JavaBean 的名称</td>
</tr>
<tr>
<td>Environment getEnvironment()</td>
<td>获取与此组件关联的环境</td>
</tr>
</tbody></table>
<hr>
<h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5><ul>
<li><p>IoC（Inversion Of Control）控制翻转，Spring 反向控制应用程序所需要使用的外部资源</p>
</li>
<li><p>DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由 Spring 为其提供，资源进入应用程序的方式称为注入，简单说就是利用反射机制为类的属性赋值的操作</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-DI%E4%BB%8B%E7%BB%8D.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-DI%E4%BB%8B%E7%BB%8D.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
</ul>
<p>IoC 和 DI 的关系：IoC 与 DI 是同一件事站在不同角度看待问题</p>
<hr>
<h5 id="set-注入"><a href="#set-注入" class="headerlink" title="set 注入"></a>set 注入</h5><p>标签：<property> 标签，<bean> 的子标签</bean></property></p>
<p>作用：使用 set 方法的形式为 bean 提供资源</p>
<p>格式：</p>
<pre><code class="xml">&lt;bean&gt;
    &lt;property /&gt;
    &lt;property /&gt;
    .....
&lt;/bean&gt;
</code></pre>
<p>基本属性：</p>
<ul>
<li>name：对应 bean 中的属性名，要注入的变量名，要求该属性必须提供可访问的 set 方法（严格规范此名称是 set 方法对应名称，首字母必须小写）</li>
<li>value：设定非引用类型属性对应的值，<strong>不能与 ref 同时使用</strong></li>
<li>ref：设定引用类型属性对应 bean 的 id ，不能与 value 同时使用</li>
</ul>
<pre><code class="xml">&lt;property name=&quot;propertyName&quot; value=&quot;propertyValue&quot; ref=&quot;beanId&quot;/&gt;
</code></pre>
<p>代码实现：</p>
<ul>
<li><p>DAO 层：要注入的资源</p>
<pre><code class="java">public interface UserDao &#123;
    public void save();
&#125;
</code></pre>
<pre><code class="java">public class UserDaoImpl implements UserDao&#123;
    public void save()&#123;
        System.out.println(&quot;user dao running...&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>Service 业务层</p>
<pre><code class="java">public interface UserService &#123;
    public void save();
&#125;
</code></pre>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao;
    private int num;
    
    //1.对需要进行注入的变量添加set方法
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
    
    public void setNum(int num) &#123;
        this.num = num;
    &#125;
    
    public void save() &#123;
        System.out.println(&quot;user service running...&quot; + num);
        userDao.save();
        bookDao.save();
    &#125;
&#125;
</code></pre>
</li>
<li><p>配置 applicationContext.xml</p>
<pre><code class="xml">&lt;!--2.将要注入的资源声明为bean--&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot;/&gt;

&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
    &lt;!--3.将要注入的引用类型的变量通过property属性进行注入，--&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;property name=&quot;num&quot; value=&quot;666&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">public class UserApp &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);
        userService.save();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h5><p>标签：<constructor-arg> 标签，<bean> 的子标签</bean></constructor-arg></p>
<p>作用：使用构造方法的形式为 bean 提供资源，兼容早期遗留系统的升级工作</p>
<p>格式：</p>
<pre><code class="xml">&lt;bean&gt;
    &lt;constructor-arg /&gt;
    .....&lt;!--一个bean可以有多个constructor-arg标签--&gt;
&lt;/bean&gt;
</code></pre>
<p>属性：</p>
<ul>
<li>name：对应bean中的构造方法所携带的参数名</li>
<li>value：设定非引用类型构造方法参数对应的值，不能与 ref 同时使用</li>
<li>ref：设定引用类型构造方法参数对应 bean 的 id ，不能与 value 同时使用</li>
<li>type：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验</li>
<li>index：设定构造方法参数的位置，用于按位置匹配参数，参数 index 值从 0 开始计数</li>
</ul>
<pre><code class="xml">&lt;constructor-arg name=&quot;argsName&quot; value=&quot;argsValue&quot; /&gt;
&lt;constructor-arg index=&quot;arg-index&quot; type=&quot;arg-type&quot; ref=&quot;beanId&quot;/&gt;
</code></pre>
<p>代码实现：</p>
<ul>
<li><p>DAO 层：要注入的资源</p>
<pre><code class="java">public class UserDaoImpl implements UserDao&#123;
    private String username;
    private String pwd;
    private String driver;

    public UserDaoImpl(String driver,String username, String pwd) &#123;
        this.driver = driver;
        this.username = username;
        this.pwd = pwd;
    &#125;
    public void save()&#123;
        System.out.println(&quot;user dao running...&quot;+username+&quot; &quot;+pwd+&quot; &quot;+driver);
    &#125;
&#125;
</code></pre>
</li>
<li><p>Service 业务层：参考 set 注入</p>
</li>
<li><p>配置 applicationContext.xml</p>
<pre><code class="xml">&lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot;&gt;
    &lt;!--使用构造方法进行注入，需要保障注入的属性与bean中定义的属性一致--&gt;
    &lt;!--一致指顺序一致或类型一致或使用index解决该问题--&gt;
    &lt;constructor-arg index=&quot;2&quot; value=&quot;123&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;root&quot;/&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;property name=&quot;num&quot; value=&quot;666&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>方式二：使用 UserServiceImpl 的构造方法注入</p>
<pre><code class="xml">&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;constructor-arg name=&quot;num&quot; value=&quot;666666&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>测试类：参考 set 注入</p>
</li>
</ul>
<hr>
<h5 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h5><p>标签：<array> <list> <set> <map> <props>，<property> 或 <constructor-arg> 标签的子标签</constructor-arg></property></props></map></set></list></array></p>
<p>作用：注入集合数据类型属性</p>
<p>格式：</p>
<pre><code class="xml">&lt;property&gt;
    &lt;list&gt;&lt;/list&gt;
&lt;/property&gt;
</code></pre>
<p>代码实现：</p>
<ul>
<li><p>DAO 层：要注入的资源</p>
<pre><code class="java">public interface BookDao &#123;
    public void save();
&#125;
</code></pre>
<pre><code class="java">public class BookDaoImpl implements BookDao &#123;
    private ArrayList al;
    private Properties properties;
    private int[] arr;
    private HashSet hs;
    private HashMap hm ;

    public void setAl(ArrayList al) &#123;
        this.al = al;
    &#125;

    public void setProperties(Properties properties) &#123;
        this.properties = properties;
    &#125;

    public void setArr(int[] arr) &#123;
        this.arr = arr;
    &#125;

    public void setHs(HashSet hs) &#123;
        this.hs = hs;
    &#125;

    public void setHm(HashMap hm) &#123;
        this.hm = hm;
    &#125;

    public void save() &#123;
        System.out.println(&quot;book dao running...&quot;);
        System.out.println(&quot;ArrayList:&quot; + al);
        System.out.println(&quot;Properties:&quot; + properties);
        for (int i = 0; i &lt; arr.length; i++) &#123;
            System.out.println(arr[i]);
        &#125;
        System.out.println(&quot;HashSet:&quot; + hs);
        System.out.println(&quot;HashMap:&quot; + hm);
    &#125;
&#125;
</code></pre>
</li>
<li><p>Service 业务层</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private BookDao bookDao;
    
    public UserServiceImpl() &#123;&#125;
    
    public void setBookDao(BookDao bookDao) &#123;
        this.bookDao = bookDao;
    &#125;

    public void save() &#123;
        System.out.println(&quot;user service running...&quot; + num);
        bookDao.save();
    &#125;
&#125;
</code></pre>
</li>
<li><p>配置 applicationContext.xml</p>
<pre><code class="xml">&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;bookDao&quot; class=&quot;dao.impl.BookDaoImpl&quot;&gt;
    &lt;property name=&quot;al&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;seazean&lt;/value&gt;
            &lt;value&gt;66666&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;name&quot;&gt;seazean666&lt;/prop&gt;
            &lt;prop key=&quot;value&quot;&gt;666666&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name=&quot;arr&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;123456&lt;/value&gt;
            &lt;value&gt;66666&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name=&quot;hs&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;seazean&lt;/value&gt;
            &lt;value&gt;66666&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;property name=&quot;hm&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;name&quot; value=&quot;seazean66666&quot;/&gt;
            &lt;entry key=&quot;value&quot; value=&quot;6666666666&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>标签：&lt;p:propertyName&gt;，&lt;p:propertyName-ref&gt;</p>
<p>作用：为 bean 注入属性值</p>
<p>格式：</p>
<pre><code class="xml">&lt;bean p:propertyName=&quot;propertyValue&quot; p:propertyName-ref=&quot;beanId&quot;/&gt;
</code></pre>
<p>开启 p 命令空间：开启 Spring 对 p 命令空间的的支持，在 beans 标签中添加对应空间支持</p>
<pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;           
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans     
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<p>实例：</p>
<pre><code class="xml">&lt;bean 
      id=&quot;userService&quot;
      class=&quot;service.impl.UserServiceImpl&quot;
      p:userDao-ref=&quot;userDao&quot;
      p:bookDao-ref=&quot;bookDao&quot;
      p:num=&quot;10&quot;
    /&gt;
</code></pre>
<hr>
<h4 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h4><p>Spring 提供了对 EL 表达式的支持，统一属性注入格式</p>
<p>作用：为 bean 注入属性值</p>
<p>格式：</p>
<pre><code class="xml">&lt;property value=&quot;EL&quot;&gt;
</code></pre>
<p>注意：所有属性值不区分是否引用类型，统一使用value赋值</p>
<p>所有格式统一使用  value&#x3D;“#{}”</p>
<ul>
<li><p>常量  #{10}  #{3.14}  #{2e5}  #{‘it’}</p>
</li>
<li><p>引用 bean  #{beanId}    </p>
</li>
<li><p>引用 bean 属性  #{beanId.propertyName}</p>
</li>
<li><p>引用 bean 方法  beanId.methodName().method2()</p>
</li>
<li><p>引用静态方法  T(java.lang.Math).PI</p>
</li>
<li><p>运算符支持  #{3 lt 4 &#x3D;&#x3D; 4 ge 3}</p>
</li>
<li><p>正则表达式支持  #{user.name matches‘[a-z]{6,}’}</p>
</li>
<li><p>集合支持  #{likes[3]}</p>
</li>
</ul>
<p>实例：</p>
<pre><code class="xml">&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;userDao&quot; value=&quot;#&#123;userDao&#125;&quot;/&gt;
        &lt;property name=&quot;bookDao&quot; value=&quot;#&#123;bookDao&#125;&quot;/&gt;
        &lt;property name=&quot;num&quot; value=&quot;#&#123;666666666&#125;&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<hr>
<h4 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h4><p>Spring 提供了读取外部 properties 文件的机制，使用读取到的数据为 bean 的属性赋值</p>
<p>操作步骤：</p>
<ol>
<li><p>准备外部 properties 文件</p>
</li>
<li><p>开启 context 命名空间支持</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        &quot;&gt;
</code></pre>
</li>
<li><p>加载指定的 properties 文件</p>
<pre><code class="xml">&lt;context:property-placeholder location=&quot;classpath:data.properties&quot; /&gt;
</code></pre>
</li>
<li><p>使用加载的数据</p>
<pre><code class="xml">&lt;property name=&quot;propertyName&quot; value=&quot;$&#123;propertiesName&#125;&quot;/&gt;
</code></pre>
</li>
</ol>
<ul>
<li><p>注意：如果需要加载所有的 properties 文件，可以使用 <code>*.properties</code> 表示加载所有的 properties 文件</p>
</li>
<li><p>注意：读取数据使用 <strong>${propertiesName}</strong> 格式进行，其中 propertiesName 指 properties 文件中的属性名</p>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>data.properties</p>
<pre><code class="properties">username=root
pwd=123456
</code></pre>
</li>
<li><p>DAO 层：注入的资源</p>
<pre><code class="java">public interface UserDao &#123;
    public void save();
&#125;
</code></pre>
<pre><code class="java">public class UserDaoImpl implements UserDao&#123;
    private String userName;
    private String password;

    public void setUserName(String userName) &#123;
        this.userName = userName;
    &#125;
    public void setPassword(String password) &#123;
        this.password = password;
    &#125;

    public void save()&#123;
        System.out.println(&quot;user dao running...&quot;+userName+&quot; &quot;+password);
    &#125;
&#125;
</code></pre>
</li>
<li><p>Service 业务层</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    private UserDao userDao;
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
    public void save() &#123;
        System.out.println(&quot;user service running...&quot;);
        userDao.save();
    &#125;
&#125;
</code></pre>
</li>
<li><p>applicationContext.xml</p>
<pre><code class="xml">&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt;

&lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;userName&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;$&#123;pwd&#125;&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">public class UserApp &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);
        userService.save();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>标签：<import>，<beans>标签的子标签</beans></import></p>
<p>作用：在当前配置文件中导入其他配置文件中的项</p>
<p>格式：</p>
<pre><code class="xml">&lt;beans&gt;
    &lt;import /&gt;
&lt;/beans&gt;
</code></pre>
<p>属性：</p>
<ul>
<li>resource：加载的配置文件名</li>
</ul>
<pre><code class="xml">&lt;import resource=“config2.xml&quot;/&gt;
</code></pre>
<p>Spring 容器加载多个配置文件：</p>
<ul>
<li><p>applicationContext-book.xml</p>
<pre><code class="xml">&lt;bean id=&quot;bookDao&quot; class=&quot;dao.impl.BookDaoImpl&quot;&gt;
    &lt;property name=&quot;num&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>applicationContext-user.xml</p>
<pre><code class="xml">&lt;bean id=&quot;userDao&quot; class=&quot;dao.impl.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;userName&quot; value=&quot;$&#123;username&#125;&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;$&#123;pwd&#125;&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>applicationContext.xml</p>
<pre><code class="xml">&lt;import resource=&quot;applicationContext-user.xml&quot;/&gt;
&lt;import resource=&quot;applicationContext-book.xml&quot;/&gt;

&lt;bean id=&quot;bookDao&quot; class=&quot;com.seazean.dao.impl.BookDaoImpl&quot;&gt;
    &lt;property name=&quot;num&quot; value=&quot;2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">new ClassPathXmlApplicationContext(&quot;applicationContext-user.xml&quot;,&quot;applicationContext-book.xml&quot;);
new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre>
</li>
</ul>
<p>Spring 容器中的 bean 定义冲突问题</p>
<ul>
<li><p>同 id 的 bean，后定义的覆盖先定义的</p>
</li>
<li><p>导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置，程序执行选择最下面的配置使用</p>
</li>
<li><p>导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同</p>
</li>
</ul>
<hr>
<h4 id="三方资源"><a href="#三方资源" class="headerlink" title="三方资源"></a>三方资源</h4><h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><p>第三方资源配置</p>
<ul>
<li><p>pom.xml</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.16&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>applicationContext.xml</p>
<pre><code class="xml">&lt;!--加载druid资源--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.2.185:3306/spring_db&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>App.java</p>
<pre><code class="java">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
DruidDataSource datasource = (DruidDataSource) ctx.getBean(&quot;datasource&quot;);
System.out.println(datasource);
</code></pre>
</li>
</ul>
<hr>
<h5 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h5><p>Mybatis 核心配置文件消失</p>
<ul>
<li><p>环境 environment 转换成数据源对象</p>
</li>
<li><p>映射 Mapper 扫描工作交由 Spring 处理</p>
</li>
<li><p>类型别名交由 Spring 处理</p>
</li>
</ul>
<p>DAO 接口不需要创建实现类，MyBatis-Spring 提供了一个动态代理的实现 <strong>MapperFactoryBean</strong>，这个类可以让直接注入数据映射器接口到 service 层 bean 中，底层将会动态代理创建类</p>
<p>整合原理：利用 Spring 框架的 SPI 机制，在 META-INF 目录的 spring.handlers 中给 Spring 容器中导入 NamespaceHandler 类</p>
<ul>
<li><p>NamespaceHandler 的 init 方法注册 bean 信息的解析器 MapperScannerBeanDefinitionParser</p>
</li>
<li><p>解析器在 Spring 容器创建过程中去<strong>解析 mapperScanner 标签</strong>，解析出的属性填充到 MapperScannerConfigurer 中</p>
</li>
<li><p>MapperScannerConfigurer 实现了 BeanDefinitionRegistryPostProcessor 接口，重写 postProcessBeanDefinitionRegistry() 方法，可以扫描到 MyBatis 的 Mapper</p>
</li>
</ul>
<hr>
<h3 id="注解开发-1"><a href="#注解开发-1" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h4><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>启动注解扫描，加载类中配置的注解项：</p>
<pre><code class="xml">&lt;context:component-scan base-package=&quot;packageName1,packageName2&quot;/&gt;
</code></pre>
<p>说明：</p>
<ul>
<li>在进行包扫描时，会对配置的包及其子包中所有文件进行扫描，多个包采用<code>,</code>隔开</li>
<li>扫描过程是以文件夹递归迭代的形式进行的</li>
<li>扫描过程仅读取合法的 Java 文件</li>
<li>扫描时仅读取 Spring 可识别的注解</li>
<li>扫描结束后会将可识别的有效注解转化为 Spring 对应的资源加入 IoC 容器</li>
<li>从加载效率上来说注解优于 XML 配置文件</li>
</ul>
<p>注解：启动时使用注解的形式替代 xml 配置，将 Spring 配置文件从工程中消除，简化书写</p>
<p>缺点：为了达成注解驱动的目的，可能会将原先很简单的书写，变的更加复杂。XML 中配置第三方开发的资源是很方便的，但使用注解驱动无法在第三方开发的资源中进行编辑，因此会增大开发工作量</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%A4%BA%E4%BE%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%A4%BA%E4%BE%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<hr>
<h5 id="纯注解"><a href="#纯注解" class="headerlink" title="纯注解"></a>纯注解</h5><p>注解配置类</p>
<p>名称：@Configuration、@ComponentScan</p>
<p>类型：类注解</p>
<p>作用：<strong>设置当前类为 Spring 核心配置加载类</strong></p>
<p>格式：</p>
<pre><code class="java">@Configuration
@ComponentScan(&#123;&quot;scanPackageName1&quot;,&quot;scanPackageName2&quot;&#125;)
public class SpringConfigClassName&#123;
&#125;
</code></pre>
<p>说明：</p>
<ul>
<li>核心配合类用于替换 Spring 核心配置文件，此类可以设置空的，不设置变量与属性</li>
<li>bean 扫描工作使用注解 @ComponentScan 替代，多个包用 <code>&#123;&#125; 和 ,</code> 隔开</li>
</ul>
<p>加载纯注解格式上下文对象，需要使用 <strong>AnnotationConfigApplicationContext</strong></p>
<pre><code class="java">@Configuration
public class SpringConfig &#123;
    @Bean
    public Person person() &#123;
        return new Person1(&quot;lisi&quot;, 20);
    &#125;
&#125;

public class MainTest &#123;
    public static void main(String[] args) &#123;
        ApplicationContext applicationContext = new 
                    AnnotationConfigApplicationContext(SpringConfig.class);
        //方式一：名称对应类名
        Person bean = applicationContext.getBean(Person.class);
        System.out.println(bean);
        
        //方式二：名称对应方法名 
        Person bean1 = (Person) applicationContext.getBean(&quot;person1&quot;);    
        
        //方法三：指定名称@Bean(&quot;person2&quot;)
    &#125;
&#125;
</code></pre>
<hr>
<h5 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h5><p>组件扫描过滤器</p>
<p>开发过程中，需要根据需求加载必要的 bean，排除指定 bean</p>
<p>名称：@ComponentScan</p>
<p>类型：<strong>类注解</strong></p>
<p>作用：设置 Spring 配置加载类扫描规则</p>
<p>格式：</p>
<pre><code class="java">@ComponentScan(
    value = &#123;&quot;dao&quot;,&quot;service&quot;&#125;,            //设置基础扫描路径
    excludeFilters =                    //设置过滤规则，当前为排除过滤
    @ComponentScan.Filter(                //设置过滤器
        type= FilterType.ANNOTATION,      //设置过滤方式为按照注解进行过滤
        classes = Service.class)         //设置具体的过滤项，过滤所有@Service修饰的bean
    )
)
</code></pre>
<p>属性：</p>
<ul>
<li>includeFilters：设置包含性过滤器 </li>
<li>excludeFilters：设置排除性过滤器</li>
<li>type：设置过滤器类型</li>
</ul>
<hr>
<h4 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h4><h5 id="设置-bean"><a href="#设置-bean" class="headerlink" title="设置 bean"></a>设置 bean</h5><p>名称：@Component、@Controller、@Service、@Repository</p>
<p>类型：类注解，写在类定义上方</p>
<p>作用：设置该类为 Spring 管理的 bean</p>
<p>格式：</p>
<pre><code class="java">@Component
public class ClassName&#123;&#125;
</code></pre>
<p>说明：@Controller、@Service 、@Repository 是 @Component 的衍生注解，功能同 @Component</p>
<p>属性：</p>
<ul>
<li>value（默认）：定义 bean 的访问 id</li>
</ul>
<hr>
<h5 id="作用范围-1"><a href="#作用范围-1" class="headerlink" title="作用范围"></a>作用范围</h5><p>名称：@Scope</p>
<p>类型：类注解，写在类定义上方</p>
<p>作用：设置该类作为 bean 对应的 scope 属性</p>
<p>格式：</p>
<pre><code class="java">@Scope
public class ClassName&#123;&#125;
</code></pre>
<p>相关属性</p>
<ul>
<li>value（默认）：定义 bean 的作用域，默认为 singleton，非单例取值 prototype</li>
</ul>
<hr>
<h5 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h5><p>名称：@PostConstruct、@PreDestroy</p>
<p>类型：方法注解，写在方法定义上方</p>
<p>作用：设置该类作为 bean 对应的生命周期方法</p>
<p>示例：</p>
<pre><code class="java">//定义bean，后面添加bean的id
@Component(&quot;userService&quot;)
//定义bean的作用域
@Scope(&quot;singleton&quot;)
public class UserServiceImpl implements UserService &#123;
    //初始化
    @PostConstruct
    public void init()&#123;
        System.out.println(&quot;user service init...&quot;);
    &#125;
    //销毁
    @PreDestroy
    public void destroy()&#123;
        System.out.println(&quot;user service destroy...&quot;);
    &#125;
&#125;
</code></pre>
<p>一个对象的执行顺序：Constructor &gt;&gt; @Autowired（注入属性） &gt;&gt; @PostConstruct（初始化逻辑）</p>
<hr>
<h5 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h5><p>名称：@Bean</p>
<p>类型：方法注解</p>
<p>作用：设置该方法的返回值作为 Spring 管理的 bean</p>
<p>格式：</p>
<pre><code class="java">@Bean(&quot;dataSource&quot;)
public DruidDataSource createDataSource() &#123;    return ……;    &#125;
</code></pre>
<p>说明：</p>
<ul>
<li><p>因为第三方 bean 无法在其源码上进行修改，使用 @Bean 解决第三方 bean 的引入问题</p>
</li>
<li><p>该注解用于替代 XML 配置中的静态工厂与实例工厂创建 bean，不区分方法是否为静态或非静态</p>
</li>
<li><p>@Bean 所在的类必须被 Spring 扫描加载，否则该注解无法生效</p>
</li>
</ul>
<p>相关属性</p>
<ul>
<li>value（默认）：定义 bean 的访问 id</li>
<li>initMethod：声明初始化方法</li>
<li>destroyMethod：声明销毁方法</li>
</ul>
<hr>
<h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>名称：@Value</p>
<p>类型：属性注解、方法注解</p>
<p>作用：设置对应属性的值或对方法进行传参</p>
<p>格式：</p>
<pre><code class="java">//@Value(&quot;$&#123;jdbc.username&#125;&quot;)
@Value(&quot;root&quot;)
private String username;
</code></pre>
<p>说明：</p>
<ul>
<li><p>value 值<strong>仅支持非引用类型数据</strong>，赋值时对方法的所有参数全部赋值</p>
</li>
<li><p>value 值支持读取 properties 文件中的属性值，通过类属性将 properties 中数据传入类中</p>
</li>
<li><p>value 值支持 SpEL</p>
</li>
<li><p>@value 注解如果添加在属性上方，可以省略 set 方法（set 方法的目的是为属性赋值）</p>
</li>
</ul>
<p>相关属性：</p>
<ul>
<li>value（默认）：定义对应的属性值或参数值</li>
</ul>
<hr>
<h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><h6 id="属性注入-1"><a href="#属性注入-1" class="headerlink" title="属性注入"></a>属性注入</h6><p>名称：@Autowired、@Qualifier</p>
<p>类型：属性注解、方法注解</p>
<p>作用：设置对应属性的对象、对方法进行引用类型传参</p>
<p>格式：</p>
<pre><code class="java">@Autowired(required = false)
@Qualifier(&quot;userDao&quot;)
private UserDao userDao;
</code></pre>
<p>说明：</p>
<ul>
<li>@Autowired 默认按类型装配，指定 @Qualifier 后可以指定自动装配的 bean 的 id</li>
</ul>
<p>相关属性：</p>
<ul>
<li>required：<strong>为 true （默认）表示注入 bean 时该 bean 必须存在</strong>，不然就会注入失败抛出异常；为 false  表示注入时该 bean 存在就注入，不存在就忽略跳过</li>
</ul>
<p>注意：在使用 @Autowired 时，首先在容器中查询对应类型的 bean，如果查询结果刚好为一个，就将该 bean 装配给 @Autowired 指定的数据，如果查询的结果不止一个，那么 @Autowired 会根据名称来查找，如果查询的结果为空，那么会抛出异常</p>
<p>解决方法：使用 required &#x3D; false</p>
<hr>
<h6 id="优先注入"><a href="#优先注入" class="headerlink" title="优先注入"></a>优先注入</h6><p>名称：@Primary</p>
<p>类型：类注解</p>
<p>作用：设置类对应的 bean 按类型装配时优先装配</p>
<p>范例：</p>
<pre><code class="java">@Primary
public class ClassName&#123;&#125;
</code></pre>
<p>说明：</p>
<ul>
<li>@Autowired 默认按类型装配，当出现相同类型的 bean，使用 @Primary 提高按类型自动装配的优先级，多个 @Primary 会导致优先级设置无效</li>
</ul>
<hr>
<h6 id="注解对比"><a href="#注解对比" class="headerlink" title="注解对比"></a>注解对比</h6><p>名称：@Inject、@Named、@Resource</p>
<ul>
<li>@Inject 与 @Named 是 JSR330 规范中的注解，功能与 @Autowired 和 @Qualifier 完全相同，适用于不同架构场景</li>
<li>@Resource 是 JSR250 规范中的注解，可以简化书写格式</li>
</ul>
<p>@Resource 相关属性</p>
<ul>
<li><p>name：设置注入的 bean 的 id</p>
</li>
<li><p>type：设置注入的 bean 的类型，接收的参数为 Class 类型</p>
</li>
</ul>
<p>@Autowired 和 @Resource之间的区别：</p>
<ul>
<li><p>@Autowired 默认是<strong>按照类型装配</strong>注入，默认情况下它要求依赖对象必须存在（可以设置 required 属性为 false）</p>
</li>
<li><p>@Resource 默认<strong>按照名称装配</strong>注入，只有当找不到与名称匹配的 bean 才会按照类型来装配注入</p>
</li>
</ul>
<hr>
<h5 id="静态注入"><a href="#静态注入" class="headerlink" title="静态注入"></a>静态注入</h5><p>Spring 容器管理的都是实例对象，**@Autowired 依赖注入的都是容器内的对象实例**，在 Java 中 static 修饰的静态属性（变量和方法）是属于类的，而非属于实例对象</p>
<p>当类加载器加载静态变量时，Spring 上下文尚未加载，所以类加载器不会在 Bean 中正确注入静态类</p>
<pre><code class="java">@Component
public class TestClass &#123;
    @Autowired
    private static Component component;

    // 调用静态组件的方法
    public static void testMethod() &#123;
        component.callTestMethod()；
    &#125;  
&#125;
// 编译正常，但运行时报java.lang.NullPointerException，所以在调用testMethod()方法时，component变量还没被初始化
</code></pre>
<p>解决方法：</p>
<ul>
<li><p>@Autowired 注解到<strong>类的构造函数</strong>上，Spring 扫描到 Component 的 Bean，然后赋给静态变量 component</p>
<pre><code class="java">@Component
public class TestClass &#123;
    private static Component component;

    @Autowired
    public TestClass(Component component) &#123;
        TestClass.component = component;
    &#125;

    public static void testMethod() &#123;
        component.callTestMethod()；
    &#125;
&#125;
</code></pre>
</li>
<li><p>@Autowired 注解到<strong>静态属性的 setter 方法</strong>上</p>
</li>
<li><p>使用 @PostConstruct 注解一个方法，在方法内为 static 静态成员赋值</p>
</li>
<li><p>使用 Spring 框架工具类获取 bean，定义成局部变量使用</p>
<pre><code class="java">public class TestClass &#123;
    // 调用静态组件的方法
   public static void testMethod() &#123;
      Component component = SpringApplicationContextUtil.getBean(&quot;component&quot;);
      component.callTestMethod();
   &#125;
&#125;
</code></pre>
</li>
</ul>
<p>参考文章：<a target="_blank" rel="noopener" href="http://jessehzx.top/2018/03/18/spring-autowired-static-field/">http://jessehzx.top/2018/03/18/spring-autowired-static-field/</a></p>
<hr>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>名称：@PropertySource</p>
<p>类型：类注解</p>
<p>作用：加载 properties 文件中的属性值</p>
<p>格式：</p>
<pre><code class="java">@PropertySource(value = &quot;classpath:filename.properties&quot;)
public class ClassName &#123;
    @Value(&quot;$&#123;propertiesAttributeName&#125;&quot;)
    private String attributeName;
&#125;
</code></pre>
<p>说明：</p>
<ul>
<li>不支持 * 通配符，加载后，所有 Spring 控制的 bean 中均可使用对应属性值，加载多个需要用 <code>&#123;&#125; 和 ,</code> 隔开</li>
</ul>
<p>相关属性</p>
<ul>
<li><p>value（默认）：设置加载的 properties 文件名</p>
</li>
<li><p>ignoreResourceNotFound：如果资源未找到，是否忽略，默认为 false</p>
</li>
</ul>
<hr>
<h4 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h4><h5 id="依赖加载"><a href="#依赖加载" class="headerlink" title="依赖加载"></a>依赖加载</h5><p>@DependsOn</p>
<ul>
<li><p>名称：@DependsOn</p>
</li>
<li><p>类型：类注解、方法注解</p>
</li>
<li><p>作用：控制 bean 的加载顺序，使其在指定 bean 加载完毕后再加载</p>
</li>
<li><p>格式：</p>
<pre><code class="java">@DependsOn(&quot;beanId&quot;)
public class ClassName &#123;
&#125;
</code></pre>
</li>
<li><p>说明：</p>
<ul>
<li><p>配置在方法上，使 @DependsOn 指定的 bean 优先于 @Bean 配置的 bean 进行加载</p>
</li>
<li><p>配置在类上，使 @DependsOn 指定的 bean 优先于当前类中所有 @Bean 配置的 bean 进行加载</p>
</li>
<li><p>配置在类上，使 @DependsOn 指定的 bean 优先于 @Component 等配置的 bean 进行加载</p>
</li>
</ul>
</li>
<li><p>相关属性</p>
<ul>
<li>value（默认）：设置当前 bean 所依赖的 bean 的 id</li>
</ul>
</li>
</ul>
<p>@Order</p>
<ul>
<li><p>名称：@Order</p>
</li>
<li><p>类型：<strong>配置类注解</strong></p>
</li>
<li><p>作用：控制配置类的加载顺序，值越小越先加载</p>
</li>
<li><p>格式：</p>
<pre><code class="java">@Order(1)
public class SpringConfigClassName &#123;
&#125;
</code></pre>
</li>
</ul>
<p>@Lazy</p>
<ul>
<li><p>名称：@Lazy</p>
</li>
<li><p>类型：类注解、方法注解</p>
</li>
<li><p>作用：控制 bean 的加载时机，使其延迟加载，获取的时候加载</p>
</li>
<li><p>格式：</p>
<pre><code class="java">@Lazy
public class ClassName &#123;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>@DependsOn</p>
<ul>
<li><p>微信订阅号，发布消息和订阅消息的 bean 的加载顺序控制（先开订阅，再发布）</p>
</li>
<li><p>双 11 活动，零点前是结算策略 A，零点后是结算策略 B，策略 B 操作的数据为促销数据，策略 B 加载顺序与促销数据的加载顺序</p>
</li>
</ul>
<p>@Lazy</p>
<ul>
<li>程序灾难出现后对应的应急预案处理是启动容器时加载时机</li>
</ul>
<p>@Order</p>
<ul>
<li>多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制</li>
</ul>
<hr>
<h4 id="整合资源"><a href="#整合资源" class="headerlink" title="整合资源"></a>整合资源</h4><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>名称：@Import</p>
<p>类型：类注解</p>
<p>作用：导入第三方 bean 作为 Spring 控制的资源，这些类都会被 Spring 创建并放入 ioc 容器</p>
<p>格式：</p>
<pre><code class="java">@Configuration
@Import(OtherClassName.class)
public class ClassName &#123;
&#125;
</code></pre>
<p>说明：</p>
<ul>
<li>@Import 注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定</li>
<li>在被导入的类中可以继续使用 @Import 导入其他资源</li>
<li>@Bean 所在的类可以使用导入的形式进入 Spring 容器，无需声明为 bean</li>
</ul>
<hr>
<h5 id="Druid-1"><a href="#Druid-1" class="headerlink" title="Druid"></a>Druid</h5><ul>
<li><p>加载资源</p>
<pre><code class="java">@Component
public class JDBCConfig &#123;
    @Bean(&quot;dataSource&quot;)
    public static DruidDataSource getDataSource() &#123;
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
        ds.setUrl(&quot;jdbc:mysql://192.168.2.185:3306/spring_db&quot;);
        ds.setUsername(&quot;root&quot;);
        ds.setPassword(&quot;123456&quot;);
        return ds;
    &#125;
&#125;
</code></pre>
</li>
<li><p>导入资源</p>
<pre><code class="java">@Configuration
@ComponentScan(value = &#123;&quot;service&quot;,&quot;dao&quot;&#125;)
@Import(JDBCConfig.class)
public class SpringConfig &#123;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">DruidDataSource dataSource = (DruidDataSource) ctx.getBean(&quot;dataSource&quot;);
System.out.println(dataSource);
</code></pre>
</li>
</ul>
<hr>
<h5 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h5><p>Spring 接管 Junit 的运行权，使用 Spring 专用的 Junit 类加载器，为 Junit 测试用例设定对应的 Spring 容器</p>
<p>注意：</p>
<ul>
<li><p>从 Spring5.0 以后，要求 Junit 的版本必须是4.12及以上</p>
</li>
<li><p>Junit 仅用于单元测试，不能将 Junit 的测试类配置成 Spring 的 bean，否则该配置将会被打包进入工程中</p>
</li>
</ul>
<p>test &#x2F; java &#x2F; service &#x2F; UserServiceTest</p>
<pre><code class="java">//设定spring专用的类加载器
@RunWith(SpringJUnit4ClassRunner.class)
//设定加载的spring上下文对应的配置
@ContextConfiguration(classes = SpringConfig.class)
public class UserServiceTest &#123;
    @Autowired
    private AccountService accountService;
    @Test
    public void testFindById() &#123;
        Account account = accountService.findById(1);
        Assert.assertEquals(&quot;Mike&quot;, account.getName());
    &#125;
&#125;
</code></pre>
<p>pom.xml</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<hr>
<h3 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h3><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>ApplicationContext：</p>
<ol>
<li><p>ApplicationContext 是一个接口，提供了访问 Spring 容器的 API</p>
</li>
<li><p>ClassPathXmlApplicationContext 是一个类，实现了上述功能</p>
</li>
<li><p>ApplicationContext 的顶层接口是 BeanFactory</p>
</li>
<li><p>BeanFactory 定义了 bean 相关的最基本操作</p>
</li>
<li><p>ApplicationContext 在 BeanFactory 基础上追加了若干新功能</p>
</li>
</ol>
<p><strong>ApplicationContext 和 BeanFactory对比：</strong></p>
<ul>
<li><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器</p>
</li>
<li><p>BeanFactory 是 Spring 里面最底层的接口，是 IoC 的核心，定义了 IoC 的基本功能，包含了各种 Bean 的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext 接口作为 BeanFactory 的子类，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>继承 MessageSource，因此支持国际化</li>
<li>资源文件访问，如 URL 和文件（ResourceLoader）。</li>
<li>载入多个（有继承关系）上下文（即加载多个配置文件） ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层</li>
<li>提供在监听器中注册 bean 的事件</li>
</ul>
</li>
<li><p>BeanFactory 创建的 bean 采用延迟加载形式，只有在使用到某个 Bean 时（调用 getBean），才对该 Bean 进行加载实例化（Spring 早期使用该方法获取 bean），这样就不能提前发现一些存在的 Spring 的配置问题；ApplicationContext 是在容器启动时，一次性创建了所有的 Bean，容器启动时，就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入</p>
</li>
<li><p>ApplicationContext 启动后预载入所有的单实例 Bean，所以程序启动慢，运行时速度快</p>
</li>
<li><p>两者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册</p>
</li>
</ul>
<p>FileSystemXmlApplicationContext：加载文件系统中任意位置的配置文件，而 ClassPathXmlAC 只能加载类路径下的配置文件</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-ApplicationContext%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-ApplicationContext%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>BeanFactory 的成员属性：</p>
<pre><code class="java">String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;
</code></pre>
<ul>
<li>区分是 FactoryBean 还是创建的 Bean，加上 &amp; 代表是工厂，getBean 将会返回工厂</li>
<li>FactoryBean：如果某个 bean 的配置非常复杂，或者想要使用编码的形式去构建它，可以提供一个构建该 bean 实例的工厂，这个工厂就是 FactoryBean 接口实现类，FactoryBean 接口实现类也是需要 Spring 管理<ul>
<li>这里产生两种对象，一种是 FactoryBean 接口实现类（IOC 管理），另一种是 FactoryBean 接口内部管理的对象</li>
<li>获取 FactoryBean 接口实现类，使用 getBean 时传的 beanName 需要带 &amp; 开头</li>
<li>获取 FactoryBean 内部管理的对象，不需要带 &amp; 开头</li>
</ul>
</li>
</ul>
<p>BeanFactory 的基本使用：</p>
<pre><code class="java">Resource res = new ClassPathResource(&quot;applicationContext.xml&quot;);
BeanFactory bf = new XmlBeanFactory(res);
UserService userService = (UserService)bf.getBean(&quot;userService&quot;);
</code></pre>
<hr>
<h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h5><p>FactoryBean：对单一的 bean 的初始化过程进行封装，达到简化配置的目的</p>
<p>FactoryBean与 BeanFactory 区别：</p>
<ul>
<li><p>FactoryBean：封装单个 bean 的创建过程，就是工厂的 Bean</p>
</li>
<li><p>BeanFactory：Spring 容器顶层接口，定义了 bean 相关的获取操作</p>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>FactoryBean，实现类一般是 MapperFactoryBean，创建 DAO 层接口的实现类</p>
<pre><code class="java">public class EquipmentDaoImplFactoryBean implements FactoryBean &#123;
    @Override    //获取Bean
    public Object getObject() throws Exception &#123;
        return new EquipmentDaoImpl();
    &#125;
    
    @Override    //获取bean的类型
    public Class&lt;?&gt; getObjectType() &#123;
        return null;
    &#125;
    
    @Override    //是否单例
    public boolean isSingleton() &#123;
        return false;
    &#125;
&#125;
</code></pre>
</li>
<li><p>MapperFactoryBean 继承 SqlSessionDaoSupport，可以获取 SqlSessionTemplate，完成 MyBatis 的整合</p>
<pre><code class="java">public abstract class SqlSessionDaoSupport extends DaoSupport &#123;
      private SqlSessionTemplate sqlSessionTemplate;
    // 获取 SqlSessionTemplate 对象
    public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123;
        if (this.sqlSessionTemplate == null || 
            sqlSessionFactory != this.sqlSessionTemplate.getSqlSessionFactory()) &#123;
              this.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);
        &#125;
      &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h5 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h5><ul>
<li><p>DAO 层 UserDao、AccountDao、BookDao、EquipmentDao</p>
<pre><code class="java">public interface UserDao &#123;
    public void save();
&#125;
</code></pre>
<pre><code class="java">@Component(&quot;userDao&quot;)
public class UserDaoImpl implements UserDao &#123;
    public void save() &#123;
        System.out.println(&quot;user dao running...&quot;);
    &#125;

&#125;
</code></pre>
</li>
<li><p>Service 业务层</p>
<pre><code class="java">public interface UserService &#123;
    public void save();
&#125;
</code></pre>
<pre><code class="java">@Service(&quot;userService&quot;)
public class UserServiceImpl implements UserService &#123;
    @Autowired
    private UserDao userDao;//...........BookDao等

    public void save() &#123;
        System.out.println(&quot;user service running...&quot;);
        userDao.save();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h5><p>名称：TypeFilter</p>
<p>类型：<strong>接口</strong></p>
<p>作用：自定义类型过滤器</p>
<p>示例：</p>
<ul>
<li><p>config &#x2F; filter &#x2F; MyTypeFilter</p>
<pre><code class="java">public class MyTypeFilter implements TypeFilter &#123;
    @Override
    /**
    * metadataReader:读取到的当前正在扫描的类的信息
    * metadataReaderFactory:可以获取到任何其他类的信息
    */
    //加载的类满足要求，匹配成功
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;
        //获取当前类注解的信息
        AnnotationMetadata am = metadataReader.getAnnotationMetadata();
        //获取当前正在扫描的类的类信息
        ClassMetadata classMetadata = metadataReader.getClassMetadata();
        //获取当前类资源（类的路径）
        Resource resource = metadataReader.getResource();
        
        
        //通过类的元数据获取类的名称
        String className = classMetadata.getClassName();
        //如果加载的类名满足过滤器要求，返回匹配成功
        if(className.equals(&quot;service.impl.UserServiceImpl&quot;))&#123;
           //返回true表示匹配成功，返回false表示匹配失败。此处仅确认匹配结果，不会确认是排除还是加入，排除/加入由配置项决定，与此处无关
            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
</li>
<li><p>SpringConfig</p>
<pre><code class="java">@Configuration
//设置排除bean，排除的规则是自定义规则（FilterType.CUSTOM），具体的规则定义为MyTypeFilter
@ComponentScan(
        value = &#123;&quot;dao&quot;,&quot;service&quot;&#125;,
        excludeFilters = @ComponentScan.Filter(
                type= FilterType.CUSTOM,
                classes = MyTypeFilter.class
        )
)
public class SpringConfig &#123;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="导入器"><a href="#导入器" class="headerlink" title="导入器"></a>导入器</h4><p>bean 只有通过配置才可以进入 Spring 容器，被 Spring 加载并控制</p>
<ul>
<li><p>配置 bean 的方式如下：</p>
<ul>
<li>XML 文件中使用 <bean> 标签配置</bean></li>
<li>使用 @Component 及衍生注解配置</li>
</ul>
</li>
</ul>
<p>导入器可以快速高效导入大量 bean，替代 @Import({a.class,b.class})，无需在每个类上添加 @Bean</p>
<p>名称： ImportSelector</p>
<p>类型：<strong>接口</strong></p>
<p>作用：自定义bean导入器</p>
<ul>
<li><p>selector &#x2F; MyImportSelector</p>
<pre><code class="java">public class MyImportSelector implements ImportSelector&#123;
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;
//      1.编程形式加载一个类
//      return new String[]&#123;&quot;dao.impl.BookDaoImpl&quot;&#125;;

//      2.加载import.properties文件中的单个类名
//      ResourceBundle bundle = ResourceBundle.getBundle(&quot;import&quot;);
//      String className = bundle.getString(&quot;className&quot;);

//      3.加载import.properties文件中的多个类名
        ResourceBundle bundle = ResourceBundle.getBundle(&quot;import&quot;);
        String className = bundle.getString(&quot;className&quot;);
        return className.split(&quot;,&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>import.properties</p>
<pre><code class="properties">#2.加载import.properties文件中的单个类名
#className=dao.impl.BookDaoImpl

#3.加载import.properties文件中的多个类名
#className=dao.impl.BookDaoImpl,dao.impl.AccountDaoImpl

#4.导入包中的所有类
path=dao.impl.*
</code></pre>
</li>
<li><p>SpringConfig</p>
<pre><code class="java">@Configuration
@ComponentScan(&#123;&quot;dao&quot;,&quot;service&quot;&#125;)
@Import(MyImportSelector.class)
public class SpringConfig &#123;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="注册器"><a href="#注册器" class="headerlink" title="注册器"></a>注册器</h4><p>可以取代 ComponentScan 扫描器</p>
<p>名称：ImportBeanDefinitionRegistrar</p>
<p>类型：<strong>接口</strong></p>
<p>作用：自定义 bean 定义注册器</p>
<ul>
<li><p>registrar &#x2F; MyImportBeanDefinitionRegistrar</p>
<pre><code class="java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;
/**
 * AnnotationMetadata:当前类的注解信息
 * BeanDefinitionRegistry:BeanDefinition注册类，把所有需要添加到容器中的bean调用registerBeanDefinition手工注册进来
 */
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;
        //自定义注册器
        //1.开启类路径bean定义扫描器，需要参数bean定义注册器BeanDefinitionRegistry，需要制定是否使用默认类型过滤器
        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry,false);
        //2.添加包含性加载类型过滤器（可选，也可以设置为排除性加载类型过滤器）
        scanner.addIncludeFilter(new TypeFilter() &#123;
            @Override
            public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;
                //所有匹配全部成功，此处应该添加实际的业务判定条件
                return true;
            &#125;
        &#125;);
        //设置扫描路径
        scanner.addExcludeFilter(tf);//排除
        scanner.scan(&quot;dao&quot;,&quot;service&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>SpringConfig</p>
<pre><code class="java">@Configuration
@Import(MyImportBeanDefinitionRegistrar.class)
public class SpringConfig &#123;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>通过创建类<strong>继承相应的处理器的接口</strong>，重写后置处理的方法，来实现<strong>拦截 Bean 的生命周期</strong>来实现自己自定义的逻辑</p>
<p>BeanPostProcessor：bean 后置处理器，bean 创建对象初始化前后进行拦截工作的</p>
<p>BeanFactoryPostProcessor：beanFactory 的后置处理器</p>
<ul>
<li><pre><code>    加载时机：在 BeanFactory 初始化之后调用，来定制和修改 BeanFactory 的内容；所有的 bean 定义已经保存加载到 beanFactory，但是 bean 的实例还未创建
</code></pre>
</li>
<li><pre><code>    执行流程：
</code></pre>
<ul>
<li>ioc 容器创建对象</li>
<li>invokeBeanFactoryPostProcessors(beanFactory)：执行 BeanFactoryPostProcessor<ul>
<li>在 BeanFactory 中找到所有类型是 BeanFactoryPostProcessor 的组件，并执行它们的方法</li>
<li>在初始化创建其他组件前面执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>BeanDefinitionRegistryPostProcessor：</p>
<ul>
<li><p>加载时机：在所有 bean 定义信息将要被加载，但是 bean 实例还未创建，优先于 BeanFactoryPostProcessor 执行；利用 BeanDefinitionRegistryPostProcessor 给容器中再额外添加一些组件</p>
</li>
<li><p>执行流程：</p>
<ul>
<li>ioc 容器创建对象</li>
<li>refresh() → invokeBeanFactoryPostProcessors(beanFactory)</li>
<li>从容器中获取到所有的 BeanDefinitionRegistryPostProcessor 组件<ul>
<li>依次触发所有的 postProcessBeanDefinitionRegistry() 方法</li>
<li>再来触发 postProcessBeanFactory() 方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><h5 id="基本概述-1"><a href="#基本概述-1" class="headerlink" title="基本概述"></a>基本概述</h5><p>ApplicationListener：监听容器中发布的事件，完成事件驱动模型开发</p>
<pre><code class="java">public interface ApplicationListener&lt;E extends ApplicationEvent&gt;
</code></pre>
<p>所以监听 ApplicationEvent 及其下面的子事件</p>
<p>应用监听器步骤：</p>
<ul>
<li><pre><code>  写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）
</code></pre>
</li>
<li><pre><code>  把监听器加入到容器 @Component
</code></pre>
</li>
<li><pre><code>  只要容器中有相关事件的发布，就能监听到这个事件；
*       ContextRefreshedEvent：容器刷新完成（所有 bean 都完全创建）会发布这个事件
*       ContextClosedEvent：关闭容器会发布这个事件
</code></pre>
</li>
<li><pre><code>  发布一个事件：`applicationContext.publishEvent()`
</code></pre>
</li>
</ul>
<pre><code class="java">@Component
public class MyApplicationListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;
    //当容器中发布此事件以后，方法触发
    @Override
    public void onApplicationEvent(ApplicationEvent event) &#123;
        System.out.println(&quot;收到事件：&quot; + event);
    &#125;
&#125;
</code></pre>
<hr>
<h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>ContextRefreshedEvent 事件：</p>
<ul>
<li><p>容器初始化过程中执行 <code>initApplicationEventMulticaster()</code>：初始化事件多播器</p>
<ul>
<li>先去容器中查询 <code>id = applicationEventMulticaster</code> 的组件，有直接返回</li>
<li>没有就执行 <code>this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory)</code> 并且加入到容器中</li>
<li>以后在其他组件要派发事件，自动注入这个 applicationEventMulticaster</li>
</ul>
</li>
<li><p>容器初始化过程执行 <strong>registerListeners()</strong> 注册监听器</p>
<ul>
<li>从容器中获取所有监听器：<code>getBeanNamesForType(ApplicationListener.class, true, false)</code></li>
<li>将 listener 注册到 ApplicationEventMulticaster</li>
</ul>
</li>
<li><p>容器刷新完成：finishRefresh() → publishEvent(new ContextRefreshedEvent(this))</p>
<p>发布 ContextRefreshedEvent 事件：</p>
<ul>
<li>获取事件的多播器（派发器）：getApplicationEventMulticaster()</li>
<li>multicastEvent 派发事件<ul>
<li>获取到所有的 ApplicationListener</li>
<li>遍历 ApplicationListener<ul>
<li>如果有 Executor，可以使用 Executor 异步派发 <code>Executor executor = getTaskExecutor()</code></li>
<li>没有就同步执行 listener 方法 <code>invokeListener(listener, event)</code>，拿到 listener 回调 onApplicationEvent</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>容器关闭会发布 ContextClosedEvent</p>
<hr>
<h5 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h5><p>注解：@EventListener</p>
<p>基本使用：</p>
<pre><code class="java">@Service
public class UserService&#123;
    @EventListener(classes=&#123;ApplicationEvent.class&#125;)
    public void listen(ApplicationEvent event)&#123;
        System.out.println(&quot;UserService。。监听到的事件：&quot; + event);
    &#125;
&#125;
</code></pre>
<p>原理：使用 EventListenerMethodProcessor 处理器来解析方法上的 @EventListener，Spring 扫描使用注解的方法，并为之创建一个监听对象</p>
<p>SmartInitializingSingleton 原理：afterSingletonsInstantiated()</p>
<ul>
<li><pre><code>      IOC 容器创建对象并 refresh()
</code></pre>
</li>
<li><pre><code>      finishBeanFactoryInitialization(beanFactory)：初始化剩下的单实例 bean
 * 先创建所有的单实例 bean：getBean()
 * 获取所有创建好的单实例 bean，判断是否是 SmartInitializingSingleton 类型的，如果是就调用 afterSingletonsInstantiated()
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><div class="story post-story"><h3 id="基本概述-2"><a href="#基本概述-2" class="headerlink" title="基本概述"></a>基本概述</h3><p>AOP（Aspect Oriented Programing）：面向切面编程，一种编程<strong>范式</strong>，指导开发者如何组织程序结构</p>
<p>AOP 弥补了 OOP 的不足，基于 OOP 基础之上进行横向开发：</p>
<ul>
<li><p>uOOP 规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型</p>
</li>
<li><p>uAOP 程序开发主要关注基于 OOP 开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分），将软件开发由手工制作走向半自动化&#x2F;全自动化阶段，实现“插拔式组件体系结构”搭建</p>
</li>
</ul>
<p>AOP 作用：</p>
<ul>
<li><p>提高代码的可重用性</p>
</li>
<li><p>业务代码编码更简洁</p>
</li>
<li><p>业务代码维护更高效</p>
</li>
<li><p>业务功能扩展更便捷</p>
</li>
</ul>
<hr>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="概念详解"><a href="#概念详解" class="headerlink" title="概念详解"></a>概念详解</h4><ul>
<li><p>Joinpoint（连接点）：就是方法</p>
</li>
<li><p>Pointcut（切入点）：就是挖掉共性功能的方法</p>
</li>
<li><p>Advice（通知）：就是共性功能，最终以一个方法的形式呈现</p>
</li>
<li><p>Aspect（切面）：就是共性功能与挖的位置的对应关系</p>
</li>
<li><p>Target（目标对象）：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的</p>
</li>
<li><p>Weaving（织入）：就是将挖掉的功能回填的动态过程</p>
</li>
<li><p>Proxy（代理）：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现</p>
</li>
<li><p>Introduction（引入&#x2F;引介）：就是对原始对象无中生有的添加成员变量或成员方法</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%88%87%E5%85%A5%E7%82%B9%E5%88%87%E9%9D%A2%E9%80%9A%E7%9F%A5.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%88%87%E5%85%A5%E7%82%B9%E5%88%87%E9%9D%A2%E9%80%9A%E7%9F%A5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<hr>
<h4 id="入门项目-1"><a href="#入门项目-1" class="headerlink" title="入门项目"></a>入门项目</h4><p>开发步骤：</p>
<ul>
<li><p>开发阶段</p>
<ul>
<li><p>制作程序</p>
</li>
<li><p>将非共性功能开发到对应的目标对象类中，并制作成切入点方法</p>
</li>
<li><p>将共性功能独立开发出来，制作成通知</p>
</li>
<li><p>在配置文件中，声明切入点</p>
</li>
<li><p>在配置文件中，声明切入点与通知间的关系（含通知类型），即切面</p>
</li>
</ul>
</li>
<li><p>运行阶段（AOP 完成）</p>
<ul>
<li><p>Spring 容器加载配置文件，监控所有配置的<strong>切入点</strong>方法的执行</p>
</li>
<li><p>当监控到切入点方法被运行，<strong>使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置将通知对应的功能织入</strong>，完成完整的代码逻辑并运行</p>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>导入坐标 pom.xml</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>业务层抽取通用代码  service &#x2F; UserServiceImpl</p>
<pre><code class="java">public interface UserService &#123;
    public void save();
&#125;
</code></pre>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    @Override
    public void save() &#123;
        //System.out.println(&quot;共性功能&quot;);
        System.out.println(&quot;user service running...&quot;);
    &#125;
&#125;
</code></pre>
<p>aop.AOPAdvice</p>
<pre><code class="java">//1.制作通知类，在类中定义一个方法用于完成共性功能
public class AOPAdvice &#123;
    //共性功能抽取后职称独立的方法
    public void function()&#123;
        System.out.println(&quot;共性功能&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>把通知加入spring容器管理，配置aop  applicationContext.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd
        &quot;&gt;
    &lt;!--原始Spring控制资源--&gt;
    &lt;bean id=&quot;userService&quot; class= &quot;service.impl.UserServiceImpl&quot;/&gt;
    &lt;!--2.配置共性功能成功spring控制的资源--&gt;
    &lt;bean id=&quot;myAdvice&quot; class=&quot;aop.AOPAdvice&quot;/&gt;
    &lt;!--3.开启AOP命名空间: beans标签内--&gt;
    &lt;!--4.配置AOP--&gt;
    &lt;aop:config&gt;
        &lt;!--5.配置切入点--&gt;
        &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* *..*(..))&quot;/&gt;
        &lt;!--6.配置切面（切入点与通知的关系）--&gt;
        &lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
            &lt;!--7.配置具体的切入点对应通知中那个操作方法--&gt;
            &lt;aop:before method=&quot;function&quot; pointcut-ref=&quot;pt&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">public class App &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);
        userService.save();//先输出共性功能，然后 user service running...
    &#125;
&#125;
</code></pre>
</li>
</ol>
<hr>
<h3 id="XML开发-1"><a href="#XML开发-1" class="headerlink" title="XML开发"></a>XML开发</h3><h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p>Aspect（切面）用于描述切入点与通知间的关系，是 AOP 编程中的一个概念</p>
<p>AspectJ 是基于 java 语言对 Aspect 的实现</p>
<hr>
<h4 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h4><h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><p>标签：<a href="aop:config">aop:config</a>，<beans> 的子标签</beans></p>
<p>作用：设置 AOP</p>
<p>格式：</p>
<pre><code class="xml">&lt;beans&gt;
    &lt;aop:config&gt;……&lt;/aop:config&gt;
    &lt;aop:config&gt;……&lt;/aop:config&gt;
    &lt;!--一个beans标签中可以配置多个aop:config标签--&gt;
&lt;/beans&gt;
</code></pre>
<hr>
<h5 id="pointcut"><a href="#pointcut" class="headerlink" title="pointcut"></a>pointcut</h5><p>标签：<a href="aop:pointcut">aop:pointcut</a>，归属于 aop:config 标签和 aop:aspect 标签</p>
<p>作用：设置切入点</p>
<p>格式：</p>
<pre><code class="xml">&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;pointcutId&quot; expression=&quot;……&quot;/&gt;
    &lt;aop:aspect&gt;
        &lt;aop:pointcut id=&quot;pointcutId&quot; expression=&quot;……&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>说明：</p>
<ul>
<li>一个 aop:config 标签中可以配置多个 aop:pointcut 标签，且该标签可以配置在 aop:aspect 标签内</li>
</ul>
<p>属性：</p>
<ul>
<li><p>id ：识别切入点的名称</p>
</li>
<li><p>expression ：切入点表达式</p>
</li>
</ul>
<hr>
<h5 id="aspect"><a href="#aspect" class="headerlink" title="aspect"></a>aspect</h5><p>标签：<a href="aop:aspect">aop:aspect</a>，aop:config 的子标签</p>
<p>作用：设置具体的 AOP 通知对应的切入点（切面）</p>
<p>格式：</p>
<pre><code class="xml">&lt;aop:config&gt;
    &lt;aop:aspect ref=&quot;beanId&quot;&gt;……&lt;/aop:aspect&gt;
    &lt;aop:aspect ref=&quot;beanId&quot;&gt;……&lt;/aop:aspect&gt;
    &lt;!--一个aop:config标签中可以配置多个aop:aspect标签--&gt;
&lt;/aop:config&gt;
</code></pre>
<p>属性：</p>
<ul>
<li>ref ：通知所在的 bean 的 id</li>
</ul>
<hr>
<h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h4><h5 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h5><p>切入点描述的是某个方法</p>
<p>切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式</p>
<hr>
<h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>格式：</p>
<pre><code class="xml">关键字(访问修饰符  返回值  包名.类名.方法名(参数)异常名)
</code></pre>
<p>示例：</p>
<pre><code class="java">//匹配UserService中只含有一个参数的findById方法
execution(public User service.UserService.findById(int))
</code></pre>
<p>格式解析：</p>
<ul>
<li>关键字：描述表达式的匹配模式（参看关键字列表）</li>
<li>访问修饰符：方法的访问控制权限修饰符</li>
<li>类名：方法所在的类（此处可以配置接口名称）</li>
<li>异常：方法定义中指定抛出的异常</li>
</ul>
<p>关键字：</p>
<ul>
<li><p>execution ：匹配执行指定方法</p>
</li>
<li><p>args ：匹配带有指定参数类型的方法</p>
</li>
<li><p>within、this、target、@within、@target、@args、@annotation、bean、reference pointcut等</p>
</li>
</ul>
<p>通配符：</p>
<ul>
<li><p>*：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p>
<pre><code class="java">//匹配com.seazean包下的任意包中的UserService类或接口中所有find开头的带有一个任意参数的方法
execution(public * com.seazean.*.UserService.find*(*)
</code></pre>
</li>
<li><p>.. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数</p>
<pre><code class="java">//匹配com包下的任意包中的UserService类或接口中所有名称为findById参数任意数量和类型的方法
execution(public User com..UserService.findById(..))
</code></pre>
</li>
<li><p>+：专用于匹配子类类型</p>
<pre><code class="java">//匹配任意包下的Service结尾的类或者接口的子类或者实现类
execution(* *..*Service+.*(..))
</code></pre>
</li>
</ul>
<p>逻辑运算符：</p>
<ul>
<li>&amp;&amp;：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配</li>
<li>||：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配</li>
<li>! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配</li>
</ul>
<p>示例：</p>
<pre><code class="java">execution(* *(..))        //前三个都是匹配全部
execution(* *..*(..))
execution(* *..*.*(..))
execution(public * *..*.*(..))
execution(public int *..*.*(..))
execution(public void *..*.*(..))
execution(public void com..*.*(..)) 
execution(public void com..service.*.*(..))
execution(public void com.seazean.service.*.*(..))
execution(public void com.seazean.service.User*.*(..))
execution(public void com.seazean.service.*Service.*(..))
execution(public void com.seazean.service.UserService.*(..))
execution(public User com.seazean.service.UserService.find*(..))    //find开头
execution(public User com.seazean.service.UserService.*Id(..))        //I
execution(public User com.seazean.service.UserService.findById(..))
execution(public User com.seazean.service.UserService.findById(int))
execution(public User com.seazean.service.UserService.findById(int,int))
execution(public User com.seazean.service.UserService.findById(int,*))
execution(public User com.seazean.service.UserService.findById())
execution(List com.seazean.service.*Service+.findAll(..))
</code></pre>
<hr>
<h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>XML 配置规则：</p>
<ul>
<li><p>企业开发命名规范严格遵循规范文档进行</p>
</li>
<li><p>先为方法配置局部切入点，再抽取类中公共切入点，最后抽取全局切入点</p>
</li>
<li><p>代码走查过程中检测切入点是否存在越界性包含</p>
</li>
<li><p>代码走查过程中检测切入点是否存在非包含性进驻</p>
</li>
<li><p>设定 AOP 执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配（不绝对正确：加进一个不该加的，删去一个不该删的相当于结果不变）</p>
</li>
<li><p>设定完毕的切入点如果发生调整务必进行回归测试</p>
</li>
</ul>
<pre><code class="xml">&lt;aop:config&gt;
    &lt;!--1.配置公共切入点--&gt;
    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* *(..))&quot;/&gt;
    &lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
        &lt;!--2.配置局部切入点--&gt;
        &lt;aop:pointcut id=&quot;pt2&quot; expression=&quot;execution(* *(..))&quot;/&gt;
        &lt;!--引用公共切入点--&gt;
        &lt;aop:before method=&quot;logAdvice&quot; pointcut-ref=&quot;pt1&quot;/&gt;
        &lt;!--引用局部切入点--&gt;
        &lt;aop:before method=&quot;logAdvice&quot; pointcut-ref=&quot;pt2&quot;/&gt;
        &lt;!--3.直接配置切入点--&gt;
        &lt;aop:before method=&quot;logAdvice&quot; pointcut=&quot;execution(* *(..))&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<hr>
<h4 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h4><h5 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h5><p>AOP 的通知类型共5种：前置通知，后置通知、返回后通知、抛出异常后通知、环绕通知</p>
<h6 id="before"><a href="#before" class="headerlink" title="before"></a>before</h6><p>标签：<a href="aop:before">aop:before</a>，aop:aspect的子标签</p>
<p>作用：设置前置通知</p>
<ul>
<li><strong>前置通知</strong>：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行</li>
<li>应用：数据校验</li>
</ul>
<p>格式：</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;adviceId&quot;&gt;
    &lt;aop:before method=&quot;methodName&quot; pointcut=&quot;execution(* *(..))&quot;/&gt;
    &lt;!--一个aop:aspect标签中可以配置多个aop:before标签--&gt;
&lt;/aop:aspect&gt;
</code></pre>
<p>基本属性：</p>
<ul>
<li><p>method：在通知类中设置当前通知类别对应的方法</p>
</li>
<li><p>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p>
</li>
<li><p>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</p>
</li>
</ul>
<h6 id="after"><a href="#after" class="headerlink" title="after"></a>after</h6><p>标签：<a href="aop:after">aop:after</a>，aop:aspect的子标签</p>
<p>作用：设置后置通知</p>
<ul>
<li><p><strong>后置通知</strong>：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知</p>
</li>
<li><p>应用：现场清理</p>
</li>
</ul>
<p>格式：</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;adviceId&quot;&gt;
    &lt;aop:after method=&quot;methodName&quot; pointcut=&quot;execution(* *(..))&quot;/&gt;
    &lt;!--一个aop:aspect标签中可以配置多个aop:after标签--&gt;
&lt;/aop:aspect&gt;
</code></pre>
<p>基本属性：</p>
<ul>
<li><p>method：在通知类中设置当前通知类别对应的方法</p>
</li>
<li><p>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p>
</li>
<li><p>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</p>
</li>
</ul>
<h6 id="after-r"><a href="#after-r" class="headerlink" title="after-r"></a>after-r</h6><p>标签：<a href="aop:after-returning">aop:after-returning</a>，aop:aspect的子标签</p>
<p>作用：设置返回后通知</p>
<ul>
<li><p><strong>返回后通知</strong>：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行</p>
</li>
<li><p>应用：返回值相关数据处理</p>
</li>
</ul>
<p>格式：</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;adviceId&quot;&gt;
    &lt;aop:after-returning method=&quot;methodName&quot; pointcut=&quot;execution(* *(..))&quot;/&gt;
    &lt;!--一个aop:aspect标签中可以配置多个aop:after-returning标签--&gt;
&lt;/aop:aspect&gt;
</code></pre>
<p>基本属性：</p>
<ul>
<li>method：在通知类中设置当前通知类别对应的方法</li>
<li>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</li>
<li>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</li>
<li>returning：设置接受返回值的参数，与通知类中对应方法的参数一致</li>
</ul>
<h6 id="after-t"><a href="#after-t" class="headerlink" title="after-t"></a>after-t</h6><p>标签：<a href="aop:after-throwing">aop:after-throwing</a>，aop:aspect的子标签</p>
<p>作用：设置抛出异常后通知</p>
<ul>
<li><strong>抛出异常后通知</strong>：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行</li>
<li>应用：对原始方法中出现的异常信息进行处理</li>
</ul>
<p>格式：</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;adviceId&quot;&gt;
    &lt;aop:after-throwing method=&quot;methodName&quot; pointcut=&quot;execution(* *(..))&quot;/&gt;
    &lt;!--一个aop:aspect标签中可以配置多个aop:after-throwing标签--&gt;
&lt;/aop:aspect&gt;
</code></pre>
<p>基本属性：</p>
<ul>
<li>method：在通知类中设置当前通知类别对应的方法</li>
<li>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</li>
<li>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</li>
<li>throwing：设置接受异常对象的参数，与通知类中对应方法的参数一致</li>
</ul>
<h6 id="around"><a href="#around" class="headerlink" title="around"></a>around</h6><p>标签：<a href="aop:around">aop:around</a>，aop:aspect的子标签</p>
<p>作用：设置环绕通知</p>
<ul>
<li><p><strong>环绕通知</strong>：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行</p>
</li>
<li><p>应用：功能强大，可以做任何事情</p>
</li>
</ul>
<p>格式：</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;adviceId&quot;&gt;
    &lt;aop:around method=&quot;methodName&quot; pointcut=&quot;execution(* *(..))&quot;/&gt;
    &lt;!--一个aop:aspect标签中可以配置多个aop:around标签--&gt;
&lt;/aop:aspect&gt;
</code></pre>
<p>基本属性：</p>
<ul>
<li><p>method ：在通知类中设置当前通知类别对应的方法</p>
</li>
<li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p>
</li>
<li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p>
</li>
</ul>
<p>环绕通知的开发方式（参考通知顺序章节）：</p>
<ul>
<li><p>环绕通知是<strong>在原始方法的前后添加功能</strong>，在环绕通知中，存在对原始方法的显式调用</p>
<pre><code class="java">public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;
    Object ret = pjp.proceed();
    return ret;
&#125;
</code></pre>
</li>
<li><p>环绕通知方法相关说明：</p>
<ul>
<li><p>方法须设定 Object 类型的返回值，否则会<strong>拦截</strong>原始方法的返回。如果原始方法返回值类型为 void，通知方法也可以设定返回值类型为 void，最终返回 null</p>
</li>
<li><p>方法需在第一个参数位置设定 ProceedingJoinPoint 对象，通过该对象调用 proceed() 方法，实现<strong>对原始方法的调用</strong>。如省略该参数，原始方法将无法执行</p>
</li>
<li><p>使用 proceed() 方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出 Throwable 对象，封装原始方法中可能出现的异常信息</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h5><p>当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准。</p>
<ul>
<li><p>AOPAdvice</p>
<pre><code class="java">public class AOPAdvice &#123;
    public void before()&#123;
        System.out.println(&quot;before...);
    &#125;
    public void after()&#123;
        System.out.println(&quot;after...&quot;);
    &#125;
    public void afterReturing()&#123;
        System.out.println(&quot;afterReturing...&quot;);
    &#125;
    public void afterThrowing()&#123;
        System.out.println(&quot;afterThrowing...&quot;);
    &#125;
    public Object around(ProceedingJoinPoint pjp) &#123;
        System.out.println(&quot;around before...&quot;);
           //对原始方法的调用
        Object ret = pjp.proceed();
        System.out.println(&quot;around after...&quot;+ret);
           return ret;
    &#125;
&#125;
</code></pre>
</li>
<li><p>applicationContext.xml  <strong>顺序执行</strong></p>
<pre><code class="xml">&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* *..*(..))&quot;/&gt;
    &lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pt&quot;/&gt;
        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pt&quot;/&gt;
        &lt;aop:after-returning method=&quot;afterReturing&quot; pointcut-ref=&quot;pt&quot;/&gt;
        &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pt&quot;/&gt;
        &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pt&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ul>
<hr>
<h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>第一种方式：</p>
<ul>
<li><p>设定通知方法第一个参数为 JoinPoint，通过该对象调用 getArgs() 方法，获取原始方法运行的参数数组</p>
<pre><code class="java">public void before(JoinPoint jp) throws Throwable &#123;
    Object[] args = jp.getArgs();
&#125;
</code></pre>
</li>
<li><p>所有的通知均可以获取参数，环绕通知使用ProceedingJoinPoint.getArgs()方法</p>
</li>
</ul>
<p>第二种方式：</p>
<ul>
<li><p>设定切入点表达式为通知方法传递参数（锁定通知变量名）</p>
</li>
<li><p>流程图：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%BA%8C.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%BA%8C.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
<li><p>解释：</p>
<ul>
<li><code>&amp;amp</code> 代表并且 &amp;</li>
<li>输出结果：a &#x3D; param1   b &#x3D; param2</li>
</ul>
</li>
</ul>
<p>第三种方式：</p>
<ul>
<li><p>设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序）</p>
</li>
<li><p>流程图：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%B8%89.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%B8%89.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
<li><p>解释：输出结果 a &#x3D; param2   b &#x3D; param1</p>
</li>
</ul>
<hr>
<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><p>环绕通知和返回后通知可以获取返回值，后置通知不一定，其他类型获取不到</p>
<p>第一种方式：适用于返回后通知（after-returning）</p>
<ul>
<li><p>设定返回值变量名</p>
</li>
<li><p>原始方法：</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    @Override
    public int save() &#123;
        System.out.println(&quot;user service running...&quot;);
        return 100;
    &#125;
&#125;
</code></pre>
</li>
<li><p>AOP 配置：</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* *(..))&quot;/&gt;
    &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pt&quot; returning=&quot;ret&quot;/&gt;
&lt;/aop:aspect&gt;
</code></pre>
</li>
<li><p>通知类：</p>
<pre><code class="java">public class AOPAdvice &#123;
    public void afterReturning(Object ret) &#123;
        System.out.println(&quot;return:&quot; + ret);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>第二种：适用于环绕通知（around）</p>
<ul>
<li><p>在通知类的方法中调用原始方法获取返回值</p>
</li>
<li><p>原始方法：</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    @Override
    public int save() &#123;
        System.out.println(&quot;user service running...&quot;);
        return 100;
    &#125;
&#125;
</code></pre>
</li>
<li><p>AOP 配置：</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* *(..))  &quot;/&gt;
    &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pt&quot; /&gt;
&lt;/aop:aspect&gt;
</code></pre>
</li>
<li><p>通知类：</p>
<pre><code class="java">public class AOPAdvice &#123;    
    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;
        Object ret = pjp.proceed();
        return ret;
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试类：</p>
<pre><code class="java">public class App &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);
        int ret = userService.save();
           System.out.println(&quot;app.....&quot; + ret);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h6 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h6><p>环绕通知和抛出异常后通知可以获取异常，后置通知不一定，其他类型获取不到</p>
<p>第一种：适用于返回后通知（after-throwing）</p>
<ul>
<li><p>设定异常对象变量名</p>
</li>
<li><p>原始方法</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    @Override
    public void save() &#123;
        System.out.println(&quot;user service running...&quot;);
        int i = 1/0;
    &#125;
&#125;
</code></pre>
</li>
<li><p>AOP 配置</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* *(..))  &quot;/&gt;
    &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pt&quot; throwing=&quot;t&quot;/&gt;
&lt;/aop:aspect&gt;
</code></pre>
</li>
<li><p>通知类</p>
<pre><code class="java">public void afterThrowing(Throwable t)&#123;
    System.out.println(t.getMessage());
&#125;
</code></pre>
</li>
</ul>
<p>第二种：适用于环绕通知（around）</p>
<ul>
<li>在通知类的方法中调用原始方法捕获异常</li>
</ul>
<ul>
<li><p>原始方法：</p>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    @Override
    public void save() &#123;
        System.out.println(&quot;user service running...&quot;);
        int i = 1/0;
    &#125;
&#125;
</code></pre>
</li>
<li><p>AOP 配置：</p>
<pre><code class="xml">&lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* *(..))  &quot;/&gt;
    &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pt&quot; /&gt;
&lt;/aop:aspect&gt;
</code></pre>
</li>
<li><p>通知类：try……catch……捕获异常后，ret为null</p>
<pre><code class="java">public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;
    Object ret = pjp.proceed();    //对此处调用进行try……catch……捕获异常，或抛出异常
    /* try &#123;
            ret = pjp.proceed();
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;around exception...&quot; + throwable.getMessage());
        &#125;*/
    return ret;
&#125;
</code></pre>
</li>
</ul>
<ul>
<li><p>测试类</p>
<pre><code class="java">userService.delete();
</code></pre>
</li>
</ul>
<hr>
<h6 id="获取全部"><a href="#获取全部" class="headerlink" title="获取全部"></a>获取全部</h6><ul>
<li><p>UserService</p>
<pre><code class="java">public interface UserService &#123;
    public void save(int i, int m);

    public int update();

    public void delete();
&#125;
</code></pre>
<pre><code class="java">public class UserServiceImpl implements UserService &#123;
    @Override
    public void save(int i, int m) &#123;
        System.out.println(&quot;user service running...&quot; + i + &quot;,&quot; + m);
    &#125;

    @Override
    public int update() &#123;
        System.out.println(&quot;user service update running...&quot;);
        return 100;
    &#125;

    @Override
    public void delete() &#123;
        System.out.println(&quot;user service delete running...&quot;);
        int i = 1 / 0;
    &#125;
&#125;
</code></pre>
</li>
<li><p>AOPAdvice</p>
<pre><code class="java">public class AOPAdvice &#123;
    public void before(JoinPoint jp)&#123;
        //通过JoinPoint参数获取调用原始方法所携带的参数
        Object[] args = jp.getArgs();
        System.out.println(&quot;before...&quot;+args[0]);
    &#125;

    public void after(JoinPoint jp)&#123;
        Object[] args = jp.getArgs();
        System.out.println(&quot;after...&quot;+args[0]);
    &#125;

    public void afterReturing(Object ret)&#123;
        System.out.println(&quot;afterReturing...&quot;+ret);
    &#125;

    public void afterThrowing(Throwable t)&#123;
        System.out.println(&quot;afterThrowing...&quot;+t.getMessage());
    &#125;

    public Object around(ProceedingJoinPoint pjp) &#123;
        System.out.println(&quot;around before...&quot;);
        Object ret = null;
        try &#123;
            //对原始方法的调用
            ret = pjp.proceed();
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;around...exception....&quot;+throwable.getMessage());
        &#125;
        System.out.println(&quot;around after...&quot;+ret);
        return ret;
    &#125;
&#125;
</code></pre>
</li>
<li><p>applicationContext.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd
        &quot;&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;service.impl.UserServiceImpl&quot;/&gt;
    &lt;bean id=&quot;myAdvice&quot; class=&quot;aop.AOPAdvice&quot;/&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* *..*(..))&quot;/&gt;
        &lt;aop:aspect ref=&quot;myAdvice&quot;&gt;
            &lt;aop:before method=&quot;before&quot; pointcut=&quot;pt&quot;/&gt;
            &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pt&quot;/&gt;
            &lt;aop:after method=&quot;after&quot; pointcut=&quot;pt&quot;/&gt;
            &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pt&quot; returning=&quot;ret&quot;/&gt;
            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pt&quot; throwing=&quot;t&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">public class App &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);
//        userService.save(666, 888);
//        int ret = userService.update();
//        System.out.println(&quot;app.....&quot; + ret);
        userService.delete();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="注解开发-2"><a href="#注解开发-2" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="AOP注解"><a href="#AOP注解" class="headerlink" title="AOP注解"></a>AOP注解</h4><p>AOP 注解简化 XML：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>注意事项：</p>
<ol>
<li><p>切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法</p>
</li>
<li><p>引用切入点时必须使用方法调用名称，方法后面的 () 不能省略</p>
</li>
<li><p>切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用</p>
</li>
<li><p>可以在通知类型注解后添加参数，实现 XML 配置中的属性，例如 after-returning 后的 returning 性</p>
</li>
</ol>
<hr>
<h4 id="启动注解"><a href="#启动注解" class="headerlink" title="启动注解"></a>启动注解</h4><h5 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h5><p>开启 AOP 注解支持：</p>
<pre><code class="xml">&lt;aop:aspectj-autoproxy/&gt;
&lt;context:component-scan base-package=&quot;aop,config,service&quot;/&gt;&lt;!--启动Spring扫描--&gt;
</code></pre>
<p>开发步骤：</p>
<ol>
<li>导入坐标（伴随 spring-context 坐标导入已经依赖导入完成）</li>
<li>开启 AOP 注解支持</li>
<li>配置切面 @Aspect</li>
<li>定义专用的切入点方法，并配置切入点 @Pointcut</li>
<li>为通知方法配置通知类型及对应切入点 @Before</li>
</ol>
<h5 id="纯注解-1"><a href="#纯注解-1" class="headerlink" title="纯注解"></a>纯注解</h5><p>注解：@EnableAspectJAutoProxy</p>
<p>位置：Spring 注解配置类定义上方</p>
<p>作用：设置当前类开启 AOP 注解驱动的支持，加载 AOP 注解</p>
<p>格式：</p>
<pre><code class="java">@Configuration
@ComponentScan(&quot;com.seazean&quot;)
@EnableAspectJAutoProxy
public class SpringConfig &#123;
&#125;
</code></pre>
<hr>
<h4 id="基本注解-1"><a href="#基本注解-1" class="headerlink" title="基本注解"></a>基本注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h5><p>注解：@Aspect</p>
<p>位置：类定义上方</p>
<p>作用：设置当前类为切面类</p>
<p>格式：</p>
<pre><code class="java">@Aspect
public class AopAdvice &#123;
&#125;
</code></pre>
<h5 id="Pointcut-1"><a href="#Pointcut-1" class="headerlink" title="Pointcut"></a>Pointcut</h5><p>注解：@Pointcut</p>
<p>位置：方法定义上方</p>
<p>作用：使用当前方法名作为切入点引用名称</p>
<p>格式：</p>
<pre><code class="java">@Pointcut(&quot;execution(* *(..))&quot;)
public void pt() &#123;
&#125;
</code></pre>
<p>说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）</p>
<h5 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h5><p>注解：@Before</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为前置通知</p>
<p>格式：</p>
<pre><code class="java">@Before(&quot;pt()&quot;)
public void before(JoinPoint joinPoint)&#123;
    //joinPoint.getArgs();
&#125;
</code></pre>
<p>注意：<strong>多个参数时，JoinPoint参数一定要在第一位</strong></p>
<h5 id="After"><a href="#After" class="headerlink" title="After"></a>After</h5><p>注解：@After</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为后置通知</p>
<p>格式：</p>
<pre><code class="java">@After(&quot;pt()&quot;)
public void after()&#123;
&#125;
</code></pre>
<h5 id="AfterR"><a href="#AfterR" class="headerlink" title="AfterR"></a>AfterR</h5><p>注解：@AfterReturning</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为返回后通知</p>
<p>格式：</p>
<pre><code class="java">@AfterReturning(value=&quot;pt()&quot;, returning = &quot;result&quot;)
public void afterReturning(Object result) &#123;
&#125;
</code></pre>
<p>特殊参数：</p>
<ul>
<li>returning ：设定使用通知方法参数<strong>接收</strong>返回值的变量名</li>
</ul>
<h5 id="AfterT"><a href="#AfterT" class="headerlink" title="AfterT"></a>AfterT</h5><p>注解：@AfterThrowing</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为异常后通知</p>
<p>格式：</p>
<pre><code class="java">@AfterThrowing(value=&quot;pt()&quot;, throwing = &quot;t&quot;)
public void afterThrowing(Throwable t)&#123;
&#125;
</code></pre>
<p>特殊参数：</p>
<ul>
<li>throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名</li>
</ul>
<h5 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h5><p>注解：@Around</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为环绕通知</p>
<p>格式：</p>
<pre><code class="java">@Around(&quot;pt()&quot;)
public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;
    Object ret = pjp.proceed();
    return ret;
&#125;
</code></pre>
<hr>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>AOP 使用 XML 配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念，参照通知所配置的<strong>方法名字符串对应的编码值顺序</strong>，可以简单理解为字母排序</p>
<ul>
<li><p>同一个通知类中，相同通知类型以方法名排序为准</p>
<pre><code class="java">@Before(&quot;aop.AOPPointcut.pt()&quot;)
public void aop001Log()&#123;&#125;

@Before(&quot;aop.AOPPointcut.pt()&quot;)
public void aop002Exception()&#123;&#125;
</code></pre>
</li>
<li><p>不同通知类中，以类名排序为准</p>
</li>
<li><p>使用 @Order 注解通过变更 bean 的加载顺序改变通知的加载顺序</p>
<pre><code class="java">@Component
@Aspect
@Order(1)  //先执行
public class AOPAdvice2 &#123;
&#125;
</code></pre>
<pre><code class="java">@Component
@Aspect
@Order(2) 
public class AOPAdvice1 &#123;//默认执行此通知
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能</p>
<pre><code class="java">public class UserServiceDecorator implements UserService&#123;
    private UserService userService;
    
    public UserServiceDecorator(UserService userService) &#123;
        this.userService = userService;
    &#125;
    
    public void save() &#123;
        //原始调用
        userService.save();
        //增强功能（后置）
        System.out.println(&quot;后置增强功能&quot;);
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>JDKProxy 动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强，因为<strong>代理类继承Proxy</strong></p>
<p>静态代理和动态代理的区别：</p>
<ul>
<li>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</li>
<li>动态代理是程序在运行后通过反射创建字节码文件交由 JVM 加载</li>
</ul>
<pre><code class="java">public class UserServiceJDKProxy &#123;
    public static UserService createUserServiceJDKProxy(UserService userService) &#123;
        UserService service = (UserService) Proxy.newProxyInstance(
            userService.getClass().getClassLoader(),//获取被代理对象的类加载器
            userService.getClass().getInterfaces(),    //获取被代理对象实现的接口
            new InvocationHandler() &#123;                //对原始方法执行进行拦截并增强
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                    if (method.getName().equals(&quot;save&quot;)) &#123;
                        System.out.println(&quot;前置增强&quot;);
                        Object ret = method.invoke(userService, args);
                        System.out.println(&quot;后置增强&quot;);
                        return ret;
                    &#125;
                    return null;
                &#125;
             &#125;);
        return service;
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><p>CGLIB（Code Generation Library）：Code 生成类库 </p>
<p>CGLIB 特点：</p>
<ul>
<li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li>
<li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li>
<li>CGLIB <strong>继承被代理类</strong>，如果代理类是 final 则不能实现</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-cglib.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-cglib.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ul>
<li><p>CGLIB 类</p>
<ul>
<li>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强，包括 Object 类中的方法（toString、hashCode）</li>
<li>返回值类型采用多态向下转型，所以需要设置父类类型</li>
</ul>
<p>需要对方法进行判断是否是 save，来选择性增强</p>
<pre><code class="java">public class UserServiceImplCglibProxy &#123;
    public static UserService createUserServiceCglibProxy(Class cls)&#123;
        //1.创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码）
        Enhancer enhancer = new Enhancer();
        
        //2.设置Enhancer对象的父类是指定类型UserServerImpl
        enhancer.setSuperclass(cls);
        
        //3.设置回调方法
        enhancer.setCallback(new MethodInterceptor() &#123;
            @Override
            public Object intercept(Object o, Method m, Object[] args, MethodProxy mp) throws Throwable &#123;
                //o是被代理出的类创建的对象，所以使用MethodProxy调用，并且是调用父类
                //通过调用父类的方法实现对原始方法的调用
                Object ret = methodProxy.invokeSuper(o, args);
                //后置增强内容,需要判断是都是save方法
                if (method.getName().equals(&quot;save&quot;)) &#123;
                    System.out.println(&quot;I love Java&quot;);
                &#125;
                return ret;
            &#125;
        &#125;);
        //使用Enhancer对象创建对应的对象
        return (UserService)enhancer.create();
    &#125;
&#125;
</code></pre>
</li>
<li><p>Test类</p>
<pre><code class="java">public class App &#123;
    public static void main(String[] args) &#123;
        UserService userService = UserServiceCglibProxy.createUserServiceCglibProxy(UserServiceImpl.class);
        userService.save();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="代理选择"><a href="#代理选择" class="headerlink" title="代理选择"></a>代理选择</h4><p>Spirng 可以通过配置的形式控制使用的代理形式，Spring 会先判断是否实现了接口，如果实现了接口就使用 JDK 动态代理，如果没有实现接口则使用 CGLIB 动态代理，通过配置可以修改为使用 CGLIB </p>
<ul>
<li><p>XML 配置</p>
<pre><code class="xml">&lt;!--XML配置AOP--&gt;
&lt;aop:config proxy-target-class=&quot;false&quot;&gt;&lt;/aop:config&gt;
</code></pre>
</li>
<li><p>XML 注解支持</p>
<pre><code class="xml">&lt;!--注解配置AOP--&gt;
&lt;aop:aspectj-autoproxy proxy-target-class=&quot;false&quot;/&gt;
</code></pre>
</li>
<li><p>注解驱动</p>
<pre><code class="java">//修改为使用 cglib 创建代理对象
@EnableAspectJAutoProxy(proxyTargetClass = true)
</code></pre>
</li>
</ul>
<ul>
<li><p>JDK 动态代理和 CGLIB 动态代理的区别：</p>
<ul>
<li>JDK 动态代理只能对实现了接口的类生成代理，没有实现接口的类不能使用。</li>
<li>CGLIB 动态代理即使被代理的类没有实现接口也可以使用，因为 CGLIB 动态代理是使用继承被代理类的方式进行扩展</li>
<li>CGLIB 动态代理是通过继承的方式，覆盖被代理类的方法来进行代理，所以如果方法是被 final 修饰的话，就不能进行代理</li>
</ul>
</li>
</ul>
<hr>
<h4 id="织入时机"><a href="#织入时机" class="headerlink" title="织入时机"></a>织入时机</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5%E6%97%B6%E6%9C%BA.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5%E6%97%B6%E6%9C%BA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="AOP织入时机"></p>
<hr>
</div><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><div class="story post-story"><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><h4 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h4><p>事务：数据库中多个操作合并在一起形成的操作序列，事务特征（ACID）</p>
<p>作用：</p>
<ul>
<li>当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（<strong>A</strong>），保障数据库即使在异常状态下仍能保持数据一致性（<strong>C</strong>）（要么操作前状态，要么操作后状态）</li>
<li>当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（<strong>I</strong>）</li>
</ul>
<p>Spring 事务一般加到业务层，对应着业务的操作，Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的，Spring 只提供统一事务管理接口</p>
<p>Spring 在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。程序是否支持事务首先取决于数据库 ，比如 MySQL ，如果是 <strong>Innodb 引擎</strong>，是支持事务的；如果 MySQL 使用 MyISAM 引擎，那从根上就是不支持事务的</p>
<p><strong>保证原子性</strong>：</p>
<ul>
<li>要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong></li>
<li>在 MySQL 中，恢复机制是通过<strong>回滚日志（undo log）</strong> 实现，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，直接利用回滚日志中的信息将数据回滚到修改之前的样子即可</li>
<li>回滚日志会先于数据持久化到磁盘上，这样保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务</li>
</ul>
<hr>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别</li>
</ul>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
<p><strong>分布式事务</strong>：允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源，全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高</p>
<p>在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE</p>
<hr>
<h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题，也就是方法嵌套：</p>
<ul>
<li><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p>
</li>
<li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行</p>
<pre><code class="java">//外层事务 Service A 的 aMethod 调用内层 Service B 的 bMethod
class A &#123;
    @Transactional(propagation=propagation.xxx)
    public void aMethod &#123;
        B b = new B();
        b.bMethod();
    &#125;
&#125;
class B &#123;
    @Transactional(propagation=propagation.xxx)
    public void bMethod &#123;&#125;
&#125;
</code></pre>
</li>
</ul>
<p><strong>支持当前事务</strong>的情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务则<strong>加入该事务</strong>；如果当前没有事务则创建一个新的事务<ul>
<li>内外层是相同的事务，在 aMethod 或者在 bMethod 内的任何地方出现异常，事务都会被回滚</li>
<li>工作流程：<ul>
<li>线程执行到 serviceA.aMethod() 时，其实是执行的代理 serviceA 对象的 aMethod</li>
<li>首先执行事务增强器逻辑（环绕增强），提取事务标签属性，检查当前线程是否绑定 connection 数据库连接资源，没有就调用 datasource.getConnection()，设置事务提交为手动提交 autocommit(false)</li>
<li>执行其他增强器的逻辑，然后调用 target 的目标方法 aMethod() 方法，进入 serviceB 的逻辑</li>
<li>serviceB 也是先执行事务增强器的逻辑，提取事务标签属性，但此时会检查到线程绑定了 connection，检查注解的传播属性，所以调用 DataSourceUtils.getConnection(datasource) 共享该连接资源，执行完相关的增强和 SQL 后，发现事务并不是当前方法开启的，可以直接返回上层</li>
<li>serviceA.aMethod() 继续执行，执行完增强后进行提交事务或回滚事务</li>
</ul>
</li>
</ul>
</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则以非事务的方式继续运行</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则抛出异常</li>
</ul>
<p><strong>不支持当前事务</strong>的情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起<ul>
<li>内外层是不同的事务，如果 bMethod 已经提交，如果 aMethod 失败回滚 ，bMethod 不会回滚</li>
<li>如果 bMethod 失败回滚，ServiceB 抛出的异常被 ServiceA 捕获，如果 B 抛出的异常是 A 会回滚的异常，aMethod 事务需要回滚，否则仍然可以提交</li>
</ul>
</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： <strong>以非事务方式运行</strong>，如果当前存在事务，则把当前事务挂起</li>
<li>TransactionDefinition.PROPAGATION_NEVER： <strong>以非事务方式运行</strong>，如果当前存在事务，则抛出异常</li>
</ul>
<p>其他情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务（两个事务没有关系）来运行<ul>
<li>如果 ServiceB 异常回滚，可以通过 try-catch 机制执行 ServiceC</li>
<li>如果 ServiceB 提交， ServiceA 可以根据具体的配置决定是 commit 还是 rollback</li>
<li><strong>应用场景</strong>：在查询数据的时候要向数据库中存储一些日志，系统不希望存日志的行为影响到主逻辑，可以使用该传播</li>
</ul>
</li>
</ul>
<p>requied：必须的、supports：支持的、mandatory：强制的、nested：嵌套的</p>
<hr>
<h4 id="超时属性"><a href="#超时属性" class="headerlink" title="超时属性"></a>超时属性</h4><p>事务超时，指一个事务所允许执行的最长时间，如果超过该时间限制事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为 -1</p>
<hr>
<h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务；只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中</p>
<p>读操作为什么需要启用事务支持：</p>
<ul>
<li>MySQL  默认对每一个新建立的连接都启用了 <code>autocommit</code> 模式，在该模式下，每一个发送到 MySQL 服务器的 SQL 语句都会在一个<strong>单独</strong>的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务</li>
<li>执行多条查询语句，如果方法加上了 <code>@Transactional</code> 注解，这个方法执行的所有 SQL 会被放在一个事务中，如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的收益。如果不加 <code>@Transactional</code>，每条 SQL 会开启一个单独的事务，中间被其它事务修改了数据，比如在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则这次整体的统计查询将会出<strong>现读数据不一致的状态</strong></li>
</ul>
<hr>
<h3 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h3><h4 id="事务对象"><a href="#事务对象" class="headerlink" title="事务对象"></a>事务对象</h4><p>J2EE 开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理</p>
<p>Spring 为业务层提供了整套的事务解决方案：</p>
<ul>
<li><p>PlatformTransactionManager</p>
</li>
<li><p>TransactionDefinition</p>
</li>
<li><p>TransactionStatus</p>
</li>
</ul>
<hr>
<h4 id="PTM"><a href="#PTM" class="headerlink" title="PTM"></a>PTM</h4><p>PlatformTransactionManager，平台事务管理器实现类：</p>
<ul>
<li><p>DataSourceTransactionManager  适用于 Spring JDBC 或 MyBatis</p>
</li>
<li><p>HibernateTransactionManager  适用于 Hibernate3.0 及以上版本</p>
</li>
<li><p>JpaTransactionManager  适用于 JPA</p>
</li>
<li><p>JdoTransactionManager  适用于 JDO</p>
</li>
<li><p>JtaTransactionManager  适用于 JTA</p>
</li>
</ul>
<p>管理器：</p>
<ul>
<li><p>JPA（Java Persistence API）Java EE 标准之一，为 POJO 提供持久化标准规范，并规范了持久化开发的统一 API，符合 JPA 规范的开发可以在不同的 JPA 框架下运行</p>
<p><strong>非持久化一个字段</strong>：</p>
<pre><code class="java">static String transient1; // not persistent because of static
final String transient2 = “Satish”; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient
</code></pre>
</li>
<li><p>JDO（Java Data Object）是 Java 对象持久化规范，用于存取某种数据库中的对象，并提供标准化 API。JDBC 仅针对关系数据库进行操作，JDO 可以扩展到关系数据库、XML、对象数据库等，可移植性更强</p>
</li>
<li><p>JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与 JDBC 相比，JDBC 事务则被限定在一个单一的数据库连接，而一个 JTA 事务可以有多个参与者，比如 JDBC 连接、JDO 都可以参与到一个 JTA 事务中</p>
</li>
</ul>
<p>此接口定义了事务的基本操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TransactionStatus getTransaction(TransactionDefinition definition)</td>
<td>获取事务</td>
</tr>
<tr>
<td>void commit(TransactionStatus status)</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback(TransactionStatus status)</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<hr>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>TransactionDefinition 此接口定义了事务的基本信息：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>获取事务定义名称</td>
</tr>
<tr>
<td>boolean isReadOnly()</td>
<td>获取事务的读写属性</td>
</tr>
<tr>
<td>int getIsolationLevel()</td>
<td>获取事务隔离级别</td>
</tr>
<tr>
<td>int getTimeout()</td>
<td>获取事务超时时间</td>
</tr>
<tr>
<td>int getPropagationBehavior()</td>
<td>获取事务传播行为特征</td>
</tr>
</tbody></table>
<hr>
<h4 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h4><p>TransactionStatus 此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isNewTransaction()</td>
<td>获取事务是否处于新开始事务状态</td>
</tr>
<tr>
<td>voin flush()</td>
<td>刷新事务状态</td>
</tr>
<tr>
<td>boolean isCompleted()</td>
<td>获取事务是否处于已完成状态</td>
</tr>
<tr>
<td>boolean hasSavepoint()</td>
<td>获取事务是否具有回滚储存点</td>
</tr>
<tr>
<td>boolean isRollbackOnly()</td>
<td>获取事务是否处于回滚状态</td>
</tr>
<tr>
<td>void setRollbackOnly()</td>
<td>设置事务处于回滚状态</td>
</tr>
</tbody></table>
<hr>
<h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p>编程式、声明式（XML）、声明式（注解）</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>银行转账业务</p>
<ul>
<li><p>包装类</p>
<pre><code class="java">public class Account implements Serializable &#123;
    private Integer id;
    private String name;
    private Double money;
    .....
&#125;
</code></pre>
</li>
<li><p>DAO层接口：AccountDao</p>
<pre><code class="java">public interface AccountDao &#123;
    //入账操作    name:入账用户名    money:入账金额
    void inMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);

    //出账操作    name:出账用户名    money:出账金额
    void outMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);
&#125;
</code></pre>
</li>
<li><p>业务层接口提供转账操作：AccountService</p>
<pre><code class="java">public interface AccountService &#123;
    //转账操作    outName:出账用户名    inName:入账用户名    money:转账金额
    public void transfer(String outName,String inName,Double money);
&#125;
</code></pre>
</li>
<li><p>业务层实现提供转账操作：AccountServiceImpl</p>
<pre><code class="java">public class AccountServiceImpl implements AccountService &#123;
    private AccountDao accountDao;
    public void setAccountDao(AccountDao accountDao) &#123;
        this.accountDao = accountDao;
    &#125;
    @Override
    public void transfer(String outName,String inName,Double money)&#123;
        accountDao.inMoney(outName,money);
        accountDao.outMoney(inName,money);
    &#125;
&#125;
</code></pre>
</li>
<li><p>映射配置文件：dao &#x2F; AccountDao.xml</p>
<pre><code class="xml">&lt;mapper namespace=&quot;dao.AccountDao&quot;&gt;
    &lt;update id=&quot;inMoney&quot;&gt;
        UPDATE account SET money = money + #&#123;money&#125; WHERE name = #&#123;name&#125;
    &lt;/update&gt;

    &lt;update id=&quot;outMoney&quot;&gt;
        UPDATE account SET money = money - #&#123;money&#125; WHERE name = #&#123;name&#125;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>jdbc.properties</p>
<pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://192.168.2.185:3306/spring_db
jdbc.username=root
jdbc.password=1234
</code></pre>
</li>
<li><p>核心配置文件：applicationContext.xml</p>
<pre><code class="xml">&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt;

&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;accountService&quot; class=&quot;service.impl.AccountServiceImpl&quot;&gt;
    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;
&lt;/bean&gt;

&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;domain&quot;/&gt;
&lt;/bean&gt;
&lt;!--扫描映射配置和Dao--&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="java">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;ap...xml&quot;);
AccountService accountService = (AccountService) ctx.getBean(&quot;accountService&quot;);
accountService.transfer(&quot;Jock1&quot;, &quot;Jock2&quot;, 100d);
</code></pre>
</li>
</ul>
<hr>
<h4 id="编程式-1"><a href="#编程式-1" class="headerlink" title="编程式"></a>编程式</h4><p>编程式事务就是代码显式的给出事务的开启和提交</p>
<ul>
<li><p>修改业务层实现提供转账操作：AccountServiceImpl</p>
<pre><code class="java">public void transfer(String outName,String inName,Double money)&#123;
    //1.创建事务管理器，
    DataSourceTransactionManager dstm = new DataSourceTransactionManager();
    //2.为事务管理器设置与数据层相同的数据源
    dstm.setDataSource(dataSource);
    //3.创建事务定义对象
    TransactionDefinition td = new DefaultTransactionDefinition();
    //4.创建事务状态对象，用于控制事务执行，【开启事务】
    TransactionStatus ts = dstm.getTransaction(td);
    accountDao.inMoney(inName,money);
    int i = 1/0;    //模拟业务层事务过程中出现错误
    accountDao.outMoney(outName,money);
    //5.提交事务
    dstm.commit(ts);
&#125;
</code></pre>
</li>
<li><p>配置 applicationContext.xml</p>
<pre><code class="xml">&lt;!--添加属性注入--&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;service.impl.AccountServiceImpl&quot;&gt;
    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="AOP改造"><a href="#AOP改造" class="headerlink" title="AOP改造"></a>AOP改造</h4><ul>
<li><p>将业务层的事务处理功能抽取出来制作成 AOP 通知，利用环绕通知运行期动态织入</p>
<pre><code class="java">public class TxAdvice &#123;
    private DataSource dataSource;
    public void setDataSource(DataSource dataSource) &#123;
        this.dataSource = dataSource;
    &#125;

    public Object tx(ProceedingJoinPoint pjp) throws Throwable &#123;
        //开启事务
        PlatformTransactionManager ptm = new DataSourceTransactionManager(dataSource);
        //事务定义
        TransactionDefinition td = new DefaultTransactionDefinition();
        //事务状态
        TransactionStatus ts =  ptm.getTransaction(td);
        //pjp.getArgs()标准写法，也可以不加，同样可以传递参数
        Object ret = pjp.proceed(pjp.getArgs());
        
        //提交事务
        ptm.commit(ts);

        return ret;
    &#125;
&#125;
</code></pre>
</li>
<li><p>配置 applicationContext.xml，要开启 AOP 空间</p>
<pre><code class="xml">&lt;!--修改bean的属性注入--&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;service.impl.AccountServiceImpl&quot;&gt;
    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;
&lt;/bean&gt;

&lt;!--配置AOP通知类，并注入dataSource--&gt;
&lt;bean id=&quot;txAdvice&quot; class=&quot;aop.TxAdvice&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;

&lt;!--使用环绕通知将通知类织入到原始业务对象执行过程中--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* *..transfer(..))&quot;/&gt;
    &lt;aop:aspect ref=&quot;txAdvice&quot;&gt;
        &lt;aop:around method=&quot;tx&quot; pointcut-ref=&quot;pt&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
<li><p>修改业务层实现提供转账操作：AccountServiceImpl</p>
<pre><code class="java">public class AccountServiceImpl implements AccountService &#123;
    private AccountDao accountDao;
    public void setAccountDao(AccountDao accountDao) &#123;
        this.accountDao = accountDao;
    &#125;
    @Override
    public void transfer(String outName,String inName,Double money)&#123;
        accountDao.inMoney(outName,money);
        //int i = 1 / 0;
        accountDao.outMoney(inName,money);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><h4 id="XML-2"><a href="#XML-2" class="headerlink" title="XML"></a>XML</h4><h5 id="tx使用"><a href="#tx使用" class="headerlink" title="tx使用"></a>tx使用</h5><p>删除 TxAdvice 通知类，开启 tx 命名空间，配置 applicationContext.xml</p>
<pre><code class="xml">&lt;!--配置平台事务管理器--&gt;
&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;

&lt;!--定义事务管理的通知类--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;
    &lt;!--定义控制的事务--&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;transfer&quot; read-only=&quot;false&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;!--使用aop:advisor在AOP配置中引用事务专属通知类，底层invoke调用--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* service.*Service.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<ul>
<li>aop:advice 与 aop:advisor 区别<ul>
<li><p>aop:advice 配置的通知类可以是普通 Java 对象，不实现接口，也不使用继承关系</p>
</li>
<li><p>aop:advisor 配置的通知类必须实现通知接口，底层 invoke 调用</p>
<ul>
<li><p>MethodBeforeAdvice</p>
</li>
<li><p>AfterReturningAdvice</p>
</li>
<li><p>ThrowsAdvice</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>pom.xml 文件引入依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
    &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<hr>
<h5 id="tx配置"><a href="#tx配置" class="headerlink" title="tx配置"></a>tx配置</h5><h6 id="advice"><a href="#advice" class="headerlink" title="advice"></a>advice</h6><p>标签：tx:advice，beans 的子标签</p>
<p>作用：专用于声明事务通知</p>
<p>格式：</p>
<pre><code class="xml">&lt;beans&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;
    &lt;/tx:advice&gt;
&lt;/beans&gt;
</code></pre>
<p>基本属性：</p>
<ul>
<li>id：用于配置 aop 时指定通知器的 id</li>
<li>transaction-manager：指定事务管理器 bean</li>
</ul>
<h6 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h6><p>类型：tx:attributes，tx:advice 的子标签</p>
<p>作用：定义通知属性</p>
<p>格式：</p>
<pre><code class="xml">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;
    &lt;tx:attributes&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<h6 id="method"><a href="#method" class="headerlink" title="method"></a>method</h6><p>标签：tx:method，tx:attribute 的子标签</p>
<p>作用：设置具体的事务属性</p>
<p>格式：</p>
<pre><code class="xml">&lt;tx:attributes&gt;
    &lt;!--标准格式--&gt;
    &lt;tx:method name=&quot;*&quot; read-only=&quot;false&quot;/&gt;
    &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;
    &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
&lt;/tx:attributes&gt;
&lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* service.*Service.*(..))&quot;/&gt;&lt;!--标准--&gt;
</code></pre>
<p>说明：通常事务属性会配置多个，包含 1 个读写的全事务属性，1 个只读的查询类事务属性</p>
<p>属性：</p>
<ul>
<li>name：待添加事务的方法名表达式（支持 * 通配符）</li>
<li>read-only：设置事务的读写属性，true 为只读，false 为读写</li>
<li>timeout：设置事务的超时时长，单位秒，-1 为无限长</li>
<li>isolation：设置事务的隔离界别，该隔离级设定是基于 Spring 的设定，非数据库端</li>
<li>no-rollback-for：设置事务中不回滚的异常，多个异常使用 <code>,</code> 分隔</li>
<li>rollback-for：设置事务中必回滚的异常，多个异常使用 <code>,</code> 分隔</li>
<li>propagation：设置事务的传播行为</li>
</ul>
<hr>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h5><h6 id="XML-3"><a href="#XML-3" class="headerlink" title="XML"></a>XML</h6><p>标签：tx:annotation-driven</p>
<p>归属：beans 标签</p>
<p>作用：开启事务注解驱动，并指定对应的事务管理器</p>
<p>范例：</p>
<pre><code class="xml">&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;
</code></pre>
<hr>
<h6 id="纯注解-2"><a href="#纯注解-2" class="headerlink" title="纯注解"></a>纯注解</h6><p>名称：@EnableTransactionManagement</p>
<p>类型：类注解，Spring 注解配置类上方</p>
<p>作用：开启注解驱动，等同 XML 格式中的注解驱动</p>
<p>范例：</p>
<pre><code class="java">@Configuration
@ComponentScan(&quot;com.seazean&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@Import(&#123;JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class&#125;)
@EnableTransactionManagement
public class SpringConfig &#123;
&#125;
</code></pre>
<pre><code class="java">public class TransactionManagerConfig &#123;
    @Bean                                                //自动装配
    public PlatformTransactionManager getTransactionManager(@Autowired DataSource dataSource)&#123;
        return new DataSourceTransactionManager(dataSource);
    &#125;
&#125;
</code></pre>
<hr>
<h5 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h5><p>名称：@Transactional</p>
<p>类型：方法注解，类注解，接口注解</p>
<p>作用：设置当前类&#x2F;接口中所有方法或具体方法开启事务，并指定相关事务属性</p>
<p>范例：</p>
<pre><code class="java">@Transactional(
    readOnly = false,
    timeout = -1,
    isolation = Isolation.DEFAULT,
    rollbackFor = &#123;ArithmeticException.class, IOException.class&#125;,
    noRollbackFor = &#123;&#125;,
    propagation = Propagation.REQUIRES_NEW
)
public void addAccount&#123;&#125; 
</code></pre>
<p>说明：</p>
<ul>
<li><p><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效</p>
</li>
<li><p>不推荐在接口上使用 <code>@Transactional</code> 注解</p>
<p>原因：在接口上使用注解，<strong>只有在使用基于接口的代理（JDK）时才会生效，因为注解是不能继承的</strong>，这就意味着如果正在使用基于类的代理（CGLIB）时，那么事务的设置将不能被基于类的代理所识别</p>
</li>
<li><p>正确的设置 <code>@Transactional</code> 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败</p>
</li>
<li><p>默认情况下，事务只有遇到运行期异常 和 Error 会导致事务回滚，但是在遇到检查型（Checked）异常时不会回滚</p>
<ul>
<li>继承自 RuntimeException 或 error 的是非检查型异常，比如空指针和索引越界，而继承自 Exception 的则是检查型异常，比如 IOException、ClassNotFoundException，RuntimeException 本身继承 Exception</li>
<li>非检查型类异常可以不用捕获，而检查型异常则必须用 try 语句块把异常交给上级方法，这样事务才能有效</li>
</ul>
</li>
</ul>
<p><strong>事务不生效的问题</strong></p>
<ul>
<li><p>情况 1：确认创建的 MySQL 数据库表引擎是 InnoDB，MyISAM 不支持事务</p>
</li>
<li><p>情况 2：注解到 protected，private 方法上事务不生效，但不会报错</p>
<p>原因：理论上而言，不用 public 修饰，也可以用 aop 实现事务的功能，但是方法私有化让其他业务无法调用</p>
<p>AopUtils.canApply：<code>methodMatcher.matches(method, targetClass) --true--&gt; return true</code><br><code>TransactionAttributeSourcePointcut.matches()</code> ，AbstractFallbackTransactionAttributeSource 中 getTransactionAttribute 方法调用了其本身的 computeTransactionAttribute 方法，当加了事务注解的方法不是 public 时，该方法直接返回 null，所以造成增强不匹配</p>
<pre><code class="java">private TransactionAttribute computeTransactionAttribute(Method method, Class&lt;?&gt; targetClass) &#123;
    // Don&#39;t allow no-public methods as required.
    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;
        return null;
    &#125;
&#125;
</code></pre>
</li>
<li><p>情况 3：注解所在的类没有被加载成 Bean</p>
</li>
<li><p>情况 4：在业务层捕捉异常后未向上抛出，事务不生效</p>
<p>原因：在业务层捕捉并处理了异常（try..catch）等于把异常处理掉了，Spring 就不知道这里有错，也不会主动去回滚数据，推荐做法是在业务层统一抛出异常，然后在控制层统一处理</p>
</li>
<li><p>情况 5：遇到检测异常时，也无法回滚</p>
<p>原因：Spring 的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。想针对检测异常进行事务回滚，可以在 @Transactional 注解里使用 rollbackFor 属性明确指定异常</p>
</li>
<li><p>情况 6：Spring 的事务传播策略在<strong>内部方法</strong>调用时将不起作用，在一个 Service 内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务，事务注解要加到调用方法上才生效</p>
<p>原因：Spring 的事务都是使用 AOP 代理的模式，动态代理 invoke 后会调用原始对象，而原始对象在去调用方法时是不会触发拦截器，就是<strong>一个方法调用本对象的另一个方法</strong>，所以事务也就无法生效</p>
<pre><code class="java">@Transactional
public int add()&#123;
    update();
&#125;
//注解添加在update方法上无效，需要添加到add()方法上
public int update()&#123;&#125;
</code></pre>
</li>
<li><p>情况 7：注解在接口上，代理对象是 CGLIB</p>
</li>
</ul>
<hr>
<h5 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h5><ul>
<li><p>Dao 层</p>
<pre><code class="java">public interface AccountDao &#123;
    @Update(&quot;update account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)
    void inMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);

    @Update(&quot;update account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)
    void outMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);
&#125;
</code></pre>
</li>
<li><p>业务层</p>
<pre><code class="java">public interface AccountService &#123;
    //对当前方法添加事务，该配置将替换接口的配置
    @Transactional(
        readOnly = false,
        timeout = -1,
        isolation = Isolation.DEFAULT,
        rollbackFor = &#123;&#125;,//java.lang.ArithmeticException.class, IOException.class
        noRollbackFor = &#123;&#125;,
        propagation = Propagation.REQUIRED
        )
    public void transfer(String outName, String inName, Double money);
&#125;
</code></pre>
<pre><code class="java">public class AccountServiceImpl implements AccountService &#123;
    @Autowired
    private AccountDao accountDao;
    public void transfer(String outName, String inName, Double money) &#123;
        accountDao.inMoney(outName,money);
        //int i = 1/0;
        accountDao.outMoney(inName,money);
    &#125;
&#125;
</code></pre>
</li>
<li><p>添加文件 Spring.config、Mybatis.config、JDBCConfig (参考ioc_Mybatis)、TransactionManagerConfig</p>
<pre><code class="java">@Configuration
@ComponentScan(&#123;&quot;&quot;,&quot;&quot;,&quot;&quot;&#125;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@Import(&#123;JDBCConfig.class,MyBatisConfig.class&#125;)
@EnableTransactionManagement
public class SpringConfig &#123;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h3><p>Spring 模板对象：TransactionTemplate、JdbcTemplate、RedisTemplate、RabbitTemplate、JmsTemplate、HibernateTemplate、RestTemplate</p>
<ul>
<li><p>JdbcTemplate：提供标准的 sql 语句操作API</p>
</li>
<li><p>NamedParameterJdbcTemplate：提供标准的具名 sql 语句操作API</p>
</li>
<li><p>RedisTemplate：</p>
<pre><code class="java">public void changeMoney(Integer id, Double money) &#123;
    redisTemplate.opsForValue().set(&quot;account:id:&quot;+id,money);
&#125;
public Double findMondyById(Integer id) &#123;
    Object money = redisTemplate.opsForValue().get(&quot;account:id:&quot; + id);
    return new Double(money.toString());
&#125;
</code></pre>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-RedisTemplate.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-RedisTemplate.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<hr>
</div><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><div class="story post-story"><h3 id="XML-4"><a href="#XML-4" class="headerlink" title="XML"></a>XML</h3><p>三大对象：</p>
<ul>
<li><p><strong>BeanDefinition</strong>：是 Spring 中极其重要的一个概念，存储了 bean 对象的所有特征信息，如是否单例、是否懒加载、factoryBeanName 等，和 bean 的关系就是类与对象的关系，一个不同的 bean 对应一个 BeanDefinition</p>
</li>
<li><p><strong>BeanDefinationRegistry</strong>：存放 BeanDefination 的容器，是一种键值对的形式，通过特定的 Bean 定义的 id，映射到相应的 BeanDefination，<strong>BeanFactory 的实现类同样继承 BeanDefinationRegistry 接口</strong>，拥有保存 BD 的能力</p>
</li>
<li><p><strong>BeanDefinitionReader</strong>：读取配置文件，<strong>XML 用 Dom4j 解析</strong>，<strong>注解用 IO 流加载解析</strong></p>
</li>
</ul>
<p>程序：</p>
<pre><code class="java">BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));
UserService userService1 = (UserService)bf.getBean(&quot;userService&quot;);
</code></pre>
<p>源码解析：</p>
<pre><code class="java">public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) &#123;
    super(parentBeanFactory);
    this.reader.loadBeanDefinitions(resource);
&#125;
public int loadBeanDefinitions(Resource resource) &#123;
    //将 resource 包装成带编码格式的 EncodedResource
    //EncodedResource 中 getReader()方法，调用java.io包下的 转换流 创建指定编码的输入流对象
    return loadBeanDefinitions(new EncodedResource(resource));
&#125;
</code></pre>
<ul>
<li><p><code>XmlBeanDefinitionReader.loadBeanDefinitions()</code>：<strong>把 Resource 解析成 BeanDefinition 对象</strong></p>
<ul>
<li><code>currentResources = this.resourcesCurrentlyBeingLoaded.get()</code>：拿到当前线程已经加载过的所有 EncodedResoure 资源，用 ThreadLocal 保证线程安全</li>
<li><code>if (currentResources == null)</code>：判断 currentResources 是否为空，为空则进行初始化</li>
<li><code>if (!currentResources.add(encodedResource))</code>：如果已经加载过该资源会报错，防止重复加载</li>
<li><code>inputSource = new InputSource(inputStream)</code>：资源对象包装成 InputSource，InputSource 是 <strong>SAX</strong> 中的资源对象，用来进行 XML 文件的解析</li>
<li><code>return doLoadBeanDefinitions()</code>：<strong>加载返回</strong></li>
<li><code>currentResources.remove(encodedResource)</code>：加载完成移除当前 encodedResource</li>
<li><code>resourcesCurrentlyBeingLoaded.remove()</code>：ThreadLocal 为空时移除元素，防止内存泄露</li>
</ul>
</li>
<li><p><code>XmlBeanDefinitionReader.doLoadBeanDefinitions(inputSource, resource)</code>：真正的加载函数</p>
<p><code>Document doc = doLoadDocument(inputSource, resource)</code>：转换成有<strong>层次结构</strong>的 Document 对象</p>
<ul>
<li><p><code>getEntityResolver()</code><strong>：获取用来解析 DTD、XSD 约束的解析器</strong></p>
</li>
<li><p><code>getValidationModeForResource(resource)</code>：获取验证模式</p>
</li>
</ul>
<p><code>int count = registerBeanDefinitions(doc, resource)</code>：<strong>将 Document 解析成 BD 对象，注册（添加）到  BeanDefinationRegistry 中</strong>，返回新注册的数量</p>
<ul>
<li><code>createBeanDefinitionDocumentReader()</code>：创建 DefaultBeanDefinitionDocumentReader 对象</li>
<li><code>getRegistry().getBeanDefinitionCount()</code>：获取解析前 BeanDefinationRegistry 中的 bd 数量</li>
<li><code>registerBeanDefinitions(doc, readerContext)</code>：注册 BD<ul>
<li><code>this.readerContext = readerContext</code>：保存上下文对象</li>
<li><code>doRegisterBeanDefinitions(doc.getDocumentElement())</code>：真正的注册 BD 函数<ul>
<li><code>doc.getDocumentElement()</code>：拿出顶层标签 <beans></beans></li>
</ul>
</li>
</ul>
</li>
<li><code>return getRegistry().getBeanDefinitionCount() - countBefore</code>：返回新加入的数量</li>
</ul>
</li>
<li><p><code>DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions()</code>：注册 BD 到 BR</p>
<ul>
<li><code>createDelegate(getReaderContext(), root, parent)</code>：beans 是标签的解析器对象</li>
<li><code>delegate.isDefaultNamespace(root)</code>：判断 beans 标签是否是默认的属性</li>
<li><code>root.getAttribute(PROFILE_ATTRIBUTE)</code>：解析 profile 属性</li>
<li><code>preProcessXml(root)</code>：解析前置处理，自定义实现</li>
<li><code>parseBeanDefinitions(root, this.delegate)</code>：<strong>解析 beans 标签中的子标签</strong><ul>
<li><code>parseDefaultElement(ele, delegate)</code>：如果是默认的标签，用该方法解析子标签<ul>
<li>判断标签名称，进行相应的解析</li>
<li><code>processBeanDefinition(ele, delegate)</code>：</li>
</ul>
</li>
<li><code>delegate.parseCustomElement(ele)</code>：解析自定义的标签</li>
</ul>
</li>
<li><code>postProcessXml(root)</code>：解析后置处理</li>
</ul>
</li>
<li><p><code>DefaultBeanDefinitionDocumentReader.processBeanDefinition()</code>：<strong>解析 bean 标签并注册到注册中心</strong></p>
<ul>
<li><p><code>delegate.parseBeanDefinitionElement(ele)</code>：解析 bean 标签封装为 BeanDefinitionHolder</p>
<ul>
<li><p><code>if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty())</code>：条件一成立说明 name 没有值，条件二成立说明别名有值</p>
<p><code>beanName = aliases.remove(0)</code>：拿别名列表的第一个元素当作 beanName</p>
</li>
<li><p><code>parseBeanDefinitionElement(ele, beanName, containingBean)</code>：<strong>解析 bean 标签</strong></p>
<ul>
<li><code>parseState.push(new BeanEntry(beanName))</code>：当前解析器的状态设置为 BeanEntry</li>
<li>class 和 parent 属性存在一个，parent 是作为父标签为了被继承</li>
<li><code>createBeanDefinition(className, parent)</code>：设置了class 的 GenericBeanDefinition对象</li>
<li><code>parseBeanDefinitionAttributes()</code>：解析 bean 标签的属性</li>
<li>接下来解析子标签</li>
</ul>
</li>
<li><p><code>beanName = this.readerContext.generateBeanName(beanDefinition)</code>：生成 className + # + 序号的名称赋值给 beanName </p>
</li>
<li><p><code>return new BeanDefinitionHolder(beanDefinition, beanName, aliases)</code>：<strong>包装成 BeanDefinitionHolder</strong></p>
</li>
</ul>
</li>
<li><p><code>registerBeanDefinition(bdHolder, getReaderContext().getRegistry())</code>：<strong>注册到容器</strong></p>
<ul>
<li><code>beanName = definitionHolder.getBeanName()</code>：获取beanName</li>
<li><code>this.beanDefinitionMap.put(beanName, beanDefinition)</code>：添加到注册中心</li>
</ul>
</li>
<li><p><code>getReaderContext().fireComponentRegistered()</code>：发送注册完成事件</p>
</li>
</ul>
</li>
</ul>
<p><strong>说明：源码部分的笔记不一定适合所有人阅读，作者采用流水线式去解析重要的代码，解析的结构类似于树状，如果视觉疲劳可以去网上参考一些博客和流程图学习源码。</strong></p>
<hr>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h4><p>Spring IOC 容器是 ApplicationContext 或者 BeanFactory，使用多个 Map 集合保存单实例 Bean，环境信息等资源，不同层级有不同的容器，比如整合 SpringMVC 的父子容器（先看 Bean 部分的源码解析再回看容器）</p>
<p>ClassPathXmlApplicationContext 与 AnnotationConfigApplicationContext 差不多：</p>
<pre><code class="java">public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) &#123;
    this();
    register(annotatedClasses);// 解析配置类，封装成一个 BeanDefinitionHolder，并注册到容器
    refresh();// 加载刷新容器中的 Bean
&#125;
</code></pre>
<pre><code class="java">public AnnotationConfigApplicationContext() &#123;
    // 注册 Spring 的注解解析器到容器
    this.reader = new AnnotatedBeanDefinitionReader(this);
    // 实例化路径扫描器，用于对指定的包目录进行扫描查找 bean 对象
    this.scanner = new ClassPathBeanDefinitionScanner(this);
&#125;
</code></pre>
<p>AbstractApplicationContext.refresh()：</p>
<ul>
<li><p>prepareRefresh()：刷新前的<strong>预处理</strong></p>
<ul>
<li><code>this.startupDate = System.currentTimeMillis()</code>：设置容器的启动时间</li>
<li><code>initPropertySources()</code>：初始化一些属性设置，可以自定义个性化的属性设置方法</li>
<li><code>getEnvironment().validateRequiredProperties()</code>：检查环境变量</li>
<li><code>earlyApplicationEvents= new LinkedHashSet&lt;ApplicationEvent&gt;()</code>：保存容器中早期的事件</li>
</ul>
</li>
<li><p>obtainFreshBeanFactory()：获取一个<strong>全新的 BeanFactory 接口实例</strong>，如果容器中存在工厂实例直接销毁</p>
<p><code>refreshBeanFactory()</code>：创建 BeanFactory，设置序列化 ID、读取 BeanDefinition 并加载到工厂</p>
<ul>
<li><code>if (hasBeanFactory())</code>：applicationContext 内部拥有一个 beanFactory 实例，需要将该实例完全释放销毁</li>
<li><code>destroyBeans()</code>：销毁原 beanFactory 实例，将 beanFactory 内部维护的单实例 bean 全部清掉，如果哪个 bean 实现了 Disposablejie接口，还会进行 bean distroy 方法的调用处理<ul>
<li><code>this.singletonsCurrentlyInDestruction = true</code>：设置当前 beanFactory 状态为销毁状态</li>
<li><code>String[] disposableBeanNames</code>：获取销毁集合中的 bean，如果当前 bean 有<strong>析构函数</strong>就会在销毁集合</li>
<li><code>destroySingleton(disposableBeanNames[i])</code>：遍历所有的 disposableBeans，执行销毁方法<ul>
<li><code>removeSingleton(beanName)</code>：清除三级缓存和 registeredSingletons 中的当前 beanName 的数据</li>
<li><code>this.disposableBeans.remove(beanName)</code>：从销毁集合中清除，每个 bean 只能 destroy 一次</li>
<li><code>destroyBean(beanName, disposableBean)</code>：销毁 bean<ul>
<li>dependentBeanMap 记录了依赖当前 bean 的其他 bean 信息，因为依赖的对象要被回收了，所以依赖当前 bean 的其他对象都要执行 destroySingleton，遍历 dependentBeanMap 执行销毁</li>
<li><code>bean.destroy()</code>：解决完成依赖后，执行 DisposableBean 的 destroy 方法</li>
<li><code> this.dependenciesForBeanMap.remove(beanName)</code>：保存当前 bean 依赖了谁，直接清除</li>
</ul>
</li>
</ul>
</li>
<li>进行一些集合和缓存的清理工作</li>
</ul>
</li>
<li><code>closeBeanFactory()</code>：将容器内部的 beanFactory 设置为空，重新创建</li>
<li><code>beanFactory = createBeanFactory()</code>：创建新的 DefaultListableBeanFactory 对象</li>
<li><code>beanFactory.setSerializationId(getId())</code>：进行 ID 的设置，可以根据 ID 获取 BeanFactory 对象</li>
<li><code>customizeBeanFactory(beanFactory)</code>：设置是否允许覆盖和循环引用</li>
<li><code>loadBeanDefinitions(beanFactory)</code>：<strong>加载 BeanDefinition 信息，注册 BD注册到 BeanFactory 中</strong></li>
<li><code>this.beanFactory = beanFactory</code>：把 beanFactory 填充至容器中</li>
</ul>
<p><code>getBeanFactory()</code>：返回创建的 DefaultListableBeanFactory 对象，该对象继承 BeanDefinitionRegistry</p>
</li>
<li><p>prepareBeanFactory(beanFactory)：<strong>BeanFactory 的预准备</strong>工作，向容器中添加一些组件</p>
<ul>
<li><code>setBeanClassLoader(getClassLoader())</code>：给当前 bf 设置一个<strong>类加载器</strong>，加载 bd 的 class 信息</li>
<li><code>setBeanExpressionResolver()</code>：设置 EL 表达式解析器</li>
<li><code>addPropertyEditorRegistrar</code>：添加一个属性编辑器，解决属性注入时的格式转换</li>
<li><code>addBeanPostProcessor()</code>：添加后处理器，主要用于向 bean 内部注入一些框架级别的实例</li>
<li><code>ignoreDependencyInterface()</code>：设置忽略自动装配的接口，bean 内部的这些类型的字段   不参与依赖注入</li>
<li><code>registerResolvableDependency()</code>：注册一些类型依赖关系</li>
<li><code>addBeanPostProcessor()</code>：将配置的监听者注册到容器中，当前 bean 实现 ApplicationListener 接口就是监听器事件</li>
<li><code>beanFactory.registerSingleton()</code>：添加一些系统信息</li>
</ul>
</li>
<li><p>postProcessBeanFactory(beanFactory)：BeanFactory 准备工作完成后进行的后置处理工作，扩展方法</p>
</li>
<li><p>invokeBeanFactoryPostProcessors(beanFactory)：<strong>执行 BeanFactoryPostProcessor 的方法</strong></p>
<ul>
<li><p><code>processedBeans = new HashSet&lt;&gt;()</code>：存储已经执行过的 BeanFactoryPostProcessor 的 beanName</p>
</li>
<li><p><code>if (beanFactory instanceof BeanDefinitionRegistry)</code>：<strong>当前 BeanFactory 是 bd 的注册中心，bd 全部注册到 bf</strong></p>
</li>
<li><p><code>for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors)</code>：遍历所有的 bf 后置处理器</p>
</li>
<li><p><code>if (postProcessor instanceof BeanDefinitionRegistryPostProcessor)</code>：是 Registry 类的后置处理器</p>
<p><code>registryProcessor.postProcessBeanDefinitionRegistry(registry)</code>：向 bf 中注册一些 bd</p>
<p><code>registryProcessors.add(registryProcessor)</code>：添加到 BeanDefinitionRegistryPostProcessor 集合</p>
</li>
<li><p><code>regularPostProcessors.add(postProcessor)</code>：添加到 BeanFactoryPostProcessor 集合</p>
</li>
<li><p>逻辑到这里已经获取到所有 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor  接口类型的后置处理器</p>
</li>
<li><p><strong>首先回调 BeanDefinitionRegistryPostProcessor 类的后置处理方法 postProcessBeanDefinitionRegistry()</strong></p>
<ul>
<li><p>获取实现了 PriorityOrdered（主排序接口）接口的 bdrpp，进行 sort 排序，然后全部执行并放入已经处理过的集合</p>
</li>
<li><p>再执行实现了 Ordered（次排序接口）接口的 bdrpp</p>
</li>
<li><p>最后执行没有实现任何优先级或者是顺序接口 bdrpp，<code>boolean reiterate = true</code> 控制 while 是否需要再次循环，循环内是查找并执行 bdrpp 后处理器的 registry 相关的接口方法，接口方法执行以后会向 bf 内注册 bd，注册的 bd 也有可能是 bdrpp 类型，所以需要该变量控制循环</p>
</li>
<li><p><code>processedBeans.add(ppName)</code>：已经执行过的后置处理器存储到该集合中，防止重复执行</p>
</li>
<li><p><code> invokeBeanFactoryPostProcessors()</code>：bdrpp 继承了 BeanFactoryPostProcessor，有 postProcessBeanFactory 方法</p>
</li>
</ul>
</li>
<li><p><strong>执行普通 BeanFactoryPostProcessor 的相关 postProcessBeanFactory 方法，按照主次无次序执行</strong></p>
<ul>
<li><code>if (processedBeans.contains(ppName))</code>：会过滤掉已经执行过的后置处理器</li>
</ul>
</li>
<li><p><code>beanFactory.clearMetadataCache()</code>：清除缓存中合并的 Bean 定义，因为后置处理器可能更改了元数据</p>
</li>
</ul>
</li>
</ul>
<p><strong>以上是 BeanFactory 的创建及预准备工作，接下来进入 Bean 的流程</strong></p>
<ul>
<li><p>registerBeanPostProcessors(beanFactory)：<strong>注册 Bean 的后置处理器</strong>，为了干预 Spring 初始化 bean 的流程，这里仅仅是向容器中<strong>注入而非使用</strong></p>
<ul>
<li><p><code>beanFactory.getBeanNamesForType(BeanPostProcessor.class)</code>：<strong>获取配置中实现了 BeanPostProcessor 接口类型</strong></p>
</li>
<li><p><code>int beanProcessorTargetCount</code>：后置处理器的数量，已经注册的 + 未注册的 + 即将要添加的一个</p>
</li>
<li><p><code>beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker())</code>：添加一个检查器</p>
<p><code>BeanPostProcessorChecker.postProcessAfterInitialization()</code>：初始化后的后处理器方法</p>
<ul>
<li><code>!(bean instanceof BeanPostProcessor) </code>：当前 bean 类型是普通 bean，不是后置处理器</li>
<li><code>!isInfrastructureBean(beanName)</code>：成立说明当前 beanName 是用户级别的 bean  不是 Spring 框架的</li>
<li><code>this.beanFactory.getBeanPostProcessorCount() &lt; this.beanPostProcessorTargetCount</code>：BeanFactory 上面注册后处理器数量 &lt; 后处理器数量，说明后处理框架尚未初始化完成</li>
</ul>
</li>
<li><p><code>for (String ppName : postProcessorNames)</code>：遍历 PostProcessor 集合，<strong>根据实现不同的顺序接口添加到不同集合</strong></p>
</li>
<li><p><code>sortPostProcessors(priorityOrderedPostProcessors, beanFactory)</code>：实现 PriorityOrdered 接口的后处理器排序</p>
<p><code>registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors)</code>：<strong>注册到 beanFactory 中</strong></p>
</li>
<li><p>接着排序注册实现 Ordered 接口的后置处理器，然后注册普通的（ 没有实现任何优先级接口）后置处理器</p>
</li>
<li><p>最后排序 MergedBeanDefinitionPostProcessor 类型的处理器，根据实现的排序接口，排序完注册到 beanFactory 中</p>
</li>
<li><p><code>beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext))</code>：重新注册 ApplicationListenerDetector 后处理器，用于在 Bean 创建完成后检查是否属于 ApplicationListener 类型，如果是就把 Bean 放到<strong>监听器容器</strong>中保存起来</p>
</li>
</ul>
</li>
<li><p>initMessageSource()：初始化 MessageSource 组件，主要用于做国际化功能，消息绑定与消息解析</p>
<ul>
<li><code>if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME))</code>：容器是否含有名称为 messageSource 的 bean</li>
<li><code>beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class)</code>：如果有证明用户自定义了该类型的 bean，获取后直接赋值给 this.messageSource</li>
<li><code>dms = new DelegatingMessageSource()</code>：容器中没有就新建一个赋值</li>
</ul>
</li>
<li><p>initApplicationEventMulticaster()：<strong>初始化事件传播器</strong>，在注册监听器时会用到</p>
<ul>
<li><code>if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME))</code>：<strong>条件成立说明用户自定义了事件传播器</strong>，可以实现 ApplicationEventMulticaster 接口编写自己的事件传播器，通过 bean 的方式提供给 Spring</li>
<li>如果有就直接从容器中获取；如果没有则创建一个 SimpleApplicationEventMulticaster 注册</li>
</ul>
</li>
<li><p>onRefresh()：留给用户去实现，可以硬编码提供一些组件，比如提供一些监听器</p>
</li>
<li><p>registerListeners()：注册通过配置提供的 Listener，这些<strong>监听器</strong>最终注册到 ApplicationEventMulticaster 内</p>
<ul>
<li><p><code>for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) </code>：注册编码实现的监听器</p>
</li>
<li><p><code>getBeanNamesForType(ApplicationListener.class, true, false)</code>：注册通过配置提供的 Listener</p>
</li>
<li><p><code>multicastEvent(earlyEvent)</code>：<strong>发布前面步骤产生的事件 applicationEvents</strong></p>
<p><code>Executor executor = getTaskExecutor()</code>：获取线程池，有线程池就异步执行，没有就同步执行</p>
</li>
</ul>
</li>
<li><p>finishBeanFactoryInitialization()：<strong>实例化非懒加载状态的单实例</strong></p>
<ul>
<li><p><code>beanFactory.freezeConfiguration()</code>：<strong>冻结配置信息</strong>，就是冻结 BD 信息，冻结后无法再向 bf 内注册 bd</p>
</li>
<li><p><code>beanFactory.preInstantiateSingletons()</code>：实例化 non-lazy-init singletons</p>
<ul>
<li><p><code>for (String beanName : beanNames)</code>：遍历容器内所有的 beanDefinitionNames</p>
</li>
<li><p><code>getMergedLocalBeanDefinition(beanName)</code>：获取与父类合并后的对象（Bean → 获取流程部分详解此函数）</p>
</li>
<li><p><code>if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit())</code>：BD 对应的 Class 满足非抽象、单实例，非懒加载，需要预先实例化</p>
<p><code>if (isFactoryBean(beanName))</code>：BD 对应的 Class 是 factoryBean 对象</p>
<ul>
<li><code>getBean(FACTORY_BEAN_PREFIX + beanName)</code>：获取工厂 FactoryBean 实例本身</li>
<li><code>isEagerInit</code>：控制 FactoryBean 内部管理的 Bean 是否也初始化</li>
<li><code>getBean(beanName)</code>：<strong>初始化 Bean，获取 Bean 详解此函数</strong></li>
</ul>
<p><code>getBean(beanName)</code>：不是工厂 bean 直接获取</p>
</li>
<li><p><code>for (String beanName : beanNames)</code>：检查所有的 Bean 是否实现 SmartInitializingSingleton 接口，实现了就执行 afterSingletonsInstantiated()，进行一些创建后的操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>finishRefresh()</code>：完成刷新后做的一些事情，主要是启动生命周期</p>
<ul>
<li><code>clearResourceCaches()</code>：清空上下文缓存</li>
<li><code>initLifecycleProcessor()</code>：<strong>初始化和生命周期有关的后置处理器</strong>，容器的生命周期<ul>
<li><code>if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME))</code>：成立说明自定义了生命周期处理器</li>
<li><code>defaultProcessor = new DefaultLifecycleProcessor()</code>：Spring 默认提供的生命周期处理器</li>
<li><code> beanFactory.registerSingleton()</code>：将生命周期处理器注册到 bf 的一级缓存和注册单例集合中</li>
</ul>
</li>
<li><code>getLifecycleProcessor().onRefresh()</code>：获取该**生命周期后置处理器回调 onRefresh()**，调用 <code>startBeans(true)</code><ul>
<li><code>lifecycleBeans = getLifecycleBeans()</code>：获取到所有实现了 Lifecycle 接口的对象包装到 Map 内，key 是beanName， value 是 Lifecycle 对象</li>
<li><code>int phase = getPhase(bean)</code>：获取当前 Lifecycle 的 phase 值，当前生命周期对象可能依赖其他生命周期对象的执行结果，所以需要 phase 决定执行顺序，数值越低的优先执行</li>
<li><code>LifecycleGroup group = phases.get(phase)</code>：把 phsae 相同的 Lifecycle 存入 LifecycleGroup</li>
<li><code>if (group == null)</code>：group 为空则创建，初始情况下是空的</li>
<li><code>group.add(beanName, bean)</code>：将当前 Lifecycle 添加到当前 phase 值一样的 group 内</li>
<li><code>Collections.sort(keys)</code>：<strong>从小到大排序，按优先级启动</strong></li>
<li><code>phases.get(key).start()</code>：遍历所有的 Lifecycle 对象开始启动</li>
<li><code>doStart(this.lifecycleBeans, member.name, this.autoStartupOnly)</code>：底层调用该方法启动<ul>
<li><code>bean = lifecycleBeans.remove(beanName)</code>： 确保 Lifecycle 只被启动一次，在一个分组内被启动了在其他分组内就看不到 Lifecycle 了</li>
<li><code>dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName)</code>：获取当前即将被启动的 Lifecycle 所依赖的其他 beanName，需要<strong>先启动所依赖的 bean</strong>，才能启动自身</li>
<li><code>if ()</code>：传入的参数 autoStartupOnly 为 true 表示启动 isAutoStartUp 为 true 的 SmartLifecycle 对象，不会启动普通的生命周期的对象；false 代表全部启动</li>
<li>bean.start()：<strong>调用启动方法</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>publishEvent(new ContextRefreshedEvent(this))</code>：<strong>发布容器刷新完成事件</strong></li>
<li><code>liveBeansView.registerApplicationContext(this)</code>：暴露 Mbean</li>
</ul>
</li>
</ul>
<p>补充生命周期 stop() 方法的调用</p>
<ul>
<li><p>DefaultLifecycleProcessor.stop()：调用 DefaultLifecycleProcessor.stopBeans()</p>
<ul>
<li><p>获取到所有实现了 Lifecycle 接口的对象并按 phase 数值分组的</p>
</li>
<li><p><code>keys.sort(Collections.reverseOrder())</code>：按 phase 降序排序 Lifecycle 接口，最先启动的最晚关闭（责任链？）</p>
</li>
<li><p><code>phases.get(key).stop()</code>：遍历所有的 Lifecycle 对象开始停止</p>
<ul>
<li><p><code>latch = new CountDownLatch(this.smartMemberCount)</code>：创建 CountDownLatch，设置 latch 内部的值为当前分组内的  smartMemberCount 的数量</p>
</li>
<li><p><code>countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet&lt;&gt;())</code>：保存当前正在处理关闭的smartLifecycle 的 BeanName</p>
</li>
<li><p><code>for (LifecycleGroupMember member : this.members)</code>：处理本分组内需要关闭的 Lifecycle</p>
<p><code>doStop(this.lifecycleBeans, member.name, latch, countDownBeanNames)</code>：真正的停止方法</p>
<ul>
<li><p><code>getBeanFactory().getDependentBeans(beanName)</code>：<strong>获取依赖当前 Lifecycle 的其他对象的 beanName</strong>，因为当前的 Lifecycle 即将要关闭了，所有的依赖了当前 Lifecycle 的 bean 也要关闭</p>
</li>
<li><p><code>countDownBeanNames.add(beanName)</code>：将当前 SmartLifecycle beanName 添加到 countDownBeanNames 集合内，该集合表示正在关闭的 SmartLifecycle</p>
</li>
<li><p><code>bean.stop()</code>：调用停止的方法</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="获取Bean-1"><a href="#获取Bean-1" class="headerlink" title="获取Bean"></a>获取Bean</h4><p>单实例：在容器启动时创建对象</p>
<p>多实例：在每次获取的时候创建对象</p>
<p>获取流程：<strong>获取 Bean 时先从单例池获取，如果没有则进行第二次获取，并带上工厂类去创建并添加至单例池</strong></p>
<p>Java 启动 Spring 代码：</p>
<pre><code class="java">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
UserService userService = (UserService) context.getBean(&quot;userService&quot;);
</code></pre>
<p>AbstractBeanFactory.doGetBean()：获取 Bean，context.getBean() 追踪到此</p>
<ul>
<li><p><code>beanName = transformedBeanName(name)</code>：name 可能是一个别名，重定向出来真实 beanName；也可能是一个 &amp; 开头的 name，说明要获取的 bean 实例对象，是一个 FactoryBean 对象（IOC 原理 → 核心类）</p>
<ul>
<li><code>BeanFactoryUtils.transformedBeanName(name)</code>：判断是哪种 name，返回截取 &amp; 以后的 name 并放入缓存<ul>
<li><code>transformedBeanNameCache.computeIfAbsent</code>：缓存是并发安全集合，key &#x3D;&#x3D; null || value &#x3D;&#x3D; null 时 put 成功 </li>
<li>do while 循环一直去除 &amp; 直到不再含有 &amp;</li>
</ul>
</li>
<li><code>canonicalName(name)</code>：aliasMap 保存别名信息，其中的 do while 逻辑是迭代查找，比如 A 别名叫做 B，但是 B 又有别名叫 C， aliasMap 为 {“C”:”B”, “B”:”A”}，get(C) 最后返回的是  A</li>
</ul>
</li>
<li><p><code>DefaultSingletonBeanRegistry.getSingleton()</code>：<strong>第一次获取从缓存池获取</strong>（循环依赖详解此代码）</p>
<ul>
<li>缓存中有数据进行 getObjectForBeanInstance() 获取可使用的 Bean（本节结束部分详解此函数）</li>
<li>缓存中没有数据进行下面的逻辑进行创建</li>
</ul>
</li>
<li><p><code>if(isPrototypeCurrentlyInCreation(beanName))</code>：检查 bean 是否在原型（Prototype）正在被创建的集合中，如果是就报错，说明产生了循环依赖，<strong>原型模式解决不了循环依赖</strong></p>
<p>原因：先加载 A，把 A 加入集合，A 依赖 B 去加载 B，B 又依赖 A，去加载 A，发现 A 在正在创建集合中，产生循环依赖</p>
</li>
<li><p><code>markBeanAsCreated(beanName)</code>：把 bean 标记为已经创建，<strong>防止其他线程重新创建 Bean</strong></p>
</li>
<li><p><code>mbd = getMergedLocalBeanDefinition(beanName)</code>：<strong>获取合并父 BD 后的 BD 对象</strong>，BD 是直接继承的，合并后的 BD 信息是包含父类的 BD 信息</p>
<ul>
<li><p><code>this.mergedBeanDefinitions.get(beanName)</code>：从缓存中获取</p>
</li>
<li><p><code>if(bd.getParentName()==null)</code>：beanName 对应 BD 没有父 BD 就不用处理继承，封装为 RootBeanDefinition 返回</p>
</li>
<li><p><code>parentBeanName = transformedBeanName(bd.getParentName())</code>：处理父 BD 的 name 信息</p>
</li>
<li><p><code>if(!beanName.equals(parentBeanName))</code>：一般情况父子 BD 的名称不同</p>
<p><code>pbd = getMergedBeanDefinition(parentBeanName)</code>：递归调用，最终返回父 BD 的父 BD 信息</p>
</li>
<li><p><code>mbd = new RootBeanDefinition(pbd)</code>：按照父 BD 信息创建 RootBeanDefinition 对象</p>
</li>
<li><p><code>mbd.overrideFrom(bd)</code>：<strong>子 BD 信息覆盖 mbd</strong>，因为是要以子 BD 为基准，不存在的才去父 BD 寻找（<strong>类似 Java 继承</strong>）</p>
</li>
<li><p><code>this.mergedBeanDefinitions.put(beanName, mbd)</code>：放入缓存</p>
</li>
</ul>
</li>
<li><p><code>checkMergedBeanDefinition()</code>：判断当前 BD 是否为<strong>抽象 BD</strong>，抽象 BD 不能创建实例，只能作为父 BD 被继承</p>
</li>
<li><p><code>mbd.getDependsOn()</code>：获取 bean 标签 depends-on</p>
</li>
<li><p><code>if(dependsOn != null)</code>：<strong>遍历所有的依赖加载，解决不了循环依赖</strong></p>
<p><code>isDependent(beanName, dep)</code>：判断循环依赖，出现循环依赖问题报错</p>
<ul>
<li><p>两个 Map：<code>&lt;bean name=&quot;A&quot; depends-on=&quot;B&quot; ...&gt;</code></p>
<ul>
<li>dependentBeanMap：记录依赖了当前 beanName 的其他 beanName（谁依赖我，我记录谁）</li>
<li>dependenciesForBeanMap：记录当前 beanName 依赖的其它 beanName </li>
<li>以 B 为视角 dependentBeanMap {“B”：{“A”}}，以 A 为视角 dependenciesForBeanMap {“A” :{“B”}}</li>
</ul>
</li>
<li><p><code>canonicalName(beanName)</code>：处理 bean 的 name</p>
</li>
<li><p><code>dependentBeans = this.dependentBeanMap.get(canonicalName)</code>：获取依赖了当前 bean 的 name</p>
</li>
<li><p><code>if (dependentBeans.contains(dependentBeanName))</code>：依赖了当前 bean 的集合中是否有该 name，有就产生循环依赖</p>
</li>
<li><p>进行递归处理所有的引用：假如 <code>&lt;bean name=&quot;A&quot; dp=&quot;B&quot;&gt; &lt;bean name=&quot;B&quot; dp=&quot;C&quot;&gt; &lt;bean name=&quot;C&quot; dp=&quot;A&quot;&gt;</code></p>
<pre><code class="java">dependentBeanMap=&#123;A:&#123;C&#125;, B:&#123;A&#125;, C:&#123;B&#125;&#125; 
// C 依赖 A             判断谁依赖了C                递归判断                谁依赖了B
isDependent(C, A)  → C#dependentBeans=&#123;B&#125; → isDependent(B, A); → B#dependentBeans=&#123;A&#125; //返回true
</code></pre>
</li>
</ul>
<p><code>registerDependentBean(dep, beanName)</code>：把 bean 和依赖注册到两个 Map 中，注意参数的位置，被依赖的在前</p>
<p><code>getBean(dep)</code>：<strong>先加载依赖的 Bean</strong>，又进入 doGetBean() 的逻辑</p>
</li>
<li><p><code>if (mbd.isSingleton())</code>：<strong>判断 bean 是否是单例的 bean</strong></p>
<p><code>getSingleton(String, ObjectFactory&lt;?&gt;)</code>：<strong>第二次获取，传入一个工厂对象</strong>，这个方法更倾向于创建实例并返回</p>
<pre><code class="java">sharedInstance = getSingleton(beanName, () -&gt; &#123;
    return createBean(beanName, mbd, args);//创建，跳转生命周期
    //lambda表达式，调用了ObjectFactory的getObject()方法，实际回调接口实现的是 createBean()方法进行创建对象
&#125;);
</code></pre>
<ul>
<li><p><code>singletonObjects.get(beanName)</code>：从一级缓存检查是否已经被加载，单例模式复用已经创建的 bean</p>
</li>
<li><p><code>this.singletonsCurrentlyInDestruction</code>：容器销毁时会设置这个属性为 true，这时就不能再创建 bean 实例了</p>
</li>
<li><p><code>beforeSingletonCreation(beanName)</code>：检查构造注入的依赖，<strong>构造参数注入产生的循环依赖无法解决</strong></p>
<p><code>!this.singletonsCurrentlyInCreation.add(beanName)</code>：将当前 beanName 放入到正在创建中单实例集合，放入成功说明没有产生循环依赖，失败则产生循环依赖，进入判断条件内的逻辑抛出异常</p>
<p>原因：加载 A，向正在创建集合中添加了 {A}，根据 A 的构造方法实例化 A 对象，发现 A 的构造方法依赖 B，然后加载 B，B 构造方法的参数依赖于 A，又去加载 A 时来到当前方法，因为创建中集合已经存在 A，所以添加失败</p>
</li>
<li><p><code>singletonObject = singletonFactory.getObject()</code>：<strong>创建 bean</strong>（生命周期部分详解）</p>
</li>
<li><p><strong>创建完成以后，Bean 已经初始化好，是一个完整的可使用的 Bean</strong></p>
</li>
<li><p><code>afterSingletonCreation(beanName)</code>：从正在创建中的集合中移出</p>
</li>
<li><p><code>addSingleton(beanName, singletonObject)</code>：<strong>添加一级缓存单例池中，从二级三级缓存移除</strong></p>
</li>
</ul>
<p><code>bean = getObjectForBeanInstance</code>：<strong>单实例可能是普通单实例或者 FactoryBean</strong>，如果是 FactoryBean 实例，需要判断 name 是带 &amp; 还是不带 &amp;，带 &amp; 说明 getBean 获取 FactoryBean 对象，否则是获取 FactoryBean 内部管理的实例</p>
<ul>
<li><p>参数 name 是未处理 &amp; 的 name，beanName 是处理过 &amp; 和别名后的 name</p>
</li>
<li><p><code>if(BeanFactoryUtils.isFactoryDereference(name))</code>：判断 doGetBean 中参数 name 前是否带 &amp;，不是处理后的</p>
</li>
<li><p><code>if(!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name))</code>：Bean 是普通单实例或者是 FactoryBean 就可以直接返回，否则进入下面的获取 <strong>FactoryBean 内部管理的实例</strong>的逻辑</p>
</li>
<li><p><code>getCachedObjectForFactoryBean(beanName)</code>：尝试到缓存获取，获取到直接返回，获取不到进行下面逻辑</p>
</li>
<li><p><code>if (mbd == null &amp;&amp; containsBeanDefinition(beanName))</code>：Spring 中有当前 beanName 的 BeanDefinition 信息</p>
<p><code>mbd = getMergedLocalBeanDefinition(beanName)</code>：获取合并后的 BeanDefinition</p>
</li>
<li><p><code>mbd.isSynthetic()</code>：默认值是 false 表示这是一个用户对象，如果是 true 表示是系统对象</p>
</li>
<li><p><code>object = getObjectFromFactoryBean(factory, beanName, !synthetic)</code>：从工厂内获取实例</p>
<ul>
<li><code>factory.isSingleton() &amp;&amp; containsSingleton(beanName)</code>：工厂内部维护的对象是单实例并且一级缓存存在该 bean</li>
<li>首先去缓存中获取，获取不到就<strong>使用工厂获取</strong>然后放入缓存，进行循环依赖判断</li>
</ul>
</li>
</ul>
</li>
<li><p><code>else if (mbd.isPrototype())</code>：<strong>bean 是原型的 bean</strong></p>
<p><code>beforePrototypeCreation(beanName)</code>：当前线程正在创建的原型对象 beanName 存入 prototypesCurrentlyInCreation</p>
<ul>
<li><code>curVal = this.prototypesCurrentlyInCreation.get()</code>：获取当前线程的正在创建的原型类集合</li>
<li><code>this.prototypesCurrentlyInCreation.set(beanName)</code>：集合为空就把当前 beanName 加入</li>
<li><code>if (curVal instanceof String)</code>：已经有线程相关原型类创建了，把当前的创建的加进去</li>
</ul>
<p><code>createBean(beanName, mbd, args)</code>：创建原型类对象，不需要三级缓存</p>
<p><code>afterPrototypeCreation(beanName)</code>：从正在创建中的集合中移除该 beanName， <strong>与 beforePrototypeCreation逻辑相反</strong></p>
</li>
<li><p><code>convertIfNecessary()</code>：<strong>依赖检查</strong>，检查所需的类型是否与实际 bean 实例的类型匹配</p>
</li>
<li><p><code>return (T) bean</code>：返回创建完成的 bean</p>
</li>
</ul>
<hr>
<h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h5><p>Bean 的生命周期：实例化 instantiation，填充属性 populate，初始化 initialization，销毁 destruction</p>
<p>AbstractAutowireCapableBeanFactory.createBean()：进入 Bean 生命周期的流程</p>
<ul>
<li><p><code>resolvedClass = resolveBeanClass(mbd, beanName)</code>：判断 mdb 中的 class 是否已经<strong>加载到 JVM</strong>，如果未加载则使用类加载器将 beanName 加载到 JVM中并返回 class 对象</p>
</li>
<li><p><code>if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null)</code>：条件成立封装 mbd 并把 resolveBeanClass 设置到 bd 中</p>
<ul>
<li>条件二：mbd 在 resolveBeanClass 之前是否有 class</li>
<li>条件三：mbd 有 className</li>
</ul>
</li>
<li><p><code>bean = resolveBeforeInstantiation(beanName, mbdToUse)</code>：实例化前的后置处理器返回一个代理实例对象（不是 AOP）</p>
<ul>
<li>自定义类继承 InstantiationAwareBeanPostProcessor，重写 postProcessBeforeInstantiation 方法，<strong>方法逻辑为创建对象</strong> </li>
<li>并配置文件 <code>&lt;bean class=&quot;intefacePackage.MyInstantiationAwareBeanPostProcessor&quot;&gt;</code> 导入为 bean</li>
<li>条件成立，<strong>短路操作</strong>，直接 return bean</li>
</ul>
</li>
<li><p><code>Object beanInstance = doCreateBean(beanName, mbdToUse, args)</code>：Do it</p>
</li>
</ul>
<p>AbstractAutowireCapableBeanFactory.<strong>doCreateBean</strong>(beanName, RootBeanDefinition, Object[] args)：创建 Bean</p>
<ul>
<li><p><code>BeanWrapper instanceWrapper = null</code>：<strong>Spring 给所有创建的 Bean 实例包装成 BeanWrapper</strong>，内部最核心的方法是获取实例，提供了一些额外的接口方法，比如属性访问器</p>
</li>
<li><p><code>instanceWrapper = this.factoryBeanInstanceCache.remove(beanName)</code>：单例对象尝试从缓存中获取，会移除缓存</p>
</li>
<li><p><code>createBeanInstance()</code>：<strong>缓存中没有实例就进行创建实例</strong>（逻辑复杂，下一小节详解）</p>
</li>
<li><p><code>if (!mbd.postProcessed)</code>：每个 bean 只进行一次该逻辑</p>
<p><code>applyMergedBeanDefinitionPostProcessors()</code>：<strong>后置处理器，合并 bd 信息</strong>，接下来要属性填充了</p>
<p><code>AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition()</code>：<strong>后置处理逻辑（@Autowired）</strong></p>
<ul>
<li><p><code>metadata = findAutowiringMetadata(beanName, beanType, null)</code>：提取当前 bean 整个继承体系内的 <strong>@Autowired、@Value、@Inject</strong> 信息，存入一个 InjectionMetadata 对象，保存着当前 bean 信息和要自动注入的字段信息</p>
<pre><code class="java">private final Class&lt;?&gt; targetClass;                            //当前 bean 
private final Collection&lt;InjectedElement&gt; injectedElements;    //要注入的信息集合
</code></pre>
<ul>
<li><p><code>metadata = buildAutowiringMetadata(clazz)</code>：查询当前 clazz 感兴趣的注解信息</p>
<ul>
<li><p><code>ReflectionUtils.doWithLocalFields()</code>：提取<strong>字段</strong>的注解的信息</p>
<p><code>findAutowiredAnnotation(field)</code>：代表感兴趣的注解就是那三种注解，获取这三种注解的元数据</p>
</li>
<li><p><code>ReflectionUtils.doWithLocalMethods()</code>：提取<strong>方法</strong>的注解的信息</p>
</li>
<li><p><code>do&#123;&#125; while (targetClass != null &amp;&amp; targetClass != Object.class)</code>：循环从父类中解析，直到 Object 类</p>
</li>
</ul>
</li>
<li><p><code>this.injectionMetadataCache.put(cacheKey, metadata)</code>：存入缓存</p>
</li>
</ul>
</li>
</ul>
<p><code>mbd.postProcessed = true</code>：设置为 true，下次访问该逻辑不会再进入</p>
</li>
<li><p><code>earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)</code>：单例、解决循环引用、是否在单例正在创建集合中</p>
<pre><code class="java">if (earlySingletonExposure) &#123;
    // 【放入三级缓存一个工厂对象，用来获取提前引用】
    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
    // lamda 表达式，用来获取提前引用，循环依赖部分详解该逻辑
&#125;
</code></pre>
</li>
<li><p><code> populateBean(beanName, mbd, instanceWrapper)</code>：**属性填充，依赖注入，整体逻辑是先处理标签再处理注解，填充至 pvs 中，最后通过 apply 方法最后完成属性依赖注入到 BeanWrapper **</p>
<ul>
<li><p><code>if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName))</code>：实例化后的后置处理器，默认返回 true，可以自定义类继承 InstantiationAwareBeanPostProcessor 修改后置处理方法的返回值为 false，使 continueWithPropertyPopulation 为 false，<strong>会导致直接返回，不进行属性的注入</strong></p>
</li>
<li><p><code>if (!continueWithPropertyPopulation)</code>：自定义方法返回值会造成该条件成立，逻辑为直接返回，<strong>不进行依赖注入</strong></p>
</li>
<li><p><code>PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null)</code>：处理依赖注入逻辑开始</p>
</li>
<li><p><code>mbd.getResolvedAutowireMode() == ?</code>：<strong>根据 bean 标签配置的 autowire</strong> 判断是 BY_NAME 或者 BY_TYPE</p>
<p><code>autowireByName(beanName, mbd, bw, newPvs)</code>：根据字段名称去获取依赖的 bean，还没注入，只是添加到 pvs</p>
<ul>
<li><p><code>propertyNames = unsatisfiedNonSimpleProperties(mbd, bw)</code>：bean 实例中有该字段和该字段的 setter 方法，但是在 bd 中没有 property 属性</p>
<ul>
<li><p>拿到配置的 property 信息和 bean 的所有字段信息</p>
</li>
<li><p><code>pd.getWriteMethod() != null</code>：<strong>当前字段是否有 set 方法，配置类注入的方式需要 set 方法</strong></p>
<p><code>!isExcludedFromDependencyCheck(pd)</code>：当前字段类型是否在忽略自动注入的列表中</p>
<p><code>!pvs.contains(pd.getName()</code>：当前字段不在 xml 或者其他方式的配置中，也就是 bd 中不存在对应的 property</p>
<p><code>!BeanUtils.isSimpleProperty(pd.getPropertyType()</code>：是否是基本数据类型和内置的几种数据类型，基本数据类型不允许自动注入</p>
</li>
</ul>
</li>
<li><p><code>if (containsBean(propertyName))</code>：BeanFactory 中存在当前 property 的 bean 实例，说明找到对应的依赖数据</p>
</li>
<li><p><code>getBean(propertyName)</code>：<strong>拿到 propertyName 对应的 bean 实例</strong></p>
</li>
<li><p><code>pvs.add(propertyName, bean)</code>：填充到 pvs 中</p>
</li>
<li><p><code>registerDependentBean(propertyName, beanName))</code>：添加到两个依赖 Map（dependsOn）中</p>
</li>
</ul>
<p><code>autowireByType(beanName, mbd, bw, newPvs)</code>：根据字段类型去查找依赖的 bean</p>
<ul>
<li><code>desc = new AutowireByTypeDependencyDescriptor(methodParam, eager)</code>：依赖描述信息</li>
<li><code>resolveDependency(desc, beanName, autowiredBeanNames, converter)</code>：根据描述信息，查找依赖对象，容器中没有对应的实例但是有对应的 BD，会调用 getBean(Type) 获取对象</li>
</ul>
<p><code>pvs = newPvs</code>：newPvs 是处理了依赖数据后的 pvs，所以赋值给 pvs</p>
</li>
<li><p><code>hasInstAwareBpps</code>：表示当前是否有 InstantiationAwareBeanPostProcessors 的后置处理器（Autowired）</p>
</li>
<li><p><code>pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName)</code>：**@Autowired 注解的注入**，这个传入的 pvs 对象，最后原封不动的返回，不会添加东西</p>
<ul>
<li><p><code>findAutowiringMetadata()</code>：包装着当前 bd 需要注入的注解信息集合，<strong>三种注解的元数据</strong>，直接缓存获取</p>
</li>
<li><p><code>InjectionMetadata.InjectedElement.inject()</code>：遍历注解信息解析后注入到 Bean，方法和字段的注入实现不同</p>
<p>以字段注入为例：</p>
<ul>
<li><p><code>value = resolveFieldValue(field, bean, beanName)</code>：处理字段属性值</p>
<p><code>value = beanFactory.resolveDependency()</code>：解决依赖</p>
<p><code>result = doResolveDependency()</code>：<strong>真正处理自动注入依赖的逻辑</strong></p>
<ul>
<li><p><code>Object shortcut = descriptor.resolveShortcut(this)</code>：默认返回 null</p>
</li>
<li><p><code>Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor)</code>：<strong>获取 @Value 的值</strong></p>
</li>
<li><p><code>converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor())</code>：如果 value 不是 null，就直接进行类型转换返回数据</p>
</li>
<li><p><code>matchingBeans = findAutowireCandidates(beanName, type, descriptor)</code>：如果 value 是空说明字段是引用类型，<strong>获取 @Autowired 的 Bean</strong></p>
<pre><code class="java">// addCandidateEntry() → Object beanInstance = descriptor.resolveCandidate()
public Object resolveCandidate(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory) throws BeansException &#123;
    // 获取 bean
    return beanFactory.getBean(beanName);
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><code>ReflectionUtils.makeAccessible(field)</code>：修改访问权限</p>
</li>
<li><p><code>field.set(bean, value)</code>：获取属性访问器为此 field 对象赋值</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>applyPropertyValues()</code>：<strong>将所有解析的 PropertyValues 的注入至 BeanWrapper 实例中</strong>（深拷贝）</p>
<ul>
<li><code>if (pvs.isEmpty())</code>：注解 @Autowired 和 @Value 标注的信息在后置处理的逻辑注入完成，此处为空直接返回</li>
<li>下面的逻辑进行 XML 配置的属性的注入，首先获取转换器进行数据转换，然后<strong>获取 WriteMethod (set) 方法进行反射调用</strong>，完成属性的注入</li>
</ul>
</li>
</ul>
</li>
<li><p><code>initializeBean(String,Object,RootBeanDefinition)</code>：<strong>初始化，分为配置文件和实现接口两种方式</strong></p>
<ul>
<li><p><code>invokeAwareMethods(beanName, bean)</code>：根据 bean 是否实现 Aware 接口执行初始化的方法</p>
</li>
<li><p><code>wrappedBean = applyBeanPostProcessorsBeforeInitialization</code>：初始化前的后置处理器，可以继承接口重写方法</p>
<ul>
<li><code>processor.postProcessBeforeInitialization()</code>：执行后置处理的方法，默认返回 bean 本身</li>
<li><code>if (current == null) return result</code>：重写方法返回 null，会造成后置处理的短路，直接返回</li>
</ul>
</li>
<li><p><code>invokeInitMethods(beanName, wrappedBean, mbd)</code>：<strong>反射执行初始化方法</strong></p>
<ul>
<li><p><code>isInitializingBean = (bean instanceof InitializingBean)</code>：初始化方法的定义有两种方式，一种是自定义类实现 InitializingBean 接口，另一种是配置文件配置 &lt;bean id&#x3D;”…” class&#x3D;”…” init-method&#x3D;”init”&#x2F; &gt;</p>
</li>
<li><p><code>isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))</code>：</p>
<ul>
<li><p>条件一：当前 bean 是不是实现了 InitializingBean </p>
</li>
<li><p>条件二：InitializingBean 接口中的方法 afterPropertiesSet，判断该方法是否是容器外管理的方法</p>
</li>
</ul>
</li>
<li><p><code>if (mbd != null &amp;&amp; bean.getClass() != NullBean.class)</code>：成立说明是配置文件的方式</p>
<p><code>if(!(接口条件))</code>表示<strong>如果通过接口实现了初始化方法的话，就不会在调用配置类中 init-method 定义的方法</strong></p>
<p><code>((InitializingBean) bean).afterPropertiesSet()</code>：调用方法</p>
<p><code>invokeCustomInitMethod</code>：执行自定义的方法</p>
<ul>
<li><code>initMethodName = mbd.getInitMethodName()</code>：获取方法名</li>
<li><code>Method initMethod = ()</code>：根据方法名获取到 init-method 方法</li>
<li><code> methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod)</code>：将方法转成从接口层面获取</li>
<li><code>ReflectionUtils.makeAccessible(methodToInvoke)</code>：访问权限设置成可访问</li>
<li><code> methodToInvoke.invoke(bean)</code>：<strong>反射调用初始化方法</strong>，以当前 bean 为角度去调用</li>
</ul>
</li>
</ul>
</li>
<li><p><code>wrappedBean = applyBeanPostProcessorsAfterInitialization</code>：初始化后的后置处理器</p>
<ul>
<li><p><code>AbstractAutoProxyCreator.postProcessAfterInitialization()</code>：如果 Bean 被子类标识为要代理的 bean，则使用配置的拦截器<strong>创建代理对象</strong>，AOP 部分详解</p>
</li>
<li><p>如果不存在循环依赖，创建动态代理 bean 在此处完成；否则真正的创建阶段是在属性填充时获取提前引用的阶段，<strong>循环依赖</strong>详解，源码分析：</p>
<pre><code class="java">// 该集合用来避免重复将某个 bean 生成代理对象，
private final Map&lt;Object, Object&gt; earlyProxyReferences = new ConcurrentHashMap&lt;&gt;(16);

public Object postProcessAfterInitialization(@Nullable Object bean,String bN)&#123;
    if (bean != null) &#123;
        // cacheKey 是 beanName 或者加上 &amp;
        Object cacheKey = getCacheKey(bean.getClass(), beanName);y
            if (this.earlyProxyReferences.remove(cacheKey) != bean) &#123;
                // 去提前代理引用池中寻找该key，不存在则创建代理
                // 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理
                return wrapIfNecessary(bean, bN, cacheKey);
            &#125;
    &#125;
    return bean;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>if (earlySingletonExposure)</code>：是否允许提前引用</p>
<p><code>earlySingletonReference = getSingleton(beanName, false)</code>：<strong>从二级缓存获取实例</strong>，放入一级缓存是在 doGetBean 中的sharedInstance &#x3D; getSingleton() 逻辑中，此时在 createBean 的逻辑还没有返回，所以一级缓存没有</p>
<p><code>if (earlySingletonReference != null)</code>：当前 bean 实例从二级缓存中获取到了，说明<strong>产生了循环依赖</strong>，在属性填充阶段会提前调用三级缓存中的工厂生成 Bean 的代理对象（或原始实例），放入二级缓存中，然后使用原始 bean 继续执行初始化</p>
<ul>
<li><p><code> if (exposedObject == bean)</code>：<strong>初始化后的 bean &#x3D;&#x3D; 创建的原始实例</strong>，条件成立的两种情况：当前的真实实例不需要被代理；当前实例存在循环依赖已经被提前代理过了，初始化时的后置处理器直接返回 bean 原实例</p>
<p><code>exposedObject = earlySingletonReference</code>：<strong>把代理后的 Bean 传给 exposedObject 用来返回，因为只有代理对象才封装了拦截器链，main 方法中用代理对象调用方法时会进行增强，代理是对原始对象的包装，所以这里返回的代理对象中含有完整的原实例（属性填充和初始化后的），是一个完整的代理对象，返回后外层方法会将当前 Bean 放入一级缓存</strong></p>
</li>
<li><p><code>else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName))</code>：是否有其他 bean 依赖当前 bean，执行到这里说明是不存在循环依赖、存在增强代理的逻辑，也就是正常的逻辑</p>
<ul>
<li><p><code>dependentBeans = getDependentBeans(beanName)</code>：取到依赖当前 bean 的其他 beanName</p>
</li>
<li><p><code>if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean))</code>：判断 dependentBean 是否创建完成</p>
<ul>
<li><code>if (!this.alreadyCreated.contains(beanName))</code>：成立当前 bean 尚未创建完成，当前 bean 是依赖exposedObject 的 bean，返回 true</li>
</ul>
</li>
<li><p><code>return false</code>：创建完成返回 false</p>
<p><code>actualDependentBeans.add(dependentBean)</code>：创建完成的 dependentBean 加入该集合</p>
</li>
<li><p><code>if (!actualDependentBeans.isEmpty())</code>：条件成立说明有依赖于当前 bean 的 bean 实例创建完成，但是当前的 bean 还没创建完成返回，依赖当前 bean 的外部 bean 持有的是不完整的 bean，所以需要报错</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>registerDisposableBeanIfNecessary</code>：判断当前 bean 是否需要<strong>注册析构函数回调</strong>，当容器销毁时进行回调</p>
<ul>
<li><p><code>if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd))</code></p>
<ul>
<li><p>如果是原型 prototype 不会注册析构回调，不会回调该函数，对象的回收由 JVM 的 GC 机制完成</p>
</li>
<li><p>requiresDestruction()：</p>
<ul>
<li><p><code>DisposableBeanAdapter.hasDestroyMethod(bean, mbd)</code>：bd 中定义了 DestroyMethod 返回 true</p>
</li>
<li><p><code>hasDestructionAwareBeanPostProcessors()</code>：后处理器框架决定是否进行析构回调</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>registerDisposableBean()</code>：条件成立进入该方法，给当前单实例注册回调适配器，适配器内根据当前 bean 实例是继承接口（DisposableBean）还是自定义标签来判定具体调用哪个方法实现</p>
</li>
</ul>
</li>
<li><p><code>this.disposableBeans.put(beanName, bean)</code>：向销毁集合添加实例</p>
</li>
</ul>
<hr>
<h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p>AbstractAutowireCapableBeanFactory.createBeanInstance(beanName, RootBeanDefinition, Object[] args)</p>
<ul>
<li><p><code>resolveBeanClass(mbd, beanName)</code>：确保 Bean 的 Class 真正的被加载</p>
</li>
<li><p>判断类的访问权限是不是 public，不是进入下一个判断，是否允许访问类的 non-public 的构造方法，不允许则报错</p>
</li>
<li><p><code>Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier()</code>：获取创建实例的函数，可以自定义，没有进入下面的逻辑</p>
</li>
<li><p><code>if (mbd.getFactoryMethodName() != null)</code>：<strong>判断 bean 是否设置了 factory-method 属性，优先使用</strong></p>
<p><bean class factory-method>，设置了该属性进入 factory-method 方法创建实例</bean></p>
</li>
<li><p><code>resolved = false</code>：代表 bd 对应的构造信息是否已经解析成可以反射调用的构造方法</p>
</li>
<li><p><code>autowireNecessary = false</code>：是否自动匹配构造方法</p>
</li>
<li><p><code>if(mbd.resolvedConstructorOrFactoryMethod != null)</code>：获取 bd 的构造信息转化成反射调用的 method 信息</p>
<ul>
<li>method 为 null 则 resolved 和 autowireNecessary 都为默认值 false</li>
<li><code>autowireNecessary = mbd.constructorArgumentsResolved</code>：构造方法有参数，设置为 true</li>
</ul>
</li>
<li><p><strong>bd 对应的构造信息解析完成，可以直接反射调用构造方法了</strong>：</p>
<ul>
<li><p><code>return autowireConstructor(beanName, mbd, null, null)</code>：<strong>有参构造</strong>，根据参数匹配最优的构造器创建实例</p>
</li>
<li><p><code>return instantiateBean(beanName, mbd)</code>：<strong>无参构造方法通过反射创建实例</strong></p>
<ul>
<li><p><code>SimpleInstantiationStrategy.instantiate()</code>：<strong>真正用来实例化的函数</strong>（无论如何都会走到这一步）</p>
<ul>
<li><p><code>if (!bd.hasMethodOverrides())</code>：没有方法重写覆盖</p>
<p><code>BeanUtils.instantiateClass(constructorToUse)</code>：调用 <code>Constructor.newInstance()</code> 实例化</p>
</li>
<li><p><code>instantiateWithMethodInjection(bd, beanName, owner)</code>：<strong>有方法重写采用 CGLIB  实例化</strong></p>
</li>
</ul>
</li>
<li><p><code>BeanWrapper bw = new BeanWrapperImpl(beanInstance)</code>：包装成 BeanWrapper 类型的对象</p>
</li>
<li><p><code>return bw</code>：返回实例</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName)</code>：**@Autowired 注解**，对应的后置处理器 AutowiredAnnotationBeanPostProcessor 逻辑</p>
<ul>
<li><p>配置了 lookup 的相关逻辑</p>
</li>
<li><p><code>this.candidateConstructorsCache.get(beanClass)</code>：从缓存中获取构造方法，第一次获取为 null，进入下面逻辑</p>
</li>
<li><p><code>rawCandidates = beanClass.getDeclaredConstructors()</code>：获取所有的构造器</p>
</li>
<li><p><code>Constructor&lt;?&gt; requiredConstructor = null</code>：唯一的选项构造器，**@Autowired(required &#x3D; “true”)** 时有值</p>
</li>
<li><p><code>for (Constructor&lt;?&gt; candidate : rawCandidates)</code>：遍历所有的构造器：</p>
<p><code>ann = findAutowiredAnnotation(candidate)</code>：有三种注解中的一个会返回注解的属性</p>
<ul>
<li><p>遍历 this.autowiredAnnotationTypes 中的三种注解：</p>
<pre><code class="java">this.autowiredAnnotationTypes.add(Autowired.class);//！！！！！！！！！！！！！！
this.autowiredAnnotationTypes.add(Value.class);
this.autowiredAnnotationTypes.add(...ClassUtils.forName(&quot;javax.inject.Inject&quot;));
</code></pre>
</li>
<li><p><code> AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type)</code>：获取注解的属性</p>
</li>
<li><p><code>if (attributes != null) return attributes</code>：任意一个注解属性不为空就注解返回</p>
</li>
</ul>
<p><code>if (ann == null)</code>：注解属性为空</p>
<ul>
<li><code>userClass = ClassUtils.getUserClass(beanClass)</code>：如果当前 beanClass 是代理对象，方法上就已经没有注解了，所以<strong>获取原始的用户类型重新获取该构造器上的注解属性</strong>（<strong>事务注解失效</strong>也是这个原理）</li>
</ul>
<p><code>if (ann != null)</code>：注解属性不为空了</p>
<ul>
<li><p><code>required = determineRequiredStatus(ann)</code>：获取 required 属性的值</p>
<ul>
<li><code>!ann.containsKey(this.requiredParameterName) || </code>：判断属性是否包含 required，不包含进入后面逻辑</li>
<li><code>this.requiredParameterValue == ann.getBoolean(this.requiredParameterName)</code>：获取属性值返回</li>
</ul>
</li>
<li><p><code>if (required)</code>：代表注解 @Autowired(required &#x3D; true)</p>
<p><code>if (!candidates.isEmpty())</code>：true 代表只能有一个构造方法，构造集合不是空代表可选的构造器不唯一，报错</p>
<p><code>requiredConstructor = candidate</code>：把构造器赋值给 requiredConstructor</p>
</li>
<li><p><code>candidates.add(candidate)</code>：把当前构造方法添加至 candidates 集合</p>
</li>
</ul>
<p><code> if(candidate.getParameterCount() == 0)</code>：当前遍历的构造器的参数为 0 代表没有参数，是<strong>默认构造器</strong>，赋值给 defaultConstructor </p>
</li>
<li><p><code>candidateConstructors = candidates.toArray(new Constructor&lt;?&gt;[0])</code>：<strong>将构造器转成数组返回</strong></p>
</li>
</ul>
</li>
<li><p><code>if(ctors != null)</code>：条件成立代表指定了<strong>构造方法数组</strong></p>
<p><code>mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR</code>：<bean autowire> 标签内 autowiremode 的属性值，默认是 no，AUTOWIRE_CONSTRUCTOR 代表选择最优的构造方法</bean></p>
<p><code>mbd.hasConstructorArgumentValues()</code>：bean 信息中是否配置了构造参数的值</p>
<p><code>!ObjectUtils.isEmpty(args)</code>：getBean 时，指定了参数 arg</p>
</li>
<li><p><code>return autowireConstructor(beanName, mbd, ctors, args)</code>：<strong>选择最优的构造器进行创建实例</strong>（复杂，不建议研究）</p>
<ul>
<li><p><code>beanFactory.initBeanWrapper(bw)</code>：向 BeanWrapper 中注册转换器，向工厂中注册属性编辑器</p>
</li>
<li><p><code>Constructor&lt;?&gt; constructorToUse = null</code>：实例化反射构造器</p>
<p><code>ArgumentsHolder argsHolderToUse</code>：实例化时真正去用的参数，并持有对象</p>
<ul>
<li>rawArguments 是转换前的参数，arguments 是类型转换完成的参数</li>
</ul>
<p><code>Object[] argsToUse</code>：参数实例化时使用的参数</p>
</li>
<li><p><code>Object[] argsToResolve</code>：表示构造器参数做转换后的参数引用</p>
</li>
<li><p><code>if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved)</code>：</p>
<ul>
<li>条件一成立说明当前 bd 生成的实例不是第一次，缓存中有解析好的构造器方法可以直接拿来反射调用</li>
<li>条件二成立说明构造器参数已经解析过了</li>
</ul>
</li>
<li><p><code>argsToUse = resolvePreparedArguments()</code>：argsToResolve 不是完全解析好的，还需要继续解析</p>
</li>
<li><p><code>if (constructorToUse == null || argsToUse == null)</code>：条件成立说明缓存机制失败，进入构造器匹配逻辑</p>
</li>
<li><p><code>Constructor&lt;?&gt;[] candidates = chosenCtors</code>：chosenCtors  只有在构造方法上有 autowaire 三种注解时才有数据</p>
</li>
<li><p><code>if (candidates == null)</code>：candidates 为空就根据 beanClass 是否允许访问非公开的方法来获取构造方法</p>
</li>
<li><p><code>if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues())</code>：默认无参</p>
<p><code>bw.setBeanInstance(instantiate())</code>：<strong>使用无参构造器反射调用，创建出实例对象，设置到 BeanWrapper 中去</strong></p>
</li>
<li><p><code>boolean autowiring</code>：<strong>需要选择最优的构造器</strong></p>
</li>
<li><p><code>cargs = mbd.getConstructorArgumentValues()</code>：获取参数值</p>
<p><code>resolvedValues = new ConstructorArgumentValues()</code>：获取已经解析后的构造器参数值</p>
<ul>
<li><code>final Map&lt;Integer, ValueHolder&gt; indexedArgumentValues</code>：key 是 index， value 是值</li>
<li><code>final List&lt;ValueHolder&gt; genericArgumentValues</code>：没有 index 的值</li>
</ul>
<p><code>minNrOfArgs = resolveConstructorArguments(..,resolvedValues)</code>：从 bd 中解析并获取构造器参数的个数</p>
<ul>
<li><code>valueResolver.resolveValueIfNecessary()</code>：将引用转换成真实的对象</li>
<li><code>resolvedValueHolder.setSource(valueHolder)</code>：将对象填充至 ValueHolder 中</li>
<li><code> resolvedValues.addIndexedArgumentValue()</code>：将参数值封装至 resolvedValues 中</li>
</ul>
</li>
<li><p><code>AutowireUtils.sortConstructors(candidates)</code>：排序规则 public &gt; 非公开的 &gt; 参数多的 &gt; 参数少的</p>
</li>
<li><p><code> int minTypeDiffWeight = Integer.MAX_VALUE</code>：值越低说明构造器<strong>参数列表类型</strong>和构造参数的匹配度越高</p>
</li>
<li><p><code>Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors</code>：模棱两可的构造器，两个构造器匹配度相等时放入</p>
</li>
<li><p><code>for (Constructor&lt;?&gt; candidate : candidates)</code>：遍历筛选出 minTypeDiffWeight 最低的构造器</p>
</li>
<li><p><code>Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes()</code>：获取当前处理的构造器的参数类型</p>
</li>
<li><p><code>if()</code>：candidates 是排过序的，当前筛选出来的构造器的优先级一定是优先于后面的 constructor</p>
</li>
<li><p><code>if (paramTypes.length &lt; minNrOfArgs)</code>：需求的小于给的，不匹配</p>
</li>
<li><p><code>int typeDiffWeight</code>：获取匹配度</p>
<ul>
<li><code>mbd.isLenientConstructorResolution()</code>：true 表示 ambiguousConstructors 允许有数据，false 代表不允许有数据，有数据就报错（LenientConstructorResolution：宽松的构造函数解析）</li>
<li><code>argsHolder.getTypeDifferenceWeight(paramTypes)</code>：选择参数转换前和转换后匹配度最低的，循环向父类中寻找该方法，直到寻找到 Obejct 类</li>
</ul>
</li>
<li><p><code> if (typeDiffWeight &lt; minTypeDiffWeight)</code>：条件成立说明当前循环处理的构造器更优</p>
</li>
<li><p><code>else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight)</code>：当前处理的构造器的计算出来的 DiffWeight 与上一次筛选出来的最优构造器的值一致，说明有模棱两可的情况</p>
</li>
<li><p><code>if (constructorToUse == null)</code>：未找到可以使用的构造器，报错</p>
</li>
<li><p><code> else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution())</code>：模棱两可有数据，LenientConstructorResolution &#x3D;&#x3D; false，所以报错</p>
</li>
<li><p><code>argsHolderToUse.storeCache(mbd, constructorToUse)</code>：匹配成功，进行缓存，方便后来者使用该 bd 实例化</p>
</li>
<li><p><code> bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse))</code>：匹配成功调用 instantiate 创建出实例对象，设置到 BeanWrapper 中去</p>
</li>
</ul>
</li>
<li><p><code>return instantiateBean(beanName, mbd)</code>：默认走到这里</p>
</li>
</ul>
<hr>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p>循环依赖：是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成一个环形调用</p>
<p>Spring 循环依赖有四种：</p>
<ul>
<li>DependsOn 依赖加载【无法解决】（两种 Map）</li>
<li>原型模式 Prototype 循环依赖【无法解决】（正在创建集合）</li>
<li>单例 Bean 循环依赖：构造参数产生依赖【无法解决】（正在创建集合，getSingleton() 逻辑中）</li>
<li>单例 Bean 循环依赖：setter 产生依赖【可以解决】</li>
</ul>
<p>解决循环依赖：提前引用，提前暴露创建中的 Bean</p>
<ul>
<li>Spring 先实例化 A，拿到 A 的构造方法反射创建出来 A 的早期实例对象，这个对象被包装成 ObjectFactory 对象，放入三级缓存</li>
<li>处理 A 的依赖数据，检查发现 A 依赖 B 对象，所以 Spring 就会去根据 B 类型到容器中去 getBean(B)，这里产生递归</li>
<li>拿到 B 的构造方法，进行反射创建出来 B 的早期实例对象，也会把 B 包装成 ObjectFactory 对象，放到三级缓存，处理 B 的依赖数据，检查发现 B 依赖了 A 对象，然后 Spring 就会去根据 A 类型到容器中去 getBean(A.class)</li>
<li>这时从三级缓存中获取到 A 的早期对象进入属性填充</li>
</ul>
<p>循环依赖的三级缓存：</p>
<pre><code class="java">//一级缓存：存放所有初始化完成单实例 bean，单例池，key是beanName，value是对应的单实例对象引用
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);

//二级缓存：存放实例化未进行初始化的 Bean，提前引用池
private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);

/** Cache of singleton factories: bean name to ObjectFactory. 3*/
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);
</code></pre>
<ul>
<li><p>为什么需要三级缓存？</p>
<ul>
<li>循环依赖解决需要提前引用动态代理对象，AOP 动态代理是在 Bean 初始化后的后置处理中进行，这时的 bean 已经是成品对象。因为需要提前进行动态代理，三级缓存的 ObjectFactory 提前产生需要代理的对象，把提前引用放入二级缓存</li>
<li>如果只有二级缓存，提前引用就直接放入了一级缓存，然后 Bean 初始化完成后又会放入一级缓存，产生数据覆盖，<strong>导致提前引用的对象和一级缓存中的并不是同一个对象</strong></li>
<li>一级缓存只能存放完整的单实例，<strong>为了保证 Bean 的生命周期不被破坏</strong>，不能将未初始化的 Bean 暴露到一级缓存</li>
<li>若存在循环依赖，<strong>后置处理不创建代理对象，真正创建代理对象的过程是在 getBean(B) 的阶段中</strong></li>
</ul>
</li>
<li><p>三级缓存一定会创建提前引用吗？</p>
<ul>
<li>出现循环依赖就会去三级缓存获取提前引用，不出现就不会，走正常的逻辑，创建完成直接放入一级缓存</li>
<li>存在循环依赖，就创建代理对象放入二级缓存，如果没有增强方法就返回 createBeanInstance 创建的实例，因为 addSingletonFactory 参数中传入了实例化的 Bean，在 singletonFactory.getObject() 中返回给 singletonObject，所以<strong>存在循环依赖就一定会使用工厂</strong>，但是不一定创建的是代理对象，不需要增强就是原始对象</li>
</ul>
</li>
<li><p>wrapIfNecessary 一定创建代理对象吗？（AOP 动态代理部分有源码解析）</p>
<ul>
<li>存在增强器会创建动态代理，不需要增强就不需要创建动态代理对象</li>
<li>存在循环依赖会提前增强，初始化后不需要增强</li>
</ul>
</li>
<li><p>什么时候将 Bean 的引用提前暴露给第三级缓存的 ObjectFactory 持有？</p>
<ul>
<li><p>实例化之后，依赖注入之前</p>
<pre><code class="java">createBeanInstance -&gt; addSingletonFactory -&gt; populateBean
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h5><p>假如 A 依赖 B，B 依赖 A</p>
<ul>
<li><p>当 A 创建实例后填充属性前，执行：</p>
<pre><code class="java">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))
</code></pre>
<pre><code class="java">// 添加给定的单例工厂以构建指定的单例
protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;
    Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);
    synchronized (this.singletonObjects) &#123;
        // 单例池包含该Bean说明已经创建完成，不需要循环依赖
        if (!this.singletonObjects.containsKey(beanName)) &#123;
            //加入三级缓存
            this.singletonFactories.put(beanName,singletonFactory);
            this.earlySingletonObjects.remove(beanName);
            // 从二级缓存移除，因为三个Map中都是一个对象，不能同时存在！
            this.registeredSingletons.add(beanName);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>填充属性时 A 依赖 B，这时需要 getBean(B)，也会把 B 的工厂放入三级缓存，接着 B 填充属性时发现依赖 A，去进行**第一次 ** getSingleton(A)</p>
<pre><code class="java">public Object getSingleton(String beanName) &#123;
    return getSingleton(beanName, true);//为true代表允许拿到早期引用。
&#125;
protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;
    // 在一级缓存中获取 beanName 对应的单实例对象。
    Object singletonObject = this.singletonObjects.get(beanName);
    // 单实例确实尚未创建；单实例正在创建，发生了循环依赖
    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;
        synchronized (this.singletonObjects) &#123;
            // 从二级缓存获取
            singletonObject = this.earlySingletonObjects.get(beanName);
            // 二级缓存不存在，并且允许获取早期实例对象，去三级缓存查看
            if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;
                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) &#123;
                    // 从三级缓存获取工厂对象，并得到 bean 的提前引用
                    singletonObject = singletonFactory.getObject();
                    // 【缓存升级】，放入二级缓存，提前引用池
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    // 从三级缓存移除该对象
                    this.singletonFactories.remove(beanName);
                &#125;
            &#125;
        &#125;
    &#125;
    return singletonObject;
&#125;
</code></pre>
</li>
<li><p>从三级缓存获取 A 的 Bean：<code>singletonFactory.getObject()</code>，调用了 lambda 表达式的 getEarlyBeanReference 方法：</p>
<pre><code class="java">public Object getEarlyBeanReference(Object bean, String beanName) &#123;
    Object cacheKey = getCacheKey(bean.getClass(), beanName);
    // 【向提前引用代理池 earlyProxyReferences 中添加该 Bean，防止对象被重新代理】
    this.earlyProxyReferences.put(cacheKey, bean);
    // 创建代理对象，createProxy
    return wrapIfNecessary(bean, beanName, cacheKey);
&#125;
</code></pre>
</li>
<li><p>B 填充了 A 的提前引用后会继续初始化直到完成，<strong>返回原始 A 的逻辑继续执行</strong></p>
</li>
</ul>
<hr>
<h3 id="AOP-2"><a href="#AOP-2" class="headerlink" title="AOP"></a>AOP</h3><h4 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h4><p>@EnableAspectJAutoProxy：AOP 注解驱动，给容器中导入 AspectJAutoProxyRegistrar</p>
<pre><code class="java">@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy &#123;
    // 是否强制使用 CGLIB 创建代理对象 
    // 配置文件方式：&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
    boolean proxyTargetClass() default false;
    
    // 将当前代理对象暴露到上下文内，方便代理对象内部的真实对象拿到代理对象
    // 配置文件方式：&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;/&gt;
    boolean exposeProxy() default false;
&#125;
</code></pre>
<p>AspectJAutoProxyRegistrar 在用来向容器中注册 <strong>AnnotationAwareAspectJAutoProxyCreator</strong>，以 BeanDefiantion 形式存在，在容器初始化时加载。AnnotationAwareAspectJAutoProxyCreator 间接实现了 InstantiationAwareBeanPostProcessor，Order 接口，该类会在 Bean 的实例化和初始化的前后起作用</p>
<p>工作流程：创建 IOC 容器，调用 refresh() 刷新容器，<code>registerBeanPostProcessors(beanFactory)</code> 阶段，通过 getBean() 创建 AnnotationAwareAspectJAutoProxyCreator 对象，在生命周期的初始化方法中执行回调 initBeanFactory() 方法初始化注册三个工具类：BeanFactoryAdvisorRetrievalHelperAdapter、ReflectiveAspectJAdvisorFactory、BeanFactoryAspectJAdvisorsBuilderAdapter</p>
<hr>
<h4 id="后置处理"><a href="#后置处理" class="headerlink" title="后置处理"></a>后置处理</h4><p>Bean 初始化完成的执行后置处理器的方法：</p>
<pre><code class="java">public Object postProcessAfterInitialization(@Nullable Object bean,String bN)&#123;
    if (bean != null) &#123;
        // cacheKey 是 【beanName 或者加上 &amp; 的 beanName】
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
            if (this.earlyProxyReferences.remove(cacheKey) != bean) &#123;
                // 去提前代理引用池中寻找该 key，不存在则创建代理
                // 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理
                return wrapIfNecessary(bean, bN, cacheKey);
            &#125;
    &#125;
    return bean;
&#125;
</code></pre>
<p>AbstractAutoProxyCreator.wrapIfNecessary()：根据通知创建动态代理，没有通知直接返回原实例</p>
<pre><code class="java">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;
    // 条件一般不成立，很少使用 TargetSourceCreator 去创建对象 BeforeInstantiation 阶段，doCreateBean 之前的阶段
    if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;
        return bean;
    &#125;
    // advisedBeans 集合保存的是 bean 是否被增强过了
    // 条件成立说明当前 beanName 对应的实例不需要被增强处理，判断是在 BeforeInstantiation 阶段做的
    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;
        return bean;
    &#125;
    // 条件一：判断当前 bean 类型是否是基础框架类型，这个类的实例不能被增强
    // 条件二：shouldSkip 判断当前 beanName 是否是 .ORIGINAL 结尾，如果是就跳过增强逻辑，直接返回
    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;
        this.advisedBeans.put(cacheKey, Boolean.FALSE);
        return bean;
    &#125;

    // 【查找适合当前 bean 实例的增强方法】（下一节详解）
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
    // 条件成立说明上面方法查询到适合当前class的通知
    if (specificInterceptors != DO_NOT_PROXY) &#123;
        this.advisedBeans.put(cacheKey, Boolean.TRUE);
        // 根据查询到的增强创建代理对象（下一节详解）
        // 参数一：目标对象
        // 参数二：beanName
        // 参数三：匹配当前目标对象 clazz 的 Advisor 数据
        Object proxy = createProxy(
            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
        // 保存代理对象类型
        this.proxyTypes.put(cacheKey, proxy.getClass());
        // 返回代理对象
        return proxy;
    &#125;
    // 执行到这里说明没有查到通知，当前 bean 不需要增强
    this.advisedBeans.put(cacheKey, Boolean.FALSE);
    // 【返回原始的 bean 实例】
    return bean;
&#125;
</code></pre>
<hr>
<h4 id="获取通知"><a href="#获取通知" class="headerlink" title="获取通知"></a>获取通知</h4><p>AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean()：查找适合当前类实例的增强，并进行排序</p>
<pre><code class="java">protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) &#123;
    // 查询适合当前类型的增强通知
    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);
    if (advisors.isEmpty()) &#123;
        // 增强为空直接返回 null，不需要创建代理
        return DO_NOT_PROXY;
    &#125;
    // 不是空，转成数组返回
    return advisors.toArray();
&#125;
</code></pre>
<p>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors()：</p>
<ul>
<li><p><code>candidateAdvisors = findCandidateAdvisors()</code>：<strong>获取当前容器内可以使用（所有）的 advisor</strong>，调用的是 AnnotationAwareAspectJAutoProxyCreator 类的方法，每个方法对应一个 Advisor </p>
<ul>
<li><p><code>advisors = super.findCandidateAdvisors()</code>：<strong>查询出 XML 配置的所有 Advisor 类型</strong></p>
<ul>
<li><code>advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors()</code>：通过 BF 查询出来 BD 配置的 class 中 是 Advisor 子类的 BeanName</li>
<li><code>advisors.add()</code>：使用 Spring 容器获取当前这个 Advisor 类型的实例</li>
</ul>
</li>
<li><p><code>advisors.addAll(....buildAspectJAdvisors())</code>：<strong>获取所有添加 @Aspect 注解类中的 Advisor</strong></p>
<p><code>buildAspectJAdvisors()</code>：构建的方法，<strong>把 Advice 封装成 Advisor</strong></p>
<ul>
<li><p><code> beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false)</code>：获取出容器内 Object 所有的 beanName，就是全部的</p>
</li>
<li><p><code> for (String beanName : beanNames)</code>：遍历所有的 beanName，判断每个 beanName 对应的 Class 是否是 Aspect 类型，就是加了 @Aspect 注解的类</p>
<ul>
<li><p><code>factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName)</code>：使用工厂模式管理 Aspect 的元数据，关联的真实 @Aspect 注解的实例对象</p>
</li>
<li><p><code>classAdvisors = this.advisorFactory.getAdvisors(factory)</code>：添加了 @Aspect 注解的类的通知信息</p>
<ul>
<li><p>aspectClass：@Aspect 标签的类的 class</p>
</li>
<li><p><code>for (Method method : getAdvisorMethods(aspectClass))</code>：遍历<strong>不包括 @Pointcut 注解的方法</strong></p>
<p><code>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName)</code>：<strong>将当前 method 包装成 Advisor 数据</strong></p>
<ul>
<li><p><code>AspectJExpressionPointcut expressionPointcut = getPointcut()</code>：获取切点表达式</p>
</li>
<li><p><code>return new InstantiationModelAwarePointcutAdvisorImpl()</code>：把 method 中 Advice 包装成 Advisor，Spring 中每个 Advisor 内部一定是持有一个 Advice 的，Advice 内部最重要的数据是当前 method 和aspectInstanceFactory，工厂用来获取实例</p>
<p><code>this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut)</code>：实例化 Advice 对象，逻辑是获取注解信息，根据注解的不同生成对应的 Advice 对象</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>advisors.addAll(classAdvisors)</code>：保存通过 @Aspect 注解定义的 Advisor 数据</p>
</li>
</ul>
</li>
<li><p><code>this.aspectBeanNames = aspectNames</code>：将所有 @Aspect 注解 beanName 缓存起来，表示提取 Advisor 工作完成</p>
</li>
<li><p><code>return advisors</code>：返回 Advisor 列表</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, ...)</code>：<strong>选出匹配当前类的增强</strong></p>
<ul>
<li><p><code>if (candidateAdvisors.isEmpty())</code>：条件成立说明当前 Spring 没有可以操作的 Advisor</p>
</li>
<li><p><code>List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;()</code>：存放匹配当前 beanClass 的 Advisors 信息</p>
</li>
<li><p><code>for (Advisor candidate : candidateAdvisors)</code>：<strong>遍历所有的 Advisor</strong></p>
<p><code> if (canApply(candidate, clazz, hasIntroductions))</code>：判断遍历的 advisor 是否匹配当前的 class，匹配就加入集合</p>
<ul>
<li><p><code>if (advisor instanceof PointcutAdvisor)</code>：创建的 advisor 是 InstantiationModelAwarePointcutAdvisorImpl 类型</p>
<p><code>PointcutAdvisor pca = (PointcutAdvisor) advisor</code>：封装当前 Advisor</p>
<p><code>return canApply(pca.getPointcut(), targetClass, hasIntroductions)</code>：重载该方法</p>
<ul>
<li><code>if (!pc.getClassFilter().matches(targetClass))</code>：<strong>类不匹配 Pointcut 表达式，直接返回 false</strong></li>
<li><code>methodMatcher = pc.getMethodMatcher()</code>：<strong>获取 Pointcut 方法匹配器</strong>，类匹配进行类中方法的匹配</li>
<li><code>Set&lt;Class&lt;?&gt;&gt; classes</code>：保存目标对象 class 和目标对象父类超类的接口和自身实现的接口</li>
<li><code>if (!Proxy.isProxyClass(targetClass))</code>：判断当前实例是不是代理类，确保 class 内存储的数据包括目标对象的class  而不是代理类的 class</li>
<li><code>for (Class&lt;?&gt; clazz : classes)</code>：<strong>检查目标 class 和上级接口的所有方法，查看是否会被方法匹配器匹配</strong>，如果有一个方法匹配成功，就说明目标对象 AOP 代理需要增强<ul>
<li><code>specificMethod = AopUtils.getMostSpecificMethod(method, targetClass)</code>：方法可能是接口的，判断当前类有没有该方法</li>
<li><code>return (specificMethod != method &amp;&amp; matchesMethod(specificMethod))</code>：<strong>类和方法的匹配</strong>，不包括参数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>extendAdvisors(eligibleAdvisors)</code>：在 eligibleAdvisors 列表的索引 0 的位置添加 DefaultPointcutAdvisor，<strong>封装了 ExposeInvocationInterceptor 拦截器</strong></p>
</li>
<li><p><code> eligibleAdvisors = sortAdvisors(eligibleAdvisors)</code>：<strong>对拦截器进行排序</strong>，数值越小优先级越高，高的排在前面</p>
<ul>
<li>实现 Ordered 或 PriorityOrdered 接口，PriorityOrdered 的级别要优先于 Ordered，使用 OrderComparator 比较器</li>
<li>使用 @Order（Spring 规范）或 @Priority（JDK 规范）注解，使用 AnnotationAwareOrderComparator 比较器</li>
<li>ExposeInvocationInterceptor 实现了 PriorityOrdered ，所以总是排在第一位，MethodBeforeAdviceInterceptor 没实现任何接口，所以优先级最低，排在最后</li>
</ul>
</li>
<li><p><code>return eligibleAdvisors</code>：返回拦截器链</p>
</li>
</ul>
<hr>
<h4 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h4><p>AbstractAutoProxyCreator.createProxy()：根据增强方法创建代理对象</p>
<ul>
<li><p><code>ProxyFactory proxyFactory = new ProxyFactory()</code>：<strong>无参构造 ProxyFactory</strong>，此处讲解一下两种有参构造方法：</p>
<ul>
<li><p>public ProxyFactory(Object target)：</p>
<pre><code class="java">public ProxyFactory(Object target) &#123;
    // 将目标对象封装成 SingletonTargetSource 保存到父类的字段中
       setTarget(target);
    // 获取目标对象 class 所有接口保存到 AdvisedSupport 中的 interfaces 集合中
       setInterfaces(ClassUtils.getAllInterfaces(target));
&#125;
</code></pre>
<p>ClassUtils.getAllInterfaces(target) 底层调用 getAllInterfacesForClassAsSet(java.lang.Class&lt;?&gt;, java.lang.ClassLoader)：</p>
<ul>
<li><code>if (clazz.isInterface() &amp;&amp; isVisible(clazz, classLoader))</code>：<ul>
<li>条件一：判断当前目标对象是接口</li>
<li>条件二：检查给定的类在给定的 ClassLoader 中是否可见</li>
</ul>
</li>
<li><code>Class&lt;?&gt;[] ifcs = current.getInterfaces()</code>：拿到自己实现的接口，拿不到接口实现的接口</li>
<li><code>current = current.getSuperclass()</code>：递归寻找父类的接口，去获取父类实现的接口</li>
</ul>
</li>
<li><p>public ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)：</p>
<pre><code class="java">public ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor) &#123;
    // 添加一个代理的接口
    addInterface(proxyInterface);
    // 添加通知，底层调用 addAdvisor
    addAdvice(interceptor);
&#125;
</code></pre>
<ul>
<li><code>addAdvisor(pos, new DefaultPointcutAdvisor(advice))</code>：Spring 中 Advice 对应的接口就是 Advisor，Spring 使用 Advisor 包装 Advice 实例</li>
</ul>
</li>
</ul>
</li>
<li><p><code>proxyFactory.copyFrom(this)</code>：填充一些信息到 proxyFactory</p>
</li>
<li><p><code>if (!proxyFactory.isProxyTargetClass())</code>：条件成立说明 proxyTargetClass 为 false（默认），两种配置方法：</p>
<ul>
<li><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; </code>：强制使用 CGLIB</li>
<li><code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code></li>
</ul>
<p><code>if (shouldProxyTargetClass(beanClass, beanName))</code>：如果 bd 内有 preserveTargetClass &#x3D; true ，那么这个 bd 对应的 class <strong>创建代理时必须使用 CGLIB</strong>，条件成立设置 proxyTargetClass 为 true</p>
<p><code>evaluateProxyInterfaces(beanClass, proxyFactory)</code>：<strong>根据目标类判定是否可以使用 JDK 动态代理</strong></p>
<ul>
<li><code>targetInterfaces = ClassUtils.getAllInterfacesForClass()</code>：获取当前目标对象 class 和父类的全部实现接口</li>
<li><code>boolean hasReasonableProxyInterface = false</code>：实现的接口中是否有一个合理的接口</li>
<li><code>if (!isConfigurationCallbackInterface(ifc) &amp;&amp; !isInternalLanguageInterface(ifc) &amp;&amp; ifc.getMethods().length &gt; 0)</code>：遍历所有的接口，如果有任意一个接口满足条件，设置 hRPI 变量为 true<ul>
<li>条件一：判断当前接口是否是 Spring 生命周期内会回调的接口</li>
<li>条件二：接口不能是 GroovyObject、Factory、MockAccess 类型的</li>
<li>条件三：找到一个可以使用的被代理的接口</li>
</ul>
</li>
<li><code>if (hasReasonableProxyInterface)</code>：<strong>有合理的接口，将这些接口设置到 proxyFactory 内</strong></li>
<li><code>proxyFactory.setProxyTargetClass(true)</code>：<strong>没有合理的代理接口，强制使用 CGLIB 创建对象</strong></li>
</ul>
</li>
<li><p><code>advisors = buildAdvisors(beanName, specificInterceptors)</code>：匹配目标对象 clazz 的 Advisors，填充至 ProxyFactory</p>
</li>
<li><p><code>proxyFactory.setPreFiltered(true)</code>：设置为 true 表示传递给 proxyFactory 的 Advisors 信息做过基础类和方法的匹配</p>
</li>
<li><p><code>return proxyFactory.getProxy(getProxyClassLoader())</code>：创建代理对象</p>
<pre><code class="java">public Object getProxy() &#123;
    return createAopProxy().getProxy();
&#125;
</code></pre>
<p>DefaultAopProxyFactory.createAopProxy(AdvisedSupport config)：参数是一个配置对象，保存着创建代理需要的生产资料，会加锁创建，保证线程安全</p>
<pre><code class="java">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;
    // 条件二为 true 代表强制使用 CGLIB 动态代理
    if (config.isOptimize() || config.isProxyTargetClass() || 
        // 条件三：被代理对象没有实现任何接口或者只实现了 SpringProxy 接口，只能使用 CGLIB 动态代理
        hasNoUserSuppliedProxyInterfaces(config)) &#123;
        Class&lt;?&gt; targetClass = config.getTargetClass();
        if (targetClass == null) &#123;
            throw new AopConfigException(&quot;&quot;);
        &#125;
        // 条件成立说明 target 【是接口或者是已经被代理过的类型】，只能使用 JDK 动态代理
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;
            return new JdkDynamicAopProxy(config);    // 使用 JDK 动态代理
        &#125;
        return new ObjenesisCglibAopProxy(config);    // 使用 CGLIB 动态代理
    &#125;
    else &#123;
        return new JdkDynamicAopProxy(config);        // 【有接口的情况下只能使用 JDK 动态代理】
    &#125;
&#125;
</code></pre>
<p>JdkDynamicAopProxy.getProxy(java.lang.ClassLoader)：获取 JDK 的代理对象</p>
<pre><code class="java">  public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException &#123;
      // 配置类封装到 JdkDynamicAopProxy.advised 属性中
      this.advised = config;
  &#125;
  public Object getProxy(@Nullable ClassLoader classLoader) &#123;
      // 获取需要代理的接口数组
      Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
      
      // 查找当前所有的需要代理的接口，看是否有 equals 方法和 hashcode 方法，如果有就做一个标记
      findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
      
      // 该方法最终返回一个代理类对象
      return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
      // classLoader：类加载器  proxiedInterfaces：生成的代理类，需要实现的接口集合
      // this JdkDynamicAopProxy 实现了 InvocationHandler
  &#125;
</code></pre>
<p>AopProxyUtils.completeProxiedInterfaces(this.advised, true)：获取代理的接口数组，并添加 SpringProxy 接口</p>
<ul>
<li><p><code>specifiedInterfaces = advised.getProxiedInterfaces()</code>：从 ProxyFactory 中拿到所有的 target 提取出来的接口</p>
<ul>
<li><code>if (specifiedInterfaces.length == 0)</code>：如果没有实现接口，检查当前 target 是不是接口或者已经是代理类，封装到 ProxyFactory 的 interfaces 集合中</li>
</ul>
</li>
<li><p><code> addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)</code>：判断目标对象所有接口中是否有 SpringProxy 接口，没有的话需要添加，这个接口<strong>标识这个代理类型是 Spring 管理的</strong></p>
<ul>
<li><code>addAdvised = !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)</code>：判断目标对象的所有接口，是否已经有 Advised 接口</li>
<li><code> addDecoratingProxy = (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class))</code>：判断目标对象的所有接口，是否已经有 DecoratingProxy 接口</li>
<li><code>int nonUserIfcCount = 0</code>：非用户自定义的接口数量，接下来要添加上面的三个接口了</li>
<li><code>proxiedInterfaces = new Class&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount]</code>：创建一个新的 class 数组，长度是原目标对象提取出来的接口数量和 Spring 追加的数量，然后进行 <strong>System.arraycopy 拷贝到新数组中</strong></li>
<li><code>int index = specifiedInterfaces.length</code>：获取原目标对象提取出来的接口数量，当作 index</li>
<li><code>if(addSpringProxy)</code>：根据上面三个布尔值把接口添加到新数组中</li>
<li><code>return proxiedInterfaces</code>：返回追加后的接口集合</li>
</ul>
</li>
</ul>
<p>JdkDynamicAopProxy.findDefinedEqualsAndHashCodeMethods()：查找在任何定义在接口中的 equals 和 hashCode 方法</p>
<ul>
<li><code>for (Class&lt;?&gt; proxiedInterface : proxiedInterfaces)</code>：遍历所有的接口<ul>
<li><p><code> Method[] methods = proxiedInterface.getDeclaredMethods()</code>：获取接口中的所有方法</p>
</li>
<li><p><code>for (Method method : methods)</code>：遍历所有的方法</p>
<ul>
<li><code>if (AopUtils.isEqualsMethod(method))</code>：当前方法是 equals 方法，把 equalsDefined 置为 true</li>
<li><code>if (AopUtils.isHashCodeMethod(method))</code>：当前方法是 hashCode 方法，把 hashCodeDefined 置为 true</li>
</ul>
</li>
<li><p><code>if (this.equalsDefined &amp;&amp; this.hashCodeDefined)</code>：如果有一个接口中有这两种方法，直接返回</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="方法增强"><a href="#方法增强" class="headerlink" title="方法增强"></a>方法增强</h4><p>main() 函数中调用用户方法，会进入代理对象的 invoke 方法</p>
<p>JdkDynamicAopProxy 类中的 invoke 方法是真正执行代理方法</p>
<pre><code class="java">// proxy：代理对象，method：目标对象的方法，args：目标对象方法对应的参数
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
    Object oldProxy = null;
    boolean setProxyContext = false;

    // advised 就是初始化 JdkDynamicAopProxy 对象时传入的变量
    TargetSource targetSource = this.advised.targetSource;
    Object target = null;

    try &#123;
        // 条件成立说明代理类实现的接口没有定义 equals 方法，并且当前 method 调用 equals 方法，
        // 就调用 JdkDynamicAopProxy 提供的 equals 方法
        if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;
            return equals(args[0]);
        &#125; //.....

        Object retVal;
        // 需不需要暴露当前代理对象到 AOP 上下文内
        if (this.advised.exposeProxy) &#123;
            // 【把代理对象设置到上下文环境】
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        &#125;

        // 根据 targetSource 获取真正的代理对象
        target = targetSource.getTarget();
        Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);

        // 查找【适合该方法的增强】，首先从缓存中查找，查找不到进入主方法【下文详解】
        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // 拦截器链是空，说明当前 method 不需要被增强
        if (chain.isEmpty()) &#123;
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
        &#125;
        else &#123;
            // 有匹配当前 method 的方法拦截器，要做增强处理，把方法信息封装到方法调用器里
            MethodInvocation invocation =
                new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            // 【拦截器链驱动方法，核心】
            retVal = invocation.proceed();
        &#125;

        Class&lt;?&gt; returnType = method.getReturnType();
        if (retVal != null &amp;&amp; retVal == target &amp;&amp;
            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;
            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;
              // 如果目标方法返回目标对象，这里做个普通替换返回代理对象
            retVal = proxy;
        &#125;
        
        // 返回执行的结果
        return retVal;
    &#125;
    finally &#123;
        if (target != null &amp;&amp; !targetSource.isStatic()) &#123;
            targetSource.releaseTarget(target);
        &#125;
        // 如果允许了提前暴露，这里需要设置为初始状态
        if (setProxyContext) &#123;
            // 当前代理对象已经完成工作，【把原始对象设置回上下文】
            AopContext.setCurrentProxy(oldProxy);
        &#125;
    &#125;
&#125;
</code></pre>
<p>this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)：查找适合该方法的增强，首先从缓存中查找，获取通知时是从全部增强中获取适合当前类的，这里是<strong>从当前类的中获取适合当前方法的增强</strong></p>
<ul>
<li><p><code>AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance()</code>：向容器注册适配器，<strong>可以将非 Advisor 类型的增强，包装成为 Advisor，将 Advisor 类型的增强提取出来对应的 MethodInterceptor</strong></p>
<ul>
<li><p><code>instance = new DefaultAdvisorAdapterRegistry()</code>：该对象向容器中注册了 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter 三个适配器</p>
</li>
<li><p>Advisor 中持有 Advice 对象</p>
<pre><code class="java">public interface Advisor &#123;
    Advice getAdvice();
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><code>advisors = config.getAdvisors()</code>：获取 ProxyFactory 内部持有的增强信息</p>
</li>
<li><p><code>interceptorList = new ArrayList&lt;&gt;(advisors.length)</code>：拦截器列表有 5 个，1 个 ExposeInvocation和 4 个增强器</p>
</li>
<li><p><code>actualClass = (targetClass != null ? targetClass : method.getDeclaringClass())</code>：真实的目标对象类型</p>
</li>
<li><p><code>Boolean hasIntroductions = null</code>：引介增强，不关心</p>
</li>
<li><p><code>for (Advisor advisor : advisors)</code>：<strong>遍历所有的 advisor 增强</strong></p>
</li>
<li><p><code>if (advisor instanceof PointcutAdvisor)</code>：条件成立说明当前 Advisor 是包含切点信息的，进入匹配逻辑</p>
<p><code>pointcutAdvisor = (PointcutAdvisor) advisor</code>：转成可以获取到切点信息的接口</p>
<p><code>if(config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass))</code>：当前代理被预处理，或者当前被代理的 class 对象匹配当前 Advisor 成功，只是 class 匹配成功</p>
<ul>
<li><p><code>mm = pointcutAdvisor.getPointcut().getMethodMatcher()</code>：获取切点的方法匹配器，不考虑引介增强</p>
</li>
<li><p><code>match = mm.matches(method, actualClass)</code>：<strong>静态匹配成功返回 true，只关注于处理类及其方法，不考虑参数</strong></p>
</li>
<li><p><code>if (match)</code>：如果静态切点检查是匹配的，在运行的时候才进行<strong>动态切点检查，会考虑参数匹配</strong>（代表传入了参数）。如果静态匹配失败，直接不需要进行参数匹配，提高了工作效率</p>
<p><code>interceptors = registry.getInterceptors(advisor)</code>：提取出当前 advisor 内持有的 advice 信息 </p>
<ul>
<li><p><code>Advice advice = advisor.getAdvice()</code>：获取增强方法</p>
</li>
<li><p><code>if (advice instanceof MethodInterceptor)</code>：当前 advice 是 MethodInterceptor 直接加入集合</p>
</li>
<li><p><code>for (AdvisorAdapter adapter : this.adapters)</code>：<strong>遍历三个适配器进行匹配</strong>（初始化时创建的），匹配成功创建对应的拦截器返回，以 MethodBeforeAdviceAdapter 为例</p>
<p><code>if (adapter.supportsAdvice(advice))</code>：判断当前 advice 是否是对应的 MethodBeforeAdvice</p>
<p><code>interceptors.add(adapter.getInterceptor(advisor))</code>：条件成立就往拦截器链中添加 advisor</p>
<ul>
<li><code>advice = (MethodBeforeAdvice) advisor.getAdvice()</code>：<strong>获取增强方法</strong></li>
<li><code>return new MethodBeforeAdviceInterceptor(advice)</code>：<strong>封装成 MethodBeforeAdviceInterceptor 返回</strong></li>
</ul>
</li>
</ul>
<p><code>interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm))</code>：向拦截器链添加动态匹配器</p>
<p><code>interceptorList.addAll(Arrays.asList(interceptors))</code>：将当前 advisor 内部的方法拦截器追加到 interceptorList</p>
</li>
</ul>
</li>
<li><p><code>interceptors = registry.getInterceptors(advisor)</code>：进入 else 的逻辑，说明当前 Advisor 匹配全部 class 的全部 method，全部加入到 interceptorList</p>
</li>
<li><p><code>return interceptorList</code>：返回 method 方法的拦截器链</p>
</li>
</ul>
<p>retVal &#x3D; invocation.proceed()：<strong>拦截器链驱动方法</strong></p>
<ul>
<li><p><code>if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1)</code>：条件成立说明方法拦截器全部都已经调用过了（index 从 - 1 开始累加），接下来需要执行目标对象的目标方法</p>
<p><code>return invokeJoinpoint()</code>：<strong>调用连接点（目标）方法</strong></p>
</li>
<li><p><code>this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)</code>：<strong>获取下一个方法拦截器</strong></p>
</li>
<li><p><code>if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)</code>：需要运行时匹配</p>
<p><code>if (dm.methodMatcher.matches(this.method, targetClass, this.arguments))</code>：判断是否匹配成功</p>
<ul>
<li><code>return dm.interceptor.invoke(this)</code>：匹配成功，执行方法</li>
<li><code>return proceed()</code>：匹配失败跳过当前拦截器</li>
</ul>
</li>
<li><p><code>return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)</code>：<strong>一般方法拦截器都会执行到该方法，此方法内继续执行 proceed() 完成责任链的驱动，直到最后一个  MethodBeforeAdviceInterceptor 调用前置通知，然后调用 mi.proceed()，发现是最后一个拦截器就直接执行连接点（目标方法），return 到上一个拦截器的 mi.proceed() 处，依次返回到责任链的上一个拦截器执行通知方法</strong></p>
</li>
</ul>
<p>图示先从上往下建立链，然后从下往上依次执行，责任链模式</p>
<ul>
<li><p>正常执行：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 返回通知</p>
</li>
<li><p>出现异常：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 异常通知</p>
</li>
<li><p>MethodBeforeAdviceInterceptor 源码：</p>
<pre><code class="java">public Object invoke(MethodInvocation mi) throws Throwable &#123;
    // 先执行通知方法，再驱动责任链
    this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
    // 开始驱动目标方法执行，执行完后返回到这，然后继续向上层返回
    return mi.proceed();
&#125;
</code></pre>
<p>AfterReturningAdviceInterceptor 源码：没有任何异常处理机制，直接抛给上层</p>
<pre><code class="java">public Object invoke(MethodInvocation mi) throws Throwable &#123;
    // 先驱动责任链，再执行通知方法
    Object retVal = mi.proceed();
    this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
    return retVal;
&#125;
</code></pre>
<p>AspectJAfterThrowingAdvice 执行异常处理：</p>
<pre><code class="java">public Object invoke(MethodInvocation mi) throws Throwable &#123;
    try &#123;
        // 默认直接驱动责任链
        return mi.proceed();
    &#125;
    catch (Throwable ex) &#123;
        // 出现错误才执行该方法
        if (shouldInvokeOnThrowing(ex)) &#123;
            invokeAdviceMethod(getJoinPointMatch(), null, ex);
        &#125;
        throw ex;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W7wy">https://www.bilibili.com/video/BV1gW411W7wy</a></p>
<hr>
<h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><h4 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h4><h5 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h5><pre><code class="xml">&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;
</code></pre>
<p>容器启动时会根据注解注册对应的解析器：</p>
<pre><code class="java">public class TxNamespaceHandler extends NamespaceHandlerSupport &#123;
    public void init() &#123;
        registerBeanDefinitionParser(&quot;advice&quot;, new TxAdviceBeanDefinitionParser());
        // 注册解析器
        registerBeanDefinitionParser(&quot;annotation-driven&quot;, new AnnotationDrivenBeanDefinitionParser());
        registerBeanDefinitionParser(&quot;jta-transaction-manager&quot;, new JtaTransactionManagerBeanDefinitionParser());
    &#125;
&#125;
protected final void registerBeanDefinitionParser(String elementName, BeanDefinitionParser parser) &#123;
    this.parsers.put(elementName, parser);
&#125;
</code></pre>
<p>获取对应的解析器 NamespaceHandlerSupport#findParserForElement：</p>
<pre><code class="java">private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123;
    String localName = parserContext.getDelegate().getLocalName(element);
    // 获取对应的解析器
    BeanDefinitionParser parser = this.parsers.get(localName);
    // ...
    return parser;
&#125;
</code></pre>
<p>调用解析器的方法对 XML 文件进行解析：</p>
<pre><code class="java">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;
    // 向Spring容器注册了一个 BD -&gt; TransactionalEventListenerFactory.class
    registerTransactionalEventListenerFactory(parserContext);
    String mode = element.getAttribute(&quot;mode&quot;);
    if (&quot;aspectj&quot;.equals(mode)) &#123;
        // mode=&quot;aspectj&quot;
        registerTransactionAspect(element, parserContext);
        if (ClassUtils.isPresent(&quot;javax.transaction.Transactional&quot;, getClass().getClassLoader())) &#123;
            registerJtaTransactionAspect(element, parserContext);
        &#125;
    &#125;
    else &#123;
        // mode=&quot;proxy&quot;，默认逻辑，不配置 mode 时
        // 用来向容器中注入一些 BeanDefinition，包括事务增强器、事务拦截器、注解解析器
        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);
    &#125;
    return null;
&#125;
</code></pre>
<hr>
<h5 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h5><p>@EnableTransactionManagement 导入 TransactionManagementConfigurationSelector，该类给 Spring 容器中两个组件：</p>
<pre><code class="java">protected String[] selectImports(AdviceMode adviceMode) &#123;
    switch (adviceMode) &#123;
        // 导入 AutoProxyRegistrar 和 ProxyTransactionManagementConfiguration（默认）
        case PROXY:
            return new String[] &#123;AutoProxyRegistrar.class.getName(),
                                 ProxyTransactionManagementConfiguration.class.getName()&#125;;
        // 导入 AspectJTransactionManagementConfiguration（与声明式事务无关）
        case ASPECTJ:
            return new String[] &#123;determineTransactionAspectClass()&#125;;
        default:
            return null;
    &#125;
&#125;
</code></pre>
<p>AutoProxyRegistrar：给容器中注册 InfrastructureAdvisorAutoProxyCreator，<strong>利用后置处理器机制拦截 bean 以后包装并返回一个代理对象</strong>，代理对象中保存所有的拦截器，利用拦截器的链式机制依次进入每一个拦截器中进行拦截执行（就是 AOP 原理）</p>
<p>ProxyTransactionManagementConfiguration：是一个 Spring 的事务配置类，注册了三个 Bean：</p>
<ul>
<li>BeanFactoryTransactionAttributeSourceAdvisor：事务驱动，利用注解 @Bean 把该类注入到容器中，该增强器有两个字段：</li>
<li>TransactionAttributeSource：解析事务注解的相关信息，真实类型是 AnnotationTransactionAttributeSource，构造方法中注册了三个<strong>注解解析器</strong>，解析 Spring、JTA、Ejb3 三种类型的事务注解</li>
<li>TransactionInterceptor：<strong>事务拦截器</strong>，代理对象执行拦截器方法时，调用 TransactionInterceptor 的 invoke 方法，底层调用TransactionAspectSupport.invokeWithinTransaction()，通过 PlatformTransactionManager 控制着事务的提交和回滚，所以事务的底层原理就是通过 AOP 动态织入，进行事务开启和提交</li>
</ul>
<p>注解解析器 SpringTransactionAnnotationParser <strong>解析 @Transactional 注解</strong>：</p>
<pre><code class="java">protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) &#123;
    RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();
    // 从注解信息中获取传播行为
    Propagation propagation = attributes.getEnum(&quot;propagation&quot;);
    rbta.setPropagationBehavior(propagation.value());
    // 获取隔离界别
    Isolation isolation = attributes.getEnum(&quot;isolation&quot;);
    rbta.setIsolationLevel(isolation.value());
    rbta.setTimeout(attributes.getNumber(&quot;timeout&quot;).intValue());
    // 从注解信息中获取 readOnly 参数
    rbta.setReadOnly(attributes.getBoolean(&quot;readOnly&quot;));
    // 从注解信息中获取 value 信息并且设置 qualifier，表示当前事务指定使用的【事务管理器】
    rbta.setQualifier(attributes.getString(&quot;value&quot;));
    // 【存放的是 rollback 条件】，回滚规则放在这个集合
    List&lt;RollbackRuleAttribute&gt; rollbackRules = new ArrayList&lt;&gt;();
    // 表示事务碰到哪些指定的异常才进行回滚，不指定的话默认是 RuntimeException/Error 非检查型异常菜回滚
    for (Class&lt;?&gt; rbRule : attributes.getClassArray(&quot;rollbackFor&quot;)) &#123;
        rollbackRules.add(new RollbackRuleAttribute(rbRule));
    &#125;
    // 与 rollbackFor 功能相同
    for (String rbRule : attributes.getStringArray(&quot;rollbackForClassName&quot;)) &#123;
        rollbackRules.add(new RollbackRuleAttribute(rbRule));
    &#125;
    // 表示事务碰到指定的 exception 实现对象不进行回滚，否则碰到其他的class就进行回滚
    for (Class&lt;?&gt; rbRule : attributes.getClassArray(&quot;noRollbackFor&quot;)) &#123;
        rollbackRules.add(new NoRollbackRuleAttribute(rbRule));
    &#125;
    for (String rbRule : attributes.getStringArray(&quot;noRollbackForClassName&quot;)) &#123;
        rollbackRules.add(new NoRollbackRuleAttribute(rbRule));
    &#125;
    // 设置回滚规则
    rbta.setRollbackRules(rollbackRules);

    return rbta;
&#125;
</code></pre>
<hr>
<h4 id="驱动方法"><a href="#驱动方法" class="headerlink" title="驱动方法"></a>驱动方法</h4><p>TransactionInterceptor 事务拦截器的核心驱动方法：</p>
<pre><code class="java">public Object invoke(MethodInvocation invocation) throws Throwable &#123;
    // targetClass 是需要被事务增强器增强的目标类，invocation.getThis() → 目标对象 → 目标类
    Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);
    // 参数一是目标方法，参数二是目标类，参数三是方法引用，用来触发驱动方法
    return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
&#125;

protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,
                                         final InvocationCallback invocation) throws Throwable &#123;

    // 事务属性源信息
    TransactionAttributeSource tas = getTransactionAttributeSource();
    //  提取 @Transactional 注解信息，txAttr 是注解信息的承载对象
    final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
    // 获取 Spring 配置的事务管理器
    // 首先会检查是否通过XML或注解配置 qualifier，没有就尝试去容器获取，一般情况下为 DatasourceTransactionManager
    final PlatformTransactionManager tm = determineTransactionManager(txAttr);
    // 权限定类名.方法名，该值用来当做事务名称使用
    final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);
    
    // 条件成立说明是【声明式事务】
    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;
        // 用来【开启事务】
        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);

        Object retVal;
        try &#123;
            // This is an 【around advice】: Invoke the next interceptor in the chain.
            // 环绕通知，执行目标方法（方法引用方式，invocation::proceed，还是调用 proceed）
            retVal = invocation.proceedWithInvocation();
        &#125;
        catch (Throwable ex) &#123;
            //  执行业务代码时抛出异常，执行回滚逻辑
            completeTransactionAfterThrowing(txInfo, ex);
            throw ex;
        &#125;
        finally &#123;
            // 清理事务的信息
            cleanupTransactionInfo(txInfo);
        &#125;
        // 提交事务的入口
        commitTransactionAfterReturning(txInfo);
        return retVal;
    &#125;
    else &#123;
       // 编程式事务，省略
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><h5 id="事务绑定"><a href="#事务绑定" class="headerlink" title="事务绑定"></a>事务绑定</h5><p>创建事务的方法：</p>
<pre><code class="java">protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
                                                       @Nullable TransactionAttribute txAttr, 
                                                       final String joinpointIdentification) &#123;

    // If no name specified, apply method identification as transaction name.
    if (txAttr != null &amp;&amp; txAttr.getName() == null) &#123;
        // 事务的名称： 类的权限定名.方法名
        txAttr = new DelegatingTransactionAttribute(txAttr) &#123;
            @Override
            public String getName() &#123;
                return joinpointIdentification;
            &#125;
        &#125;;
    &#125;
    TransactionStatus status = null;
    if (txAttr != null) &#123;
        if (tm != null) &#123;
            // 通过事务管理器根据事务属性创建事务状态对象，事务状态对象一般情况下包装着 事务对象，当然也有可能是null
            // 方法上的注解为 @Transactional(propagation = NOT_SUPPORTED || propagation = NEVER) 时
            // 【下一小节详解】
            status = tm.getTransaction(txAttr);
        &#125;
        else &#123;
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification +
                             &quot;] because no transaction manager has been configured&quot;);
            &#125;
        &#125;
    &#125;
    // 包装成一个上层的事务上下文对象
    return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
&#125;
</code></pre>
<p>TransactionAspectSupport#prepareTransactionInfo：为事务的属性和状态准备一个事务信息对象</p>
<ul>
<li><code>TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification)</code>：创建事务信息对象</li>
<li><code>txInfo.newTransactionStatus(status)</code>：填充事务的状态信息</li>
<li><code>txInfo.bindToThread()</code>：利用 ThreadLocal <strong>把当前事务信息绑定到当前线程</strong>，不同的事务信息会形成一个栈的结构<ul>
<li><code>this.oldTransactionInfo = transactionInfoHolder.get()</code>：获取其他事务的信息存入 oldTransactionInfo </li>
<li><code>transactionInfoHolder.set(this)</code>：将当前的事务信息设置到 ThreadLocalMap 中</li>
</ul>
</li>
</ul>
<hr>
<h5 id="事务创建"><a href="#事务创建" class="headerlink" title="事务创建"></a>事务创建</h5><pre><code class="java">public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123;
    // 获取事务的对象
    Object transaction = doGetTransaction();
    boolean debugEnabled = logger.isDebugEnabled();

    if (definition == null) &#123;
        // Use defaults if no transaction definition given.
        definition = new DefaultTransactionDefinition();
    &#125;
    // 条件成立说明当前是事务重入的情况，事务中有 ConnectionHolder 对象
    if (isExistingTransaction(transaction)) &#123;
        // a方法开启事务，a方法内调用b方法，b方法仍然加了 @Transactional 注解，需要检查传播行为
        return handleExistingTransaction(definition, transaction, debugEnabled);
    &#125;
    
    // 逻辑到这说明当前线程没有连接资源，一个连接对应一个事务，没有连接就相当于没有开启事务
    // 检查事务的延迟属性
    if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;
        throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());
    &#125;

    // 传播行为是 MANDATORY，没有事务就抛出异常
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;
        throw new IllegalTransactionStateException();
    &#125;
    // 需要开启事务的传播行为
    else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;
        // 什么也没挂起，因为线程并没有绑定事务
        SuspendedResourcesHolder suspendedResources = suspend(null);
        try &#123;
            // 是否支持同步线程事务，一般是 true
            boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
            // 新建一个事务状态信息
            DefaultTransactionStatus status = newTransactionStatus(
                definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
            // 【启动事务】
            doBegin(transaction, definition);
            // 设置线程上下文变量，方便程序运行期间获取当前事务的一些核心的属性，initSynchronization() 启动同步
            prepareSynchronization(status, definition);
            return status;
        &#125;
        catch (RuntimeException | Error ex) &#123;
            // 恢复现场
            resume(null, suspendedResources);
            throw ex;
        &#125;
    &#125;
    // 不支持事务的传播行为
    else &#123;
        // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        // 创建事务状态对象
        // 参数2 transaction 是 null 说明当前事务状态是未手动开启事，线程上未绑定任何的连接资源，业务程序执行时需要先去 datasource 获取的 conn，是自动提交事务的，不需要 Spring 再提交事务
        // 参数6 suspendedResources 是 null 说明当前事务状态未挂起任何事务，当前事务执行到后置处理时不需要恢复现场
        return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);
    &#125;
&#125;
</code></pre>
<p>DataSourceTransactionManager#doGetTransaction：真正获取事务的方法</p>
<ul>
<li><p><code>DataSourceTransactionObject txObject = new DataSourceTransactionObject()</code>：<strong>创建事务对象</strong></p>
</li>
<li><p><code>txObject.setSavepointAllowed(isNestedAllowed())</code>：设置事务对象是否支持保存点，由事务管理器控制（默认不支持）</p>
</li>
<li><p><code>ConnectionHolder conHolder = TransactionSynchronizationManager.getResource(obtainDataSource())</code>：</p>
<ul>
<li><p>从 ThreadLocal 中获取 conHolder 资源，可能拿到 null 或者不是 null</p>
</li>
<li><p>是 null：举例</p>
<pre><code class="java">@Transaction
public void a() &#123;...b.b()....&#125;
</code></pre>
</li>
<li><p>不是 null：执行 b 方法事务增强的前置逻辑时，可以拿到 a 放进去的 conHolder 资源</p>
<pre><code class="java">@Transaction
public void b() &#123;....&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><code>txObject.setConnectionHolder(conHolder, false)</code>：将 ConnectionHolder 保存到事务对象内，参数二是 false 代表连接资源是上层事务共享的，不是新建的连接资源</p>
</li>
<li><p><code>return txObject</code>：返回事务的对象</p>
</li>
</ul>
<p>DataSourceTransactionManager#doBegin：事务开启的逻辑</p>
<ul>
<li><p><code>txObject = (DataSourceTransactionObject) transaction</code>：强转为事务对象</p>
</li>
<li><p>事务中没有数据库连接资源就要分配：</p>
<p><code>Connection newCon = obtainDataSource().getConnection()</code>：<strong>获取 JDBC 原生的数据库连接对象</strong></p>
<p><code>txObject.setConnectionHolder(new ConnectionHolder(newCon), true)</code>：代表是新开启的事务，新建的连接对象</p>
</li>
<li><p><code>previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)</code>：修改连接属性</p>
<ul>
<li><p><code>if (definition != null &amp;&amp; definition.isReadOnly())</code>：注解（或 XML）配置了只读属性，需要设置</p>
</li>
<li><p><code>if (..definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT)</code>：注解配置了隔离级别</p>
<p><code>int currentIsolation = con.getTransactionIsolation()</code>：获取连接的隔离界别</p>
<p><code>previousIsolationLevel = currentIsolation</code>：保存之前的隔离界别，返回该值</p>
<p><code> con.setTransactionIsolation(definition.getIsolationLevel())</code>：<strong>将当前连接设置为配置的隔离界别</strong></p>
</li>
</ul>
</li>
<li><p><code>txObject.setPreviousIsolationLevel(previousIsolationLevel)</code>：将 Conn 原来的隔离级别保存到事务对象，为了释放 Conn 时重置回原状态</p>
</li>
<li><p><code>if (con.getAutoCommit())</code>：默认会成立，说明还没开启事务</p>
<p><code>txObject.setMustRestoreAutoCommit(true)</code>：保存 Conn 原来的事务状态</p>
<p><code>con.setAutoCommit(false)</code>：<strong>开启事务，JDBC 原生的方式</strong></p>
</li>
<li><p><code>txObject.getConnectionHolder().setTransactionActive(true)</code>：表示 Holder 持有的 Conn 已经手动开启事务了</p>
</li>
<li><p><code>TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder())</code>：将 ConnectionHolder 对象绑定到 ThreadLocal 内，数据源为 key，为了方便获取手动开启事务的连接对象去执行 SQL</p>
</li>
</ul>
<hr>
<h5 id="事务重入"><a href="#事务重入" class="headerlink" title="事务重入"></a>事务重入</h5><p>事务重入的核心处理逻辑：</p>
<pre><code class="java">private TransactionStatus handleExistingTransaction( TransactionDefinition definition, 
                                                    Object transaction, boolean debugEnabled)&#123;
    // 传播行为是 PROPAGATION_NEVER，需要以非事务方式执行操作，如果当前事务存在则【抛出异常】
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;
        throw new IllegalTransactionStateException();
    &#125;
    // 传播行为是 PROPAGATION_NOT_SUPPORTED，以非事务方式运行，如果当前存在事务，则【把当前事务挂起】
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;
        // 挂起事务
        Object suspendedResources = suspend(transaction);
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        // 创建一个非事务的事务状态对象返回
        return prepareTransactionStatus(definition, null, false, newSynchronization, debugEnabled, suspendedResources);
    &#125;
    // 开启新事物的逻辑
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;
        // 【挂起当前事务】
        SuspendedResourcesHolder suspendedResources = suspend(transaction);
           // 【开启新事物】
    &#125;
    // 传播行为是 PROPAGATION_NESTED，嵌套事务
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;
        // Spring 默认不支持内嵌事务
        // 【开启方式】：&lt;property name=&quot;nestedTransactionAllowed&quot; value=&quot;true&quot;&gt;
        if (!isNestedTransactionAllowed()) &#123;
            throw new NestedTransactionNotSupportedException();
        &#125;
        
        if (useSavepointForNestedTransaction()) &#123;
            //  为当前方法创建一个 TransactionStatus 对象，
            DefaultTransactionStatus status =
                prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);
            // 创建一个 JDBC 的保存点
            status.createAndHoldSavepoint();
            // 不需要使用同步，直接返回
            return status;
        &#125;
        else &#123;
            // Usually only for JTA transaction，开启一个新事务
        &#125;
    &#125;

    // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED，【使用当前的事务】
    boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
    return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);
&#125;
</code></pre>
<hr>
<h5 id="挂起恢复"><a href="#挂起恢复" class="headerlink" title="挂起恢复"></a>挂起恢复</h5><p>AbstractPlatformTransactionManager#suspend：<strong>挂起事务</strong>，并获得一个上下文信息对象</p>
<pre><code class="java">protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) &#123;
    // 事务是同步状态的
    if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();
        try &#123;
            Object suspendedResources = null;
            if (transaction != null) &#123;
                // do it
                suspendedResources = doSuspend(transaction);
            &#125;
            //将上层事务绑定在线程上下文的变量全部取出来
            //...
            // 通过被挂起的资源和上层事务的上下文变量，创建一个【SuspendedResourcesHolder】返回
            return new SuspendedResourcesHolder(suspendedResources, suspendedSynchronizations, 
                                                name, readOnly, isolationLevel, wasActive);
        &#125; //...
&#125;
protected Object doSuspend(Object transaction) &#123;
    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
    // 将当前方法的事务对象 connectionHolder 属性置为 null，不和上层共享资源
    // 当前方法有可能是不开启事务或者要开启一个独立的事务
    txObject.setConnectionHolder(null);
    // 【解绑在线程上的事务】
    return TransactionSynchronizationManager.unbindResource(obtainDataSource());
&#125;
</code></pre>
<p>AbstractPlatformTransactionManager#resume：<strong>恢复现场</strong>，根据挂起资源去恢复线程上下文信息</p>
<pre><code class="java">protected final void resume(Object transaction, SuspendedResourcesHolder resourcesHolder) &#123;
    if (resourcesHolder != null) &#123;
        // 获取被挂起的事务资源
        Object suspendedResources = resourcesHolder.suspendedResources;
        if (suspendedResources != null) &#123;
            //绑定上一个事务的 ConnectionHolder 到线程上下文
            doResume(transaction, suspendedResources);
        &#125;
        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;
        if (suspendedSynchronizations != null) &#123;
            //....
            // 将线程上下文变量恢复为上一个事务的挂起现场
            doResumeSynchronization(suspendedSynchronizations);
        &#125;
    &#125;
&#125;
protected void doResume(@Nullable Object transaction, Object suspendedResources) &#123;
    // doSuspend 的逆动作，【绑定资源】
    TransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);
&#125;
</code></pre>
<hr>
<h4 id="提交回滚"><a href="#提交回滚" class="headerlink" title="提交回滚"></a>提交回滚</h4><h5 id="回滚方式"><a href="#回滚方式" class="headerlink" title="回滚方式"></a>回滚方式</h5><pre><code class="java">protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) &#123;
    // 事务状态信息不为空进入逻辑
    if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) &#123;
        // 条件二成立 说明目标方法抛出的异常需要回滚事务
        if (txInfo.transactionAttribute != null &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;
            try &#123;
                // 事务管理器的回滚方法
                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
            &#125;
            catch (TransactionSystemException ex2) &#123;&#125;
        &#125;
        else &#123;
            // 执行到这里，说明当前事务虽然抛出了异常，但是该异常并不会导致整个事务回滚
            try &#123;
                // 提交事务
                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
            &#125;
            catch (TransactionSystemException ex2) &#123;&#125;
        &#125;
    &#125;
&#125;
public boolean rollbackOn(Throwable ex) &#123;
    // 继承自 RuntimeException 或 error 的是【非检查型异常】，才会归滚事务
    // 如果配置了其他回滚错误，会获取到回滚规则 rollbackRules 进行判断
    return (ex instanceof RuntimeException || ex instanceof Error);
&#125;
</code></pre>
<pre><code class="java">public final void rollback(TransactionStatus status) throws TransactionException &#123;
    // 事务已经完成不需要回滚
    if (status.isCompleted()) &#123;
        throw new IllegalTransactionStateException();
    &#125;
    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
    // 开始回滚事务
    processRollback(defStatus, false);
&#125;
</code></pre>
<p>AbstractPlatformTransactionManager#processRollback：事务回滚</p>
<ul>
<li><p><code>triggerBeforeCompletion(status)</code>：用来做扩展逻辑，回滚前的前置处理</p>
</li>
<li><p><code>if (status.hasSavepoint())</code>：条件成立说明当前事务是一个<strong>内嵌事务</strong>，当前方法只是复用了上层事务的一个内嵌事务</p>
<p><code>status.rollbackToHeldSavepoint()</code>：内嵌事务加入事务时会创建一个保存点，此时恢复至保存点</p>
</li>
<li><p><code>if (status.isNewTransaction())</code>：说明事务是当前连接开启的，需要去回滚事务</p>
<p><code>doRollback(status)</code>：真正的的回滚函数</p>
<ul>
<li><code>DataSourceTransactionObject txObject = status.getTransaction()</code>：获取事务对象</li>
<li><code>Connection con = txObject.getConnectionHolder().getConnection()</code>：获取连接对象</li>
<li><code>con.rollback()</code>：<strong>JDBC 的方式回滚事务</strong></li>
</ul>
</li>
<li><p><code>else</code>：当前方法是共享的上层的事务，和上层使用同一个 Conn 资源，<strong>共享的事务不能直接回滚，应该交给上层处理</strong></p>
<p><code>doSetRollbackOnly(status)</code>：设置 con.rollbackOnly &#x3D; true，线程回到上层事务 commit 时会检查该字段，然后执行回滚操作</p>
</li>
<li><p><code>triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)</code>：回滚的后置处理</p>
</li>
<li><p><code>cleanupAfterCompletion(status)</code>：清理和恢复现场</p>
</li>
</ul>
<hr>
<h5 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h5><pre><code class="java">protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) &#123;
    if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) &#123;
        // 事务管理器的提交方法
        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
    &#125;
&#125;
</code></pre>
<pre><code class="java">public final void commit(TransactionStatus status) throws TransactionException &#123;
    // 已经完成的事务不需要提交了
    if (status.isCompleted()) &#123;
        throw new IllegalTransactionStateException();
    &#125;
    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
    // 条件成立说明是当前的业务强制回滚
    if (defStatus.isLocalRollbackOnly()) &#123;
        // 回滚逻辑，
        processRollback(defStatus, false);
        return;
    &#125;
    // 成立说明共享当前事务的【下层事务逻辑出错，需要回滚】
    if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;
        // 如果当前事务还是事务重入，会继续抛给上层，最上层事务会进行真实的事务回滚操作
        processRollback(defStatus, true);
        return;
    &#125;
    // 执行提交
    processCommit(defStatus);
&#125;
</code></pre>
<p>AbstractPlatformTransactionManager#processCommit：事务提交</p>
<ul>
<li><p><code>prepareForCommit(status)</code>：前置处理</p>
</li>
<li><p><code>if (status.hasSavepoint())</code>：条件成立说明当前事务是一个<strong>内嵌事务</strong>，只是复用了上层事务</p>
<p><code>status.releaseHeldSavepoint()</code>：清理保存点，因为没有发生任何异常，所以保存点没有存在的意义了</p>
</li>
<li><p><code>if (status.isNewTransaction())</code>：说明事务是归属于当前连接的，需要去提交事务</p>
<p><code>doCommit(status)</code>：真正的提交函数</p>
<ul>
<li><code>Connection con = txObject.getConnectionHolder().getConnection()</code>：获取连接对象</li>
<li><code>con.commit()</code>：<strong>JDBC 的方式提交事务</strong></li>
</ul>
</li>
<li><p><code>doRollbackOnCommitException(status, ex)</code>：<strong>提交事务出错后进行回滚</strong></p>
</li>
<li><p><code> cleanupAfterCompletion(status)</code>：清理和恢复现场</p>
</li>
</ul>
<hr>
<h5 id="清理现场"><a href="#清理现场" class="headerlink" title="清理现场"></a>清理现场</h5><p>恢复上层事务：</p>
<pre><code class="java">protected void cleanupTransactionInfo(@Nullable TransactionInfo txInfo) &#123;
    if (txInfo != null) &#123;
        // 从当前线程的 ThreadLocal 获取上层的事务信息，将当前事务出栈，继续执行上层事务
        txInfo.restoreThreadLocalStatus();
    &#125;
&#125;
private void restoreThreadLocalStatus() &#123;
    // Use stack to restore old transaction TransactionInfo.
    transactionInfoHolder.set(this.oldTransactionInfo);
&#125;
</code></pre>
<p>当前层级事务结束时的清理：</p>
<pre><code class="java">private void cleanupAfterCompletion(DefaultTransactionStatus status) &#123;
    // 设置当前方法的事务状态为完成状态
    status.setCompleted();
    if (status.isNewSynchronization()) &#123;
        // 清理线程上下文变量以及扩展点注册的 sync
        TransactionSynchronizationManager.clear();
    &#125;
    // 事务是当前线程开启的
    if (status.isNewTransaction()) &#123;
        // 解绑资源
        doCleanupAfterCompletion(status.getTransaction());
    &#125;
    // 条件成立说明当前事务执行的时候，【挂起了一个上层的事务】
    if (status.getSuspendedResources() != null) &#123;
        Object transaction = (status.hasTransaction() ? status.getTransaction() : null);
        // 恢复上层事务现场
        resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());
    &#125;
&#125;
</code></pre>
<p>DataSourceTransactionManager#doCleanupAfterCompletion：清理工作</p>
<ul>
<li><p><code>TransactionSynchronizationManager.unbindResource(obtainDataSource())</code>：解绑数据库资源</p>
</li>
<li><p><code>if (txObject.isMustRestoreAutoCommit())</code>：是否恢复连接，Conn 归还到 DataSource<strong>，归还前需要恢复到申请时的状态</strong></p>
<p><code>con.setAutoCommit(true)</code>：恢复连接为自动提交</p>
</li>
<li><p><code>DataSourceUtils.resetConnectionAfterTransaction(con, txObject.getPreviousIsolationLevel())</code>：恢复隔离级别</p>
</li>
<li><p><code>DataSourceUtils.releaseConnection(con, this.dataSource)</code>：<strong>将连接归还给数据库连接池</strong></p>
</li>
<li><p><code>txObject.getConnectionHolder().clear()</code>：清理 ConnectionHolder 资源</p>
</li>
</ul>
<hr>
<h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>@Component 解析流程：</p>
<ul>
<li><p>注解类启动容器的时，注册 ClassPathBeanDefinitionScanner 到容器，用来扫描 Bean 的相关信息</p>
<pre><code class="java">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;
    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();
    // 遍历指定的所有的包，【这就相当于扫描了】
    for (String basePackage : basePackages) &#123;
        // 读取当前包下的资源装换为 BeanDefinition，字节流的方式
        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);
        for (BeanDefinition candidate : candidates) &#123;
            // 遍历，封装，类似于 XML 的解析方式，注册到容器中
            registerBeanDefinition(definitionHolder, this.registry)
        &#125;
    return beanDefinitions;
&#125;
</code></pre>
</li>
<li><p>ClassPathScanningCandidateComponentProvider.findCandidateComponents()</p>
<pre><code class="java">public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123;
    if (this.componentsIndex != null &amp;&amp; indexSupportsIncludeFilters()) &#123;
        return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
    &#125;
    else &#123;
        return scanCandidateComponents(basePackage);
    &#125;
&#125;
</code></pre>
<pre><code class="java">private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) &#123;&#125;
</code></pre>
<ul>
<li><p><code>String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX resolveBasePackage(basePackage) + &#39;/&#39; + this.resourcePattern</code> ：将 package 转化为 ClassLoader 类资源搜索路径 packageSearchPath，例如：<code>com.sea.spring.boot</code> 转化为 <code>classpath*:com/sea/spring/boot/**/*.class</code></p>
</li>
<li><p><code>resources = getResourcePatternResolver().getResources(packageSearchPath)</code>：加载路径下的资源</p>
</li>
<li><p><code>for (Resource resource : resources) </code>：遍历所有的资源</p>
<p><code>metadataReader = getMetadataReaderFactory().getMetadataReader(resource)</code>：获取元数据阅读器</p>
<p><code>if (isCandidateComponent(metadataReader))</code>：<strong>当前类不匹配任何排除过滤器，并且匹配一个包含过滤器</strong>，返回 true</p>
<ul>
<li><p>includeFilters 由 <code>registerDefaultFilters()</code> 设置初始值，方法有 @Component，没有 @Service，因为 @Component 是 @Service 的元注解，Spring 在读取 @Service 时也读取了元注解，并将 @Service 作为 @Component 处理</p>
<pre><code class="java">this.includeFilters.add(new AnnotationTypeFilter(Component.class))
</code></pre>
<pre><code class="java">@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component    // 拥有了 Component 功能
public @interface Service &#123;&#125;
</code></pre>
</li>
</ul>
<p><code>candidates.add(sbd)</code>：添加到返回结果的 list</p>
</li>
</ul>
</li>
</ul>
<p>参考文章：<a target="_blank" rel="noopener" href="https://my.oschina.net/floor/blog/4325651">https://my.oschina.net/floor/blog/4325651</a></p>
<hr>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h4><p>打开 @Autowired 源码，注释上写 Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor</p>
<p>AutowiredAnnotationBeanPostProcessor 间接实现 InstantiationAwareBeanPostProcessor，就具备了实例化前后（而不是初始化前后）管理对象的能力，实现了 BeanPostProcessor，具有初始化前后管理对象的能力，实现 BeanFactoryAware，具备随时拿到 BeanFactory 的能力，所以这个类<strong>具备一切后置处理器的能力</strong></p>
<p><strong>在容器启动，为对象赋值的时候，遇到 @Autowired 注解，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性，赋值给对象上，这就是 Autowired 的原理</strong></p>
<p>作用时机：</p>
<ul>
<li>Spring 在每个 Bean 实例化之后，调用 AutowiredAnnotationBeanPostProcessor 的 <code>postProcessMergedBeanDefinition()</code> 方法，查找该 Bean 是否有 @Autowired 注解，进行相关元数据的获取</li>
<li>Spring 在每个 Bean 调用 <code>populateBean()</code> 进行属性注入的时候，即调用 <code>postProcessProperties()</code> 方法，查找该 Bean 属性是否有 @Autowired 注解，进行相关数据的填充</li>
</ul>
<hr>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1></div><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><div class="story post-story"><p>SpringMVC：是一种基于 Java 实现 MVC 模型的轻量级 Web 框架</p>
<p>SpringMVC 优点：</p>
<ul>
<li>使用简单</li>
<li>性能突出（对比现有的框架技术）</li>
<li>灵活性强</li>
</ul>
<p>软件开发三层架构：</p>
<ul>
<li><p>表现层：负责数据展示</p>
</li>
<li><p>业务层：负责业务处理</p>
</li>
<li><p>数据层：负责数据操作</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
</ul>
<p>MVC（Model View Controller），一种用于设计创建Web应用程序表现层的模式</p>
<ul>
<li><p>Model（模型）：数据模型，用于封装数据</p>
</li>
<li><p>View（视图）：页面视图，用于展示数据</p>
<ul>
<li>jsp  </li>
<li>html</li>
</ul>
</li>
</ul>
<ul>
<li><p>Controller（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑</p>
<ul>
<li>Servlet</li>
<li>SpringMVC</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-MVC%E5%8A%9F%E8%83%BD%E5%9B%BE%E7%A4%BA.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-MVC%E5%8A%9F%E8%83%BD%E5%9B%BE%E7%A4%BA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
</ul>
<p>参考视频：<a target="_blank" rel="noopener" href="https://space.bilibili.com/37974444/">https://space.bilibili.com/37974444/</a></p>
<hr>
</div><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><div class="story post-story"><h3 id="入门项目-2"><a href="#入门项目-2" class="headerlink" title="入门项目"></a>入门项目</h3><p>流程分析：</p>
<ul>
<li>服务器启动<ol>
<li>加载 web.xml 中 DispatcherServlet</li>
<li>读取 spring-mvc.xml 中的配置，加载所有 controller 包中所有标记为 bean 的类</li>
<li>读取 bean 中方法上方标注 @RequestMapping 的内容</li>
</ol>
</li>
<li>处理请求<ol>
<li>DispatcherServlet 配置拦截所有请求 &#x2F;</li>
<li>使用请求路径与所有加载的 @RequestMapping 的内容进行比对</li>
<li>执行对应的方法</li>
<li>根据方法的返回值在 webapp 目录中查找对应的页面并展示</li>
</ol>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>pom.xml 导入坐标</p>
<pre><code class="xml">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

&lt;groupId&gt;demo&lt;/groupId&gt;
&lt;artifactId&gt;spring_base_config&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;war&lt;/packaging&gt;

&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;!-- servlet3.0规范的坐标 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--jsp坐标--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--spring的坐标--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--springmvc的坐标--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;!--构建--&gt;
&lt;build&gt;
    &lt;!--设置插件--&gt;
    &lt;plugins&gt;
        &lt;!--具体的插件配置--&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;port&gt;80&lt;/port&gt;
                &lt;path&gt;/&lt;/path&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
</li>
<li><p>设定具体 Controller，控制层 java &#x2F; controller &#x2F; UserController</p>
<pre><code class="java">@Controller  //@Component衍生注解
public class UserController &#123;
    //设定当前方法的访问映射地址，等同于Servlet在web.xml中的配置
    @RequestMapping(&quot;/save&quot;)
    //设置当前方法返回值类型为String，用于指定请求完成后跳转的页面
    public String save()&#123;
        System.out.println(&quot;user mvc controller is running ...&quot;);
        //设定具体跳转的页面
        return &quot;success.jsp&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>webapp &#x2F; WEB-INF &#x2F; web.xml，配置SpringMVC核心控制器，请求转发到对应的具体业务处理器Controller中（等同于Servlet配置）</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
    &lt;!--配置Servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--加载Spring控制文件--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath*:spring-mvc.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
</li>
<li><p>resouces &#x2F; spring-mvc.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!--扫描加载所有的控制类--&gt;
    &lt;context:component-scan base-package=&quot;controller&quot;/&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<hr>
<h3 id="加载控制-1"><a href="#加载控制-1" class="headerlink" title="加载控制"></a>加载控制</h3><p>Controller 加载控制：SpringMVC 的处理器对应的 bean 必须按照规范格式开发，未避免加入无效的 bean 可通过 bean 加载过滤器进行包含设定或排除设定，表现层 bean 标注通常设定为 @Controller  </p>
<ul>
<li><p>resources &#x2F; spring-mvc.xml 配置</p>
<pre><code class="xml">&lt;context:component-scan base-package=&quot;com.seazean&quot;&gt;
    &lt;context:include-filter 
                        type=&quot;annotation&quot; 
                        expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre>
</li>
<li><p>静态资源加载（webapp 目录下的相关资源），spring-mvc.xml 配置，开启 mvc 命名空间</p>
<pre><code class="xml">&lt;!--放行指定类型静态资源配置方式--&gt;
&lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt; &lt;!--webapp/img/资源--&gt;
&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;
&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt;

&lt;!--SpringMVC 提供的通用资源放行方式，建议选择--&gt;
&lt;mvc:default-servlet-handler/&gt;
</code></pre>
</li>
<li><p>中文乱码处理 SpringMVC 提供专用的中文字符过滤器，用于处理乱码问题。配置在 web.xml 里面</p>
<pre><code class="xml">&lt;!--乱码处理过滤器，与Servlet中使用的完全相同，差异之处在于处理器的类由Spring提供--&gt;
&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
</li>
</ul>
<hr>
<h3 id="注解驱动-1"><a href="#注解驱动-1" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>WebApplicationContext，生成 Spring 核心容器（主容器&#x2F;父容器&#x2F;根容器）</p>
<ul>
<li>父容器：Spring 环境加载后形成的容器，包含 Spring 环境下的所有的 bean</li>
<li>子容器：当前 mvc 环境加载后形成的容器，不包含 Spring 环境下的 bean</li>
<li>子容器可以访问父容器中的资源，父容器不可以访问子容器的资源</li>
</ul>
<p>EnableWebMvc 注解作用：</p>
<ul>
<li>支持 ConversionService 的配置，可以方便配置自定义类型转换器</li>
<li>支持 @NumberFormat 注解格式化数字类型</li>
<li>支持 @DateTimeFormat 注解格式化日期数据，日期包括 Date、Calendar</li>
<li>支持 @Valid 的参数校验（需要导入 JSR-303 规范）</li>
<li>配合第三方 jar 包和 SpringMVC 提供的注解读写 XML 和 JSON 格式数据</li>
</ul>
<p>纯注解开发：</p>
<ul>
<li><p>使用注解形式转化 SpringMVC 核心配置文件为配置类 java &#x2F; config &#x2F;  SpringMVCConfiguration.java</p>
<pre><code class="java">@Configuration
@ComponentScan(value = &quot;com.seazean&quot;, includeFilters = @ComponentScan.Filter(
                                    type=FilterType.ANNOTATION,
                                    classes = &#123;Controller.class&#125; )
    )
//等同于&lt;mvc:annotation-driven/&gt;，还不完全相同
@EnableWebMvc
public class SpringMVCConfiguration implements WebMvcConfigurer&#123;
    //注解配置通用放行资源的格式 建议使用
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;
        configurer.enable();
    &#125;
&#125;
</code></pre>
</li>
<li><p>基于 servlet3.0 规范，自定义 Servlet 容器初始化配置类，加载 SpringMVC 核心配置类  </p>
<pre><code class="java">public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;
    //创建Servlet容器时，使用注解方式加载SPRINGMVC配置类中的信息，
    //并加载成WEB专用的ApplicationContext对象该对象放入了ServletContext范围，
    //在整个WEB容器中可以随时获取调用
    @Override
    protected WebApplicationContext createServletApplicationContext() &#123;
        A.C.W.A ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringMVCConfiguration.class);
        return ctx;
    &#125;

    //注解配置映射地址方式，服务于SpringMVC的核心控制器DispatcherServlet
    @Override
    protected String[] getServletMappings() &#123;
        return new String[]&#123;&quot;/&quot;&#125;;
    &#125;

    @Override
    protected WebApplicationContext createRootApplicationContext() &#123;
        return null;
    &#125;

    //乱码处理作为过滤器，在servlet容器启动时进行配置
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException &#123;
        super.onStartup(servletContext);
        CharacterEncodingFilter cef = new CharacterEncodingFilter();
        cef.setEncoding(&quot;UTF-8&quot;);
        FilterRegistration.Dynamic registration = servletContext.addFilter(&quot;characterEncodingFilter&quot;, cef);
        registration.addMappingForUrlPatterns(EnumSet.of(
                       DispatcherType.REQUEST,
                    DispatcherType.FORWARD,
                    DispatcherType.INCLUDE), false,&quot;/*&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h3><p>名称：@RequestMapping</p>
<p>类型：方法注解、类注解</p>
<p>位置：处理器类中的方法定义上方、处理器类定义上方</p>
<ul>
<li><p>方法注解</p>
<p>作用：绑定请求地址与对应处理方法间的关系</p>
<p>无类映射地址访问格式： <a target="_blank" rel="noopener" href="http://localhost/requestURL2">http://localhost/requestURL2</a></p>
<pre><code class="java">@Controller
public class UserController &#123;
    @RequestMapping(&quot;/requestURL2&quot;)
    public String requestURL2() &#123;
        return &quot;page.jsp&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>类注解</p>
<p>作用：为当前处理器中所有方法设定公共的访问路径前缀</p>
<p>带有类映射地址访问格式，将类映射地址作为前缀添加在实际映射地址前面：**&#x2F;user&#x2F;requestURL1**</p>
<p>最终返回的页面如果未设定绝对访问路径，将从类映射地址所在目录中查找 <strong>webapp&#x2F;user&#x2F;page.jsp</strong></p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;
    @RequestMapping(&quot;/requestURL2&quot;)
    public String requestURL2() &#123;
        return &quot;page.jsp&quot;;
    &#125;
&#125; 
</code></pre>
</li>
<li><p>常用属性</p>
<pre><code class="java">@RequestMapping(
    value=&quot;/requestURL3&quot;, //设定请求路径，与path属性、 value属性相同
    method = RequestMethod.GET, //设定请求方式
    params = &quot;name&quot;, //设定请求参数条件
    headers = &quot;content-type=text/*&quot;, //设定请求消息头条件
    consumes = &quot;text/*&quot;, //用于指定可以接收的请求正文类型（MIME类型）
    produces = &quot;text/*&quot; //用于指定可以生成的响应正文类型（MIME类型）
)
public String requestURL3() &#123;
    return &quot;/page.jsp&quot;;
&#125;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h2><div class="story post-story"><h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><h4 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h4><p>SpringMVC 将传递的参数封装到处理器方法的形参中，达到快速访问参数的目的</p>
<ul>
<li><p>访问 URL：<a target="_blank" rel="noopener" href="http://localhost/requestParam1?name=seazean&amp;age=14">http://localhost/requestParam1?name=seazean&amp;age=14</a>  </p>
<pre><code class="java">@Controller
public class UserController &#123;
    @RequestMapping(&quot;/requestParam1&quot;)
    public String requestParam1(String name ,int age)&#123;
        System.out.println(&quot;name=&quot; + name + &quot;,age=&quot; + age);
        return &quot;page.jsp&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="jsp">&lt;%@page pageEncoding=&quot;UTF-8&quot; language=&quot;java&quot; contentType=&quot;text/html;UTF-8&quot; %&gt;
&lt;html&gt;
&lt;body&gt;
    &lt;h1&gt;请求参数测试页面&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ul>
<p>@RequestParam 的使用：</p>
<ul>
<li><p>类型：形参注解</p>
</li>
<li><p>位置：处理器类中的方法形参前方</p>
</li>
<li><p>作用：绑定请求参数与对应处理方法形参间的关系</p>
</li>
<li><p>访问 URL：<a target="_blank" rel="noopener" href="http://localhost/requestParam2?userName=Jock">http://localhost/requestParam2?userName=Jock</a></p>
<pre><code class="java">@RequestMapping(&quot;/requestParam2&quot;)
public String requestParam2(@RequestParam(
                            name = &quot;userName&quot;,
                            required = true,    //为true代表必须有参数
                            defaultValue = &quot;s&quot;) String name)&#123;
    System.out.println(&quot;name=&quot; + name);
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="POJO类型"><a href="#POJO类型" class="headerlink" title="POJO类型"></a>POJO类型</h4><h5 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h5><p>当 POJO 中使用简单类型属性时， 参数名称与 POJO 类属性名保持一致  </p>
<ul>
<li><p>访问 URL： <a target="_blank" rel="noopener" href="http://localhost/requestParam3?name=seazean&amp;age=14">http://localhost/requestParam3?name=seazean&amp;age=14</a>  </p>
<pre><code class="java">@RequestMapping(&quot;/requestParam3&quot;)
public String requestParam3(User user)&#123;
    System.out.println(&quot;name=&quot; + user.getName());
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
<pre><code class="java">public class User &#123;
    private String name;
    private Integer age;
    //......
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="参数冲突"><a href="#参数冲突" class="headerlink" title="参数冲突"></a>参数冲突</h5><p>当 POJO 类型属性与其他形参出现同名问题时，将被<strong>同时赋值</strong>，建议使用 @RequestParam 注解进行区分</p>
<ul>
<li><p>访问 URL： <a target="_blank" rel="noopener" href="http://localhost/requestParam4?name=seazean&amp;age=14">http://localhost/requestParam4?name=seazean&amp;age=14</a>  </p>
<pre><code class="java">@RequestMapping(&quot;/requestParam4&quot;)
public String requestParam4(User user, String age)&#123;
    System.out.println(&quot;user.age=&quot; + user.getAge() + &quot;,age=&quot; + age);//14 14 
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h5><p>当 POJO 中出现对象属性时，参数名称与对象层次结构名称保持一致  </p>
<ul>
<li><p>访问 URL： <a target="_blank" rel="noopener" href="http://localhost/requestParam5?address.province=beijing">http://localhost/requestParam5?address.province=beijing</a>  </p>
<pre><code class="java">@RequestMapping(&quot;/requestParam5&quot;)
public String requestParam5(User user)&#123;
    System.out.println(&quot;user.address=&quot; + user.getAddress().getProvince());
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
<pre><code class="java">public class User &#123;
    private String name;
    private Integer age;
    private Address address; //....
&#125;
</code></pre>
<pre><code class="java">public class Address &#123;
    private String province;
    private String city;
    private String address;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h5><p>POJO 中出现集合类型的处理方式</p>
<ul>
<li><p>通过 URL 地址中同名参数，可以为 POJO 中的集合属性进行赋值，集合属性要求保存简单数据</p>
<p>访问 URL：<a target="_blank" rel="noopener" href="http://localhost/requestParam6?nick=Jock1&amp;nick=Jockme&amp;nick=zahc">http://localhost/requestParam6?nick=Jock1&amp;nick=Jockme&amp;nick=zahc</a></p>
<pre><code class="java">@RequestMapping(&quot;/requestParam6&quot;)
public String requestParam6(User user)&#123;
    System.out.println(&quot;user=&quot; + user);
    //user = User&#123;name=&#39;null&#39;,age=null,nick=&#123;Jock1,Jockme,zahc&#125;&#125;
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
<pre><code class="java">public class User &#123;
    private String name;
    private Integer age;
    private List&lt;String&gt; nick;
&#125;
</code></pre>
</li>
<li><p>POJO 中出现 List 保存对象数据，参数名称与对象层次结构名称保持一致，使用数组格式描述集合中对象的位置访问 URL：<a target="_blank" rel="noopener" href="http://localhost/requestParam7?addresses%5B0%5D.province=bj&amp;addresses%5B1%5D.province=tj">http://localhost/requestParam7?addresses[0].province=bj&amp;addresses[1].province=tj</a>  </p>
<pre><code class="java">@RequestMapping(&quot;/requestParam7&quot;)
public String requestParam7(User user)&#123;
    System.out.println(&quot;user.addresses=&quot; + user.getAddress());
    //&#123;Address&#123;provice=bj,city=&#39;null&#39;,address=&#39;null&#39;&#125;&#125;,&#123;Address&#123;....&#125;&#125;
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
<pre><code class="java">public class User &#123;
    private String name;
    private Integer age;
    private List&lt;Address&gt; addresses;
&#125;
</code></pre>
</li>
<li><p>POJO 中出现 Map 保存对象数据，参数名称与对象层次结构名称保持一致，使用映射格式描述集合中对象位置</p>
<p>URL: <a target="_blank" rel="noopener" href="http://localhost/requestParam8?addressMap%5B%E2%80%99home%E2%80%99%5D.province=bj&amp;addressMap%5B%E2%80%99job%E2%80%99%5D.province=tj">http://localhost/requestParam8?addressMap[’home’].province=bj&amp;addressMap[’job’].province=tj</a>  </p>
<pre><code class="java">@RequestMapping(&quot;/requestParam8&quot;)
public String requestParam8(User user)&#123;
    System.out.println(&quot;user.addressMap=&quot; + user.getAddressMap());
    //user.addressMap=&#123;home=Address&#123;p=,c=,a=&#125;,job=Address&#123;....&#125;&#125;
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
<pre><code class="java">public class User &#123;
    private Map&lt;String,Address&gt; addressMap;
    //....
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="数组集合"><a href="#数组集合" class="headerlink" title="数组集合"></a>数组集合</h4><h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h5><p>请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个  </p>
<ul>
<li><p>访问 URL： <a target="_blank" rel="noopener" href="http://localhost/requestParam9?nick=Jockme&amp;nick=zahc">http://localhost/requestParam9?nick=Jockme&amp;nick=zahc</a>  </p>
<pre><code class="java">@RequestMapping(&quot;/requestParam9&quot;)
public String requestParam9(String[] nick)&#123;
    System.out.println(nick[0] + &quot;,&quot; + nick[1]);
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h5><p>保存简单类型数据，请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个</p>
<ul>
<li><p>访问 URL： <a target="_blank" rel="noopener" href="http://localhost/requestParam10?nick=Jockme&amp;nick=zahc">http://localhost/requestParam10?nick=Jockme&amp;nick=zahc</a></p>
<pre><code class="java">@RequestMapping(&quot;/requestParam10&quot;)
public String requestParam10(@RequestParam(&quot;nick&quot;) List&lt;String&gt; nick)&#123;
    System.out.println(nick);
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
</li>
<li><p>注意： SpringMVC 默认将 List 作为对象处理，赋值前先创建对象，然后将 nick <strong>作为对象的属性</strong>进行处理。List 是接口无法创建对象，报无法找到构造方法异常；修复类型为可创建对象的 ArrayList 类型后，对象可以创建但没有 nick 属性，因此数据为空<br>解决方法：需要告知 SpringMVC 的处理器 nick 是一组数据，而不是一个单一属性。通过 @RequestParam 注解，将数量大于 1 个 names 参数打包成参数数组后， SpringMVC 才能识别该数据格式，并判定形参类型是否为数组或集合，并按数组或集合对象的形式操作数据</p>
</li>
</ul>
<hr>
<h4 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h4><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>开启转换配置：<code>&lt;mvc:annotation-driven /&gt;  </code><br>作用：提供 Controller 请求转发，Json 自动转换等功能</p>
<p>如果访问 URL：<a target="_blank" rel="noopener" href="http://localhost/requestParam1?name=seazean&amp;age=seazean%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99%EF%BC%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%BC%82%E5%B8%B8">http://localhost/requestParam1?name=seazean&amp;age=seazean，会出现报错，类型转化异常</a></p>
<pre><code class="java">@RequestMapping(&quot;/requestParam1&quot;)
public String requestParam1(String name ,int age)&#123;
    System.out.println(&quot;name=&quot; + name + &quot;,age=&quot; + age);
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
<p>SpringMVC 对接收的数据进行自动类型转换，该工作通过 Converter 接口实现：</p>
<ul>
<li><p>标量转换器</p>
</li>
<li><p>集合、数组相关转换器</p>
</li>
<li><p>默认转换器</p>
</li>
</ul>
<hr>
<h5 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h5><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-date%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-date%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>如果访问 URL：<a target="_blank" rel="noopener" href="http://localhost/requestParam11?date=1999-09-09">http://localhost/requestParam11?date=1999-09-09</a> 会报错，所以需要日期类型转换</p>
<ul>
<li><p>声明自定义的转换格式并覆盖系统转换格式，配置 resources &#x2F; spring-mvc.xml</p>
<pre><code class="xml">&lt;!--5.启用自定义Converter--&gt;
&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;
&lt;!--1.设定格式类型Converter，注册为Bean，受SpringMVC管理--&gt;
&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;!--2.自定义Converter格式类型设定，该设定使用的是同类型覆盖的思想--&gt;
    &lt;property name=&quot;formatters&quot;&gt;
        &lt;!--3.使用set保障相同类型的转换器仅保留一个，避免冲突--&gt;
        &lt;set&gt;
            &lt;!--4.设置具体的格式类型--&gt;
            &lt;bean class=&quot;org.springframework.format.datetime.DateFormatter&quot;&gt;
                &lt;!--5.类型规则--&gt;
                &lt;property name=&quot;pattern&quot; value=&quot;yyyy-MM-dd&quot;/&gt;
            &lt;/bean&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>@DateTimeFormat<br>类型：形参注解、成员变量注解<br>位置：形参前面 或 成员变量上方<br>作用：为当前参数或变量指定类型转换规则</p>
<pre><code class="java">public String requestParam12(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date date)&#123;
    System.out.println(&quot;date=&quot; + date);
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
<pre><code class="java">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
private Date date;
</code></pre>
<p>依赖注解驱动支持，xml 开启配置：</p>
<pre><code class="xml">&lt;mvc:annotation-driven /&gt;  
</code></pre>
</li>
</ul>
<hr>
<h5 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h5><p>自定义类型转换器，实现 Converter 接口或者直接容器中注入：</p>
<ul>
<li><p>方式一：</p>
<pre><code class="java">public class WebConfig implements WebMvcConfigurer &#123;
    @Bean
    public WebMvcConfigurer webMvcConfigurer() &#123;
        return new WebMvcConfigurer() &#123;
            @Override
            public void addFormatters(FormatterRegistry registry) &#123;
                registry.addConverter(new Converter&lt;String, Date&gt;() &#123;
                    @Override
                    public Pet convert(String source) &#123;
                        DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
                        Date date = null;
                        //类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，
                        //不允许抛出，框架无法预计此类异常如何处理
                        try &#123;
                            date = df.parse(source);
                        &#125; catch (ParseException e) &#123;
                            e.printStackTrace();
                        &#125;
                        return date;
                    &#125;
                &#125;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>方式二：</p>
<pre><code class="java">//本例中的泛型填写的是String，Date，最终出现字符串转日期时，该类型转换器生效
public class MyDateConverter implements Converter&lt;String, Date&gt; &#123;
    //重写接口的抽象方法，参数由泛型决定
    public Date convert(String source) &#123;
        DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date = null;
        //类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，
        //不允许抛出，框架无法预计此类异常如何处理
        try &#123;
            date = df.parse(source);
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        return date;
    &#125;
&#125;
</code></pre>
<p>配置 resources &#x2F; spring-mvc.xml，注册自定义转换器，将功能加入到 SpringMVC 转换服务 ConverterService 中</p>
<pre><code class="xml">&lt;!--1.将自定义Converter注册为Bean，受SpringMVC管理--&gt;
&lt;bean id=&quot;myDateConverter&quot; class=&quot;converter.MyDateConverter&quot;/&gt;
&lt;!--2.设定自定义Converter服务bean--&gt;
&lt;bean id=&quot;conversionService&quot;
      class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
    &lt;!--3.注入所有的自定义Converter，该设定使用的是同类型覆盖的思想--&gt;
    &lt;property name=&quot;converters&quot;&gt;
        &lt;!--4.set保障同类型转换器仅保留一个，去重规则以Converter&lt;S,T&gt;的泛型为准--&gt;
        &lt;set&gt;
            &lt;!--5.具体的类型转换器--&gt;
            &lt;ref bean=&quot;myDateConverter&quot;/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!--开启注解驱动，加载自定义格式化转换器对应的类型转换服务--&gt;
&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;
</code></pre>
</li>
<li><p>使用转换器</p>
<pre><code class="java">@RequestMapping(&quot;/requestParam12&quot;)
public String requestParam12(Date date)&#123;
    System.out.println(date);
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h3><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><p>请求转发和重定向：</p>
<ul>
<li><p>请求转发：</p>
<pre><code class="java">@Controller
public class UserController &#123;
    @RequestMapping(&quot;/showPage1&quot;)
    public String showPage1() &#123;
            System.out.println(&quot;user mvc controller is running ...&quot;);
        return &quot;forward:/WEB-INF/page/page.jsp;
    &#125;
&#125;
</code></pre>
</li>
<li><p>请求重定向：</p>
<pre><code class="java">@RequestMapping(&quot;/showPage2&quot;)
public String showPage2() &#123;
    System.out.println(&quot;user mvc controller is running ...&quot;);
    return &quot;redirect:/WEB-INF/page/page.jsp&quot;;//不能访问WEB-INF下的资源
&#125;
</code></pre>
</li>
</ul>
<p>页面访问快捷设定（InternalResourceViewResolver）：</p>
<ul>
<li><p>展示页面的保存位置通常固定且结构相似，可以设定通用的访问路径简化页面配置，配置 spring-mvc.xml：</p>
<pre><code class="xml">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>简化</p>
<pre><code class="java">@RequestMapping(&quot;/showPage3&quot;)
public String showPage3() &#123;
    System.out.println(&quot;user mvc controller is running...&quot;);
    return &quot;page&quot;;
&#125;
@RequestMapping(&quot;/showPage4&quot;)
public String showPage4() &#123;
    System.out.println(&quot;user mvc controller is running...&quot;);
    return &quot;forward:page&quot;;
&#125;

@RequestMapping(&quot;/showPage5&quot;)
public String showPage5() &#123;
    System.out.println(&quot;user mvc controller is running...&quot;);
    return &quot;redirect:page&quot;;
&#125;
</code></pre>
</li>
<li><p>如果未设定了返回值，使用 void 类型，则默认使用访问路径作页面地址的前缀后缀</p>
<pre><code class="java">//最简页面配置方式，使用访问路径作为页面名称，省略返回值
@RequestMapping(&quot;/showPage6&quot;)
public void showPage6() &#123;
    System.out.println(&quot;user mvc controller is running ...&quot;);
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="数据跳转"><a href="#数据跳转" class="headerlink" title="数据跳转"></a>数据跳转</h4><p>ModelAndView 是 SpringMVC 提供的一个对象，该对象可以用作控制器方法的返回值（Model 同），实现携带数据跳转</p>
<p>作用：</p>
<ul>
<li>设置数据，向请求域对象中存储数据</li>
<li>设置视图，逻辑视图</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>使用 HttpServletRequest 类型形参进行数据传递</p>
<pre><code class="java">@Controller
public class BookController &#123;
    @RequestMapping(&quot;/showPageAndData1&quot;)
    public String showPageAndData1(HttpServletRequest request) &#123;
        request.setAttribute(&quot;name&quot;,&quot;seazean&quot;);
        return &quot;page&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>使用 Model 类型形参进行数据传递</p>
<pre><code class="java">@RequestMapping(&quot;/showPageAndData2&quot;)
public String showPageAndData2(Model model) &#123;
    model.addAttribute(&quot;name&quot;,&quot;seazean&quot;);
    Book book = new Book();
    book.setName(&quot;SpringMVC入门实战&quot;);
    book.setPrice(66.6d);
    //添加数据的方式，key对value
    model.addAttribute(&quot;book&quot;,book);
    return &quot;page&quot;;
&#125;
</code></pre>
<pre><code class="java">public class Book &#123;
    private String name;
    private Double price;
&#125;
</code></pre>
</li>
<li><p>使用 ModelAndView 类型形参进行数据传递，将该对象作为返回值传递给调用者  </p>
<pre><code class="java">@RequestMapping(&quot;/showPageAndData3&quot;)
public ModelAndView showPageAndData3(ModelAndView modelAndView) &#123;
    //ModelAndView mav = new ModelAndView(); 替换形参中的参数
    Book book  = new Book();
    book.setName(&quot;SpringMVC入门案例&quot;);
    book.setPrice(66.66d);

    //添加数据的方式，key对value
    modelAndView.addObject(&quot;book&quot;,book);
    modelAndView.addObject(&quot;name&quot;,&quot;Jockme&quot;);
    //设置页面的方式，该方法最后一次执行的结果生效
    modelAndView.setViewName(&quot;page&quot;);
    //返回值设定成ModelAndView对象
    return modelAndView;
&#125;
</code></pre>
</li>
<li><p>ModelAndView 扩展</p>
<pre><code class="java">//ModelAndView对象支持转发的手工设定，该设定不会启用前缀后缀的页面拼接格式
@RequestMapping(&quot;/showPageAndData4&quot;)
public ModelAndView showPageAndData4(ModelAndView modelAndView) &#123;
    modelAndView.setViewName(&quot;forward:/WEB-INF/page/page.jsp&quot;);
    return modelAndView;
&#125;

//ModelAndView对象支持重定向的手工设定，该设定不会启用前缀后缀的页面拼接格式
@RequestMapping(&quot;/showPageAndData5&quot;)
public ModelAndView showPageAndData6(ModelAndView modelAndView) &#123;
    modelAndView.setViewName(&quot;redirect:page.jsp&quot;);
    return modelAndView;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>注解：@ResponseBody</p>
<p>作用：将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 Response 的 body 区。如果返回值是字符串，那么直接将字符串返回客户端；如果是一个对象，会<strong>将对象转化为 JSON</strong>，返回客户端</p>
<p>注意：当方法上面没有写 ResponseBody，底层会将方法的返回值封装为 ModelAndView 对象</p>
<ul>
<li><p>使用 HttpServletResponse 对象响应数据</p>
<pre><code class="java">@Controller
public class AccountController &#123;
    @RequestMapping(&quot;/showData1&quot;)
    public void showData1(HttpServletResponse response) throws IOException &#123;
        response.getWriter().write(&quot;message&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>使用 <strong>@ResponseBody 将返回的结果作为响应内容</strong>（页面显示），而非响应的页面名称</p>
<pre><code class="java">@RequestMapping(&quot;/showData2&quot;)
@ResponseBody
public String showData2()&#123;
    return &quot;&#123;&#39;name&#39;:&#39;Jock&#39;&#125;&quot;;
&#125;
</code></pre>
</li>
<li><p>使用 jackson 进行 json 数据格式转化</p>
<p>导入坐标：</p>
<pre><code class="xml">&lt;!--json相关坐标3个--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
    &lt;version&gt;2.9.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
    &lt;version&gt;2.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">@RequestMapping(&quot;/showData3&quot;)
@ResponseBody
public String showData3() throws JsonProcessingException &#123;
    Book book  = new Book();
    book.setName(&quot;SpringMVC入门案例&quot;);
    book.setPrice(66.66d);

    ObjectMapper om = new ObjectMapper();
    return om.writeValueAsString(book);
&#125;
</code></pre>
</li>
<li><p>使用 SpringMVC 提供的消息类型转换器将对象与集合数据自动转换为 JSON 数据</p>
<pre><code class="java">//使用SpringMVC注解驱动，对标注@ResponseBody注解的控制器方法进行结果转换，由于返回值为引用类型，自动调用jackson提供的类型转换器进行格式转换
@RequestMapping(&quot;/showData4&quot;)
@ResponseBody
public Book showData4() &#123;
    Book book  = new Book();
    book.setName(&quot;SpringMVC入门案例&quot;);
    book.setPrice(66.66d);
    return book;
&#125;
</code></pre>
<ul>
<li><p>手工添加信息类型转换器  </p>
<pre><code class="xml">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.
             annotation.RequestMappingHandlerAdapter&quot;&gt;
    &lt;property name=&quot;messageConverters&quot;&gt;
        &lt;list&gt;
            &lt;bean class=&quot;org.springframework.http.converter.
                      json.MappingJackson2HttpMessageConverter&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean
</code></pre>
</li>
<li><p>使用 SpringMVC 注解驱动：</p>
<pre><code class="xml">&lt;!--开启springmvc注解驱动，对@ResponseBody的注解进行格式增强，追加其类型转换的功能，具体实现由MappingJackson2HttpMessageConverter进行--&gt;
&lt;mvc:annotation-driven/&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>转换集合类型数据</p>
<pre><code class="java">@RequestMapping(&quot;/showData5&quot;)
@ResponseBody
public List showData5() &#123;
    Book book1  = new Book();
    book1.setName(&quot;SpringMVC入门案例&quot;);
    book1.setPrice(66.66d);

    Book book2  = new Book();
    book2.setName(&quot;SpringMVC入门案例&quot;);
    book2.setPrice(66.66d);

    ArrayList al = new ArrayList();
    al.add(book1);
    al.add(book2);
    return al;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Rest（REpresentational State Transfer）：表现层状态转化，定义了<strong>资源在网络传输中以某种表现形式进行状态转移</strong>，即网络资源的访问方式</p>
<ul>
<li>资源：把真实的对象数据称为资源，一个资源既可以是一个集合，也可以是单个个体；每一种资源都有特定的 URI（统一资源标识符）与之对应，如果获取这个资源，访问这个 URI 就可以，比如获取特定的班级 <code>/class/12</code>；资源也可以包含子资源，比如 <code>/classes/classId/teachers</code> 某个指定班级的所有老师</li>
<li>表现形式：资源是一种信息实体，它可以有多种外在表现形式，把资源具体呈现出来的形式比如 json、xml、image、txt 等等叫做它的”表现层&#x2F;表现形式”</li>
<li>状态转移：描述的服务器端资源的状态，比如增删改查（通过 HTTP 动词实现）引起资源状态的改变，互联网通信协议 HTTP 协议，是一个<strong>无状态协议</strong>，所有的资源状态都保存在服务器端</li>
</ul>
<hr>
<h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><p>Restful 是按照 Rest 风格访问网络资源</p>
<ul>
<li>传统风格访问路径：<a target="_blank" rel="noopener" href="http://localhost/user/get?id=1">http://localhost/user/get?id=1</a></li>
<li>Rest 风格访问路径：<a target="_blank" rel="noopener" href="http://localhost/user/1">http://localhost/user/1</a></li>
</ul>
<p>优点：隐藏资源的访问行为，通过地址无法得知做的是何种操作，书写简化</p>
<p>Restful 请求路径简化配置方式：<code>@RestController = @Controller + @ResponseBody</code></p>
<p>相关注解：@GetMapping 注解是 @RequestMapping 注解的衍生，所以效果是一样的，建议使用 @GetMapping </p>
<ul>
<li><p><code>@GetMapping(&quot;/poll&quot;)</code> &#x3D; <code>@RequestMapping(value = &quot;/poll&quot;,method = RequestMethod.GET)</code></p>
<pre><code class="java">@RequestMapping(method = RequestMethod.GET)            // @GetMapping 就拥有了 @RequestMapping 的功能
public @interface GetMapping &#123;
    @AliasFor(annotation = RequestMapping.class)    // 与 RequestMapping 相通
    String name() default &quot;&quot;;
&#125;
</code></pre>
</li>
<li><p><code>@PostMapping(&quot;/push&quot;)</code> &#x3D; <code>@RequestMapping(value = &quot;/push&quot;,method = RequestMethod.POST)</code></p>
</li>
</ul>
<p>过滤器：HiddenHttpMethodFilter 是 SpringMVC 对 Restful 风格的访问支持的过滤器</p>
<p>代码实现：</p>
<ul>
<li><p>restful.jsp：</p>
<ul>
<li><p>页面表单<strong>使用隐藏域提交请求类型</strong>，参数名称固定为 _method，必须配合提交类型 method&#x3D;post 使用</p>
</li>
<li><p>GET 请求通过地址栏可以发送，也可以通过设置 form 的请求方式提交</p>
</li>
<li><p>POST 请求必须通过 form 的请求方式提交</p>
</li>
</ul>
<pre><code class="html">&lt;h1&gt;restful风格请求表单&lt;/h1&gt;
&lt;!--切换请求路径为restful风格--&gt;
&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;
    &lt;!--一隐藏域，切换为PUT请求或DELETE请求，但是form表单的提交方式method属性必须填写post--&gt;
    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;PUT&quot;/&gt;
    &lt;input value=&quot;REST-PUT 提交&quot; type=&quot;submit&quot;/&gt;
&lt;/form&gt;
</code></pre>
</li>
<li><p>java &#x2F; controller &#x2F; UserController</p>
<pre><code class="java">@RestController                //设置rest风格的控制器
@RequestMapping(&quot;/user/&quot;)    //设置公共访问路径，配合下方访问路径使用
public class UserController &#123;
    @GetMapping(&quot;/user&quot;)
    //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)
    public String getUser()&#123;
        return &quot;GET-张三&quot;;
    &#125;

    @PostMapping(&quot;/user&quot;)
    //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)
    public String saveUser()&#123;
        return &quot;POST-张三&quot;;
    &#125;

    @PutMapping(&quot;/user&quot;)
    //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)
    public String putUser()&#123;
        return &quot;PUT-张三&quot;;
    &#125;

    @DeleteMapping(&quot;/user&quot;)
    //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)
    public String deleteUser()&#123;
        return &quot;DELETE-张三&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>配置拦截器 web.xml</p>
<pre><code class="xml">&lt;!--配置拦截器，解析请求中的参数_method，否则无法发起PUT请求与DELETE请求，配合页面表单使用--&gt;
&lt;filter&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
&lt;/filter-mapping&gt;
</code></pre>
</li>
</ul>
<hr>
<h4 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h4><p>Restful 开发中的参数注解</p>
<pre><code class="java">@GetMapping(&quot;&#123;id&#125;&quot;)
public String getMessage(@PathVariable(&quot;id&quot;) Integer id)&#123;
&#125;
</code></pre>
<p>使用 @PathVariable 注解获取路径上配置的具名变量，一般在有多个参数的时候添加</p>
<p>其他注解：</p>
<ul>
<li>@RequestHeader：获取请求头</li>
<li>@RequestParam：获取请求参数（指问号后的参数，url?a&#x3D;1&amp;b&#x3D;2）</li>
<li>@CookieValue：获取 Cookie 值</li>
<li>@RequestAttribute：获取 request 域属性</li>
<li>@RequestBody：获取请求体 [POST]</li>
<li>@MatrixVariable：矩阵变量</li>
<li>@ModelAttribute：自定义类型变量</li>
</ul>
<pre><code class="java">@RestController    
@RequestMapping(&quot;/user/&quot;)
public class UserController &#123;
    //rest风格访问路径简化书写方式，配合类注解@RequestMapping使用
    @RequestMapping(&quot;&#123;id&#125;&quot;)
    public String restLocation2(@PathVariable Integer id)&#123;
        System.out.println(&quot;restful is running ....get:&quot; + id);
        return &quot;success.jsp&quot;;
    &#125;

    //@RequestMapping(value = &quot;&#123;id&#125;&quot;,method = RequestMethod.GET)
    @GetMapping(&quot;&#123;id&#125;&quot;)
    public String get(@PathVariable Integer id)&#123;
        System.out.println(&quot;restful is running ....get:&quot; + id);
        return &quot;success.jsp&quot;;
    &#125;

    @PostMapping(&quot;&#123;id&#125;&quot;)
    public String post(@PathVariable Integer id)&#123;
        System.out.println(&quot;restful is running ....post:&quot; + id);
        return &quot;success.jsp&quot;;
    &#125;

    @PutMapping(&quot;&#123;id&#125;&quot;)
    public String put(@PathVariable Integer id)&#123;
        System.out.println(&quot;restful is running ....put:&quot; + id);
        return &quot;success.jsp&quot;;
    &#125;

    @DeleteMapping(&quot;&#123;id&#125;&quot;)
    public String delete(@PathVariable Integer id)&#123;
        System.out.println(&quot;restful is running ....delete:&quot; + id);
        return &quot;success.jsp&quot;;
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="识别原理"><a href="#识别原理" class="headerlink" title="识别原理"></a>识别原理</h4><p>表单提交要使用 REST 时，会带上 <code>_method=PUT</code>，请求过来被 <code>HiddenHttpMethodFilter</code> 拦截，进行过滤操作</p>
<p>org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal()：</p>
<pre><code class="java">public class HiddenHttpMethodFilter extends OncePerRequestFilter &#123;
    // 兼容的请求 PUT、DELETE、PATCH
    private static final List&lt;String&gt; ALLOWED_METHODS =
            Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),
                    HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));
    // 隐藏域的名字
    public static final String DEFAULT_METHOD_PARAM = &quot;_method&quot;;

    private String methodParam = DEFAULT_METHOD_PARAM;
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException &#123;

        HttpServletRequest requestToUse = request;
        // 请求必须是 POST，
        if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) &#123;
            // 获取标签中 name=&quot;_method&quot; 的 value 值
            String paramValue = request.getParameter(this.methodParam);
            if (StringUtils.hasLength(paramValue)) &#123;
                // 转成大写
                String method = paramValue.toUpperCase(Locale.ENGLISH);
                // 兼容的请求方式
                if (ALLOWED_METHODS.contains(method)) &#123;
                    // 包装请求
                    requestToUse = new HttpMethodRequestWrapper(request, method);
                &#125;
            &#125;
        &#125;
        // 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的
        filterChain.doFilter(requestToUse, response);
    &#125;
&#125;
</code></pre>
<p>Rest 使用客户端工具，如 Postman 可直接发送 put、delete 等方式请求不被过滤</p>
<p>改变默认的 <code>_method</code> 的方式：</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
public class WebConfig&#123;
    //自定义filter
    @Bean
    public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;
        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();
        //通过set 方法自定义
        methodFilter.setMethodParam(&quot;_m&quot;);
        return methodFilter;
    &#125;    
&#125;
</code></pre>
<hr>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>SpringMVC 提供访问原始 Servlet 接口的功能</p>
<ul>
<li><p>SpringMVC 提供访问原始 Servlet 接口 API 的功能，通过形参声明即可 </p>
<pre><code class="java">@RequestMapping(&quot;/servletApi&quot;)
public String servletApi(HttpServletRequest request,
                         HttpServletResponse response, HttpSession session)&#123;
    System.out.println(request);
    System.out.println(response);
    System.out.println(session);
    request.setAttribute(&quot;name&quot;,&quot;seazean&quot;);
    System.out.println(request.getAttribute(&quot;name&quot;));
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
</li>
<li><p>Head 数据获取快捷操作方式<br>名称：@RequestHeader<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求头数据与对应处理方法形参间的关系<br>范例：</p>
<pre><code class="java">快捷操作方式@RequestMapping(&quot;/headApi&quot;)
public String headApi(@RequestHeader(&quot;Accept-Language&quot;) String headMsg)&#123;
    System.out.println(headMsg);
    return &quot;page&quot;;
&#125;  
</code></pre>
</li>
<li><p>Cookie 数据获取快捷操作方式<br>名称：@CookieValue<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求 Cookie 数据与对应处理方法形参间的关系<br>范例：</p>
<pre><code class="java">@RequestMapping(&quot;/cookieApi&quot;)
public String cookieApi(@CookieValue(&quot;JSESSIONID&quot;) String jsessionid)&#123;
    System.out.println(jsessionid);
    return &quot;page&quot;;
&#125;  
</code></pre>
</li>
<li><p>Session 数据获取<br>名称：@SessionAttribute<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求Session数据与对应处理方法形参间的关系<br>范例：</p>
<pre><code class="java">@RequestMapping(&quot;/sessionApi&quot;)
public String sessionApi(@SessionAttribute(&quot;name&quot;) String name)&#123;
    System.out.println(name);
    return &quot;page.jsp&quot;;
&#125;
//用于在session中放入数据
@RequestMapping(&quot;/setSessionData&quot;)
public String setSessionData(HttpSession session)&#123;
    session.setAttribute(&quot;name&quot;,&quot;seazean&quot;);
    return &quot;page&quot;;
&#125;
</code></pre>
</li>
<li><p>Session 数据设置<br>名称：@SessionAttributes<br>类型：类注解<br>位置：处理器类上方<br>作用：声明放入session范围的变量名称，适用于Model类型数据传参<br>范例：</p>
<pre><code class="java">@Controller
//设定当前类中名称为age和gender的变量放入session范围，不常用
@SessionAttributes(names = &#123;&quot;age&quot;,&quot;gender&quot;&#125;)
public class ServletController &#123;
    //将数据放入session存储范围，Model对象实现数据set，@SessionAttributes注解实现范围设定
    @RequestMapping(&quot;/setSessionData2&quot;)
    public String setSessionDate2(Model model) &#123;
        model.addAttribute(&quot;age&quot;,39);
        model.addAttribute(&quot;gender&quot;,&quot;男&quot;);
        return &quot;page&quot;;
    &#125;
    
    @RequestMapping(&quot;/sessionApi&quot;)
    public String sessionApi(@SessionAttribute(&quot;age&quot;) int age,
                             @SessionAttribute(&quot;gender&quot;) String gender)&#123;
        System.out.println(name);
        System.out.println(age);
        return &quot;page&quot;;
    &#125;
&#125;  
</code></pre>
</li>
<li><p>spring-mvc.xml 配置</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.seazean&quot;/&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;
    &lt;mvc:annotation-driven/&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="运行原理-1"><a href="#运行原理-1" class="headerlink" title="运行原理"></a>运行原理</h2><div class="story post-story"><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><h4 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h4><p>核心组件：</p>
<ul>
<li><p>DispatcherServlet：核心控制器， 是 SpringMVC 的核心，整体流程控制的中心，所有的请求第一步都先到达这里，由其调用其它组件处理用户的请求，它就是在 web.xml 配置的核心 Servlet，有效的降低了组件间的耦合性</p>
</li>
<li><p>HandlerMapping：处理器映射器， 负责根据请求找到对应具体的 Handler 处理器，SpringMVC 中针对配置文件方式、注解方式等提供了不同的映射器来处理</p>
</li>
<li><p>Handler：处理器，其实就是 Controller，业务处理的核心类，通常由开发者编写，并且必须遵守 Controller 开发的规则，这样适配器才能正确的执行。例如实现 Controller 接口，将 Controller 注册到 IOC 容器中等</p>
</li>
<li><p>HandlAdapter：处理器适配器，根据映射器中找到的 Handler，通过 HandlerAdapter 去执行 Handler，这是适配器模式的应用</p>
</li>
<li><p>View Resolver：视图解析器， 将 Handler 中返回的逻辑视图（ModelAndView）解析为一个具体的视图（View）对象</p>
</li>
<li><p>View：视图， View 最后对页面进行渲染将结果返回给用户，SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
</ul>
<p>优点：</p>
<ul>
<li>与 Spring 集成，更好的管理资源</li>
<li>有很多参数解析器和视图解析器，支持的数据类型丰富</li>
<li>将映射器、处理器、视图解析器进行解耦，分工明确</li>
</ul>
<hr>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>在 Spring 容器初始化时会建立所有的 URL 和 Controller 的对应关系，保存到 Map&lt;URL, Controller&gt; 中，这样 request 就能快速根据 URL 定位到 Controller：</p>
<ul>
<li>在 Spring IOC 容器初始化完所有单例 bean 后</li>
<li>SpringMVC 会遍历所有的 bean，获取 Controller 中对应的 URL（这里获取 URL 的实现类有多个，用于处理不同形式配置的 Controller）</li>
<li>将每一个 URL 对应一个 Controller 存入 Map&lt;URL, Controller&gt; 中</li>
</ul>
<p>注意：将 @Controller 注解换成 @Component，启动时不会报错，但是在浏览器中输入路径时会出现 404，说明 Spring 没有对所有的 bean 进行 URL 映射</p>
<p><strong>一个 Request 来了：</strong></p>
<ul>
<li>监听端口，获得请求：Tomcat 监听 8080 端口的请求处理，根据路径调用了 web.xml 中配置的核心控制器 DispatcherServlet，<code>DispatcherServlet#doDispatch</code> 是<strong>核心调度方法</strong></li>
<li><strong>首先根据 URI 获取 HandlerMapping 处理器映射器</strong>，RequestMappingHandlerMapping 用来处理 @RequestMapping 注解的映射规则，其中保存了所有 handler 的映射规则，最后包装成一个拦截器链返回，拦截器链对象持有 HandlerMapping。如果没有合适的处理请求的 HandlerMapping，说明请求处理失败，设置响应码 404 返回</li>
<li>根据映射器获取当前 handler，<strong>处理器适配器执行处理方法</strong>，适配器根据请求的 URL 去 handler 中寻找对应的处理方法：<ul>
<li>创建 ModelAndViewContainer (mav) 对象，用来填充数据，然后通过不同的<strong>参数解析器</strong>去解析 URL 中的参数，完成数据解析绑定，然后执行真正的 Controller 方法，完成 handle 处理</li>
<li>方法执行完对<strong>返回值</strong>进行处理，没添加 @ResponseBody 注解的返回值使用视图处理器处理，把视图名称设置进入 mav 中</li>
<li>对添加了 @ResponseBody 注解的 Controller 的按照普通的返回值进行处理，首先进行内容协商，找到一种浏览器可以接受（请求头 Accept）的并且服务器可以生成的数据类型，选择合适数据转换器，设置响应头中的数据类型，然后写出数据</li>
<li>最后把 ModelAndViewContainer 和 ModelMap 中的数据<strong>封装到 ModelAndView 对象</strong>返回</li>
</ul>
</li>
<li><strong>视图解析</strong>，根据返回值创建视图，请求转发 View 实例为 InternalResourceView，重定向 View 实例为 RedirectView。最后调用 view.render 进行页面渲染，结果派发<ul>
<li>请求转发时请求域中的数据不丢失，会把 ModelAndView 的数据设置到请求域中，获取 Servlet 原生的 RequestDispatcher，调用 <code>RequestDispatcher#forward</code> 实现转发</li>
<li>重定向会造成请求域中的数据丢失，使用 Servlet 原生方式实现重定向 <code>HttpServletResponse#sendRedirect</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="调度函数"><a href="#调度函数" class="headerlink" title="调度函数"></a>调度函数</h3><p>请求进入原生的 HttpServlet 的 doGet() 方法处理，调用子类 FrameworkServlet 的 doGet() 方法，最终调用 DispatcherServlet 的 doService() 方法，为请求设置相关属性后调用 doDispatch()，请求和响应的以参数的形式传入</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%BA%94%E7%9A%84%E5%8E%9F%E7%90%86.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%BA%94%E7%9A%84%E5%8E%9F%E7%90%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<pre><code class="java">// request 和 response 为 Java 原生的类
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    // 文件上传请求
    boolean multipartRequestParsed = false;
    // 异步管理器
    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try &#123;
        ModelAndView mv = null;
        Exception dispatchException = null;

        try &#123;
            // 文件上传相关请求
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // 找到当前请求使用哪个 HandlerMapping （Controller 的方法）处理，返回执行链
            mappedHandler = getHandler(processedRequest);
            // 没有合适的处理请求的方式 HandlerMapping，请求失败，直接返回 404
            if (mappedHandler == null) &#123;
                noHandlerFound(processedRequest, response);
                return;
            &#125;

            // 根据映射器获取当前 handler 处理器适配器，用来【处理当前的请求】
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
            // 获取发出此次请求的方式
            String method = request.getMethod();
            // 判断请求是不是 GET 方法
            boolean isGet = HttpMethod.GET.matches(method);
            if (isGet || HttpMethod.HEAD.matches(method)) &#123;
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;
                    return;
                &#125;
            &#125;
            // 拦截器链的前置处理
            if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;
                return;
            &#125;
            // 执行处理方法，返回的是 ModelAndView 对象，封装了所有的返回值数据
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) &#123;
                return;
            &#125;
            // 设置视图名字
            applyDefaultViewName(processedRequest, mv);
            // 执行拦截器链中的后置处理方法
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        &#125; catch (Exception ex) &#123;
            dispatchException = ex;
        &#125;
        
        // 处理程序调用的结果，进行结果派发
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    &#125;
    //....
&#125;
</code></pre>
<p>笔记参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a></p>
<hr>
<h3 id="请求映射-1"><a href="#请求映射-1" class="headerlink" title="请求映射"></a>请求映射</h3><h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><p>doDispatch() 中调用 getHandler 方法获取所有的映射器</p>
<p>总体流程：</p>
<ul>
<li><p>所有的请求映射都在 HandlerMapping 中，<strong>RequestMappingHandlerMapping 处理 @RequestMapping 注解的映射规则</strong></p>
</li>
<li><p>遍历所有的 HandlerMapping 看是否可以匹配当前请求，匹配成功后返回，匹配失败设置 HTTP 404 响应码</p>
</li>
<li><p>用户可以自定义的映射处理，也可以给容器中放入自定义 HandlerMapping</p>
</li>
</ul>
<p>访问 URL：<a target="_blank" rel="noopener" href="http://localhost:8080/user">http://localhost:8080/user</a></p>
<pre><code class="java">@GetMapping(&quot;/user&quot;)
public String getUser()&#123;
    return &quot;GET&quot;;
&#125;
@PostMapping(&quot;/user&quot;)
public String postUser()&#123;
    return &quot;POST&quot;;
&#125;
//。。。。。
</code></pre>
<p>HandlerMapping 处理器映射器，<strong>保存了所有 <code>@RequestMapping</code>  和 <code>handler</code> 的映射规则</strong></p>
<pre><code class="java">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;
    if (this.handlerMappings != null) &#123;
        // 遍历所有的 HandlerMapping
        for (HandlerMapping mapping : this.handlerMappings) &#123;
            // 尝试去每个 HandlerMapping 中匹配当前请求的处理
            HandlerExecutionChain handler = mapping.getHandler(request);
            if (handler != null) &#123;
                return handler;
            &#125;
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E8%8E%B7%E5%8F%96Controller%E5%A4%84%E7%90%86%E5%99%A8.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E8%8E%B7%E5%8F%96Controller%E5%A4%84%E7%90%86%E5%99%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ul>
<li><p><code>mapping.getHandler(request)</code>：调用 AbstractHandlerMapping#getHandler</p>
<ul>
<li><p><code>Object handler = getHandlerInternal(request)</code>：<strong>获取映射器</strong>，底层调用 RequestMappingInfoHandlerMapping 类的方法，又调用 AbstractHandlerMethodMapping#getHandlerInternal</p>
<ul>
<li><p><code>String lookupPath = initLookupPath(request)</code>：地址栏的 URI，这里的 lookupPath 为 &#x2F;user</p>
</li>
<li><p><code>this.mappingRegistry.acquireReadLock()</code>：加读锁防止其他线程并发修改</p>
</li>
<li><p><code>handlerMethod = lookupHandlerMethod(lookupPath, request)</code>：获取当前 HandlerMapping 中的映射规则</p>
<ul>
<li><p><code>directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath)</code>：获取当前的映射器与当前<strong>请求的 URI 有关的所有映射规则</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-HandlerMapping%E7%9A%84%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-HandlerMapping%E7%9A%84%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
<li><p><code>addMatchingMappings(directPathMatches, matches, request)</code>：<strong>匹配某个映射规则</strong></p>
<ul>
<li><code>for (T mapping : mappings)</code>：遍历所有的映射规则</li>
<li><code>match = getMatchingMapping(mapping, request)</code>：去匹配每一个映射规则，匹配失败返回 null</li>
<li><code>matches.add(new Match())</code>：匹配成功后封装成匹配器添加到匹配集合中</li>
</ul>
</li>
<li><p><code>matches.sort(comparator)</code>：匹配集合排序</p>
</li>
<li><p><code>Match bestMatch = matches.get(0)</code>：匹配完成只剩一个，直接获取返回对应的处理方法</p>
</li>
<li><p><code>if (matches.size() &gt; 1)</code>：当有多个映射规则符合请求时，报错</p>
</li>
<li><p><code>return bestMatch.getHandlerMethod()</code>：返回匹配器中的处理方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>executionChain = getHandlerExecutionChain(handler, request)</code>：<strong>为当前请求和映射器的构建一个拦截器链</strong></p>
<ul>
<li><code>for (HandlerInterceptor interceptor : this.adaptedInterceptors)</code>：遍历所有的拦截器</li>
<li><code>chain.addInterceptor(interceptor)</code>：把所有的拦截器添加到 HandlerExecutionChain 中，形成拦截器链</li>
</ul>
</li>
<li><p><code>return executionChain</code>：<strong>返回拦截器链，HandlerMapping 是链的 handler 成员属性</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p>doDispatch() 中调用 <code>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler())</code></p>
<pre><code class="java">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;
    if (this.handlerAdapters != null) &#123;
        // 遍历所有的 HandlerAdapter
        for (HandlerAdapter adapter : this.handlerAdapters) &#123;
            // 判断当前适配器是否支持当前 handle
            if (adapter.supports(handler)) &#123;
                // 返回的是 【RequestMappingHandlerAdapter】
                // AbstractHandlerMethodAdapter#supports -&gt; RequestMappingHandlerAdapter
                return adapter;
            &#125;
        &#125;
    &#125;
    throw new ServletException();
&#125;
</code></pre>
<hr>
<h4 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h4><p>实例代码：</p>
<pre><code class="java">@GetMapping(&quot;/params&quot;)
public String param(Map&lt;String, Object&gt; map, Model model, HttpServletRequest request) &#123;
    map.put(&quot;k1&quot;, &quot;v1&quot;);            // 都可以向请求域中添加数据
    model.addAttribute(&quot;k2&quot;, &quot;v2&quot;);    // 它们两个都在数据封装在 【BindingAwareModelMap】，继承自 LinkedHashMap
    request.setAttribute(&quot;m&quot;, &quot;HelloWorld&quot;);
    return &quot;forward:/success&quot;;
&#125;
</code></pre>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-Model%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-Model%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>doDispatch() 中调用 <code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler())</code> <strong>使用适配器执行方法</strong></p>
<p><code>AbstractHandlerMethodAdapter#handle</code> → <code>RequestMappingHandlerAdapter#handleInternal</code> → <code>invokeHandlerMethod</code>：</p>
<pre><code class="java">protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
                                           HttpServletResponse response, 
                                           HandlerMethod handlerMethod) throws Exception &#123;
    // 封装成 SpringMVC 的接口，用于通用 Web 请求拦截器，使能够访问通用请求元数据，而不是用于实际处理请求
    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    try &#123;
        // WebDataBinder 用于【从 Web 请求参数到 JavaBean 对象的数据绑定】，获取创建该实例的工厂
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        // 创建 Model 实例，用于向模型添加属性
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);
        // 方法执行器
        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
        
        // 参数解析器，有很多
        if (this.argumentResolvers != null) &#123;
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        &#125;
        // 返回值处理器，也有很多
        if (this.returnValueHandlers != null) &#123;
            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        &#125;
        // 设置数据绑定器
        invocableMethod.setDataBinderFactory(binderFactory);
        // 设置参数检查器
        invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);
   
        // 新建一个 ModelAndViewContainer 并进行初始化和一些属性的填充
        ModelAndViewContainer mavContainer = new ModelAndViewContainer();
            
        // 设置一些属性
        
        // 【执行目标方法】
        invocableMethod.invokeAndHandle(webRequest, mavContainer);
        // 异步请求
        if (asyncManager.isConcurrentHandlingStarted()) &#123;
            return null;
        &#125;
        // 【获取 ModelAndView 对象，封装了 ModelAndViewContainer】
        return getModelAndView(mavContainer, modelFactory, webRequest);
    &#125;
    finally &#123;
        webRequest.requestCompleted();
    &#125;
&#125;
</code></pre>
<p>ServletInvocableHandlerMethod#invokeAndHandle：执行目标方法</p>
<ul>
<li><p><code>returnValue = invokeForRequest(webRequest, mavContainer, providedArgs)</code>：<strong>执行自己写的 controller 方法，返回的就是自定义方法中 return 的值</strong></p>
<p><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs)</code>：<strong>参数处理的逻辑</strong>，遍历所有的参数解析器解析参数或者将 URI 中的参数进行绑定，绑定完成后开始执行目标方法</p>
<ul>
<li><p><code>parameters = getMethodParameters()</code>：获取此处理程序方法的方法参数的详细信息</p>
</li>
<li><p><code>Object[] args = new Object[parameters.length]</code>：存放所有的参数</p>
</li>
<li><p><code>for (int i = 0; i &lt; parameters.length; i++)</code>：遍历所有的参数</p>
</li>
<li><p><code>args[i] = findProvidedArgument(parameter, providedArgs)</code>：获取调用方法时提供的参数，一般是空</p>
</li>
<li><p><code>if (!this.resolvers.supportsParameter(parameter))</code>：<strong>获取可以解析当前参数的参数解析器</strong></p>
<p><code>return getArgumentResolver(parameter) != null</code>：获取参数的解析是否为空</p>
<ul>
<li><p><code>for (HandlerMethodArgumentResolver resolver : this.argumentResolvers)</code>：遍历容器内所有的解析器</p>
<p><code>if (resolver.supportsParameter(parameter))</code>：是否支持当前参数</p>
<ul>
<li><code>PathVariableMethodArgumentResolver#supportsParameter</code>：<strong>解析标注 @PathVariable 注解的参数</strong></li>
<li><code>ModelMethodProcessor#supportsParameter</code>：解析 Map 和 Model 类型的参数，Model 和 Map 的作用一样</li>
<li><code>ExpressionValueMethodArgumentResolver#supportsParameter</code>：解析标注 @Value 注解的参数</li>
<li><code>RequestParamMapMethodArgumentResolver#supportsParameter</code>：<strong>解析标注 @RequestParam 注解</strong></li>
<li><code>RequestPartMethodArgumentResolver#supportsParameter</code>：解析文件上传的信息</li>
<li><code>ModelAttributeMethodProcessor#supportsParameter</code>：解析标注 @ModelAttribute 注解或者不是简单类型<ul>
<li>子类 ServletModelAttributeMethodProcessor 是解析自定义类型 JavaBean 的解析器</li>
<li>简单类型有 Void、Enum、Number、CharSequence、Date、URI、URL、Locale、Class</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>args[i] = this.resolvers.resolveArgument()</code>：<strong>开始解析参数，每个参数使用的解析器不同</strong></p>
<p><code>resolver = getArgumentResolver(parameter)</code>：获取参数解析器</p>
<p><code>return resolver.resolveArgument()</code>：开始解析</p>
<ul>
<li><code>PathVariableMapMethodArgumentResolver#resolveArgument</code>：@PathVariable，包装 URI 中的参数为 Map</li>
<li><code>MapMethodProcessor#resolveArgument</code>：调用 <code>mavContainer.getModel()</code> 返回默认 BindingAwareModelMap 对象</li>
<li><code>ModelAttributeMethodProcessor#resolveArgument</code>：<strong>自定义的 JavaBean 的绑定封装</strong>，下一小节详解</li>
</ul>
</li>
</ul>
<p><code>return doInvoke(args)</code>：<strong>真正的执行 Controller 方法</strong></p>
<ul>
<li><code>Method method = getBridgedMethod()</code>：从 HandlerMethod 获取要反射执行的方法</li>
<li><code>ReflectionUtils.makeAccessible(method)</code>：破解权限</li>
<li><code>method.invoke(getBean(), args)</code>：执行方法，getBean 获取的是标记 @Controller 的 Bean 类，其中包含执行方法</li>
</ul>
</li>
<li><p><strong>进行返回值的处理，响应部分详解</strong>，处理完成进入下面的逻辑</p>
</li>
</ul>
<p>RequestMappingHandlerAdapter#getModelAndView：获取 ModelAndView 对象</p>
<ul>
<li><p><code>modelFactory.updateModel(webRequest, mavContainer)</code>：Model 数据升级到会话域（<strong>请求域中的数据在重定向时丢失</strong>）</p>
<ul>
<li><code>updateBindingResult(request, defaultModel)</code>：把绑定的数据添加到 BindingAwareModelMap 中</li>
</ul>
</li>
<li><p><code>if (mavContainer.isRequestHandled())</code>：判断请求是否已经处理完成了</p>
</li>
<li><p><code>ModelMap model = mavContainer.getModel()</code>：获取<strong>包含 Controller 方法参数</strong>的 BindingAwareModelMap（本节开头）</p>
</li>
<li><p><code>mav = new ModelAndView()</code>：<strong>把 ModelAndViewContainer 和 ModelMap 中的数据封装到 ModelAndView</strong> </p>
</li>
<li><p><code>if (!mavContainer.isViewReference())</code>：是否是通过名称指定视图引用</p>
</li>
<li><p><code>if (model instanceof RedirectAttributes)</code>：判断 model 是否是重定向数据，如果是进行重定向逻辑</p>
</li>
<li><p><code>return mav</code>：<strong>任何方法执行都会返回 ModelAndView 对象</strong></p>
</li>
</ul>
<hr>
<h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>解析自定义的 JavaBean 为例，调用 ModelAttributeMethodProcessor#resolveArgument 处理参数的方法，通过合适的类型转换器把 URL 中的参数转换以后，利用反射获取 set 方法，注入到 JavaBean</p>
<ul>
<li><p>Person.java：</p>
<pre><code class="java">@Data
@Component    //加入到容器中
public class Person &#123;
    private String userName;
    private Integer age;
    private Date birth;
&#125;
</code></pre>
</li>
<li><p>Controller：</p>
<pre><code class="java">@RestController    //返回的数据不是页面
public class ParameterController &#123;
    // 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定
    @GetMapping(&quot;/saveuser&quot;)
    public Person saveuser(Person person)&#123;
        return person;
    &#125;
&#125;
</code></pre>
</li>
<li><p>访问 URL：<a target="_blank" rel="noopener" href="http://localhost:8080/saveuser?userName=zhangsan&amp;age=20">http://localhost:8080/saveuser?userName=zhangsan&amp;age=20</a></p>
</li>
</ul>
<p>进入源码：ModelAttributeMethodProcessor#resolveArgument</p>
<ul>
<li><p><code>name = ModelFactory.getNameForParameter(parameter)</code>：获取名字，此例就是 person</p>
</li>
<li><p><code>ann = parameter.getParameterAnnotation(ModelAttribute.class)</code>：是否有 ModelAttribute 注解</p>
</li>
<li><p><code>if (mavContainer.containsAttribute(name))</code>：ModelAndViewContainer 中是否包含 person 对象</p>
</li>
<li><p><code>attribute = createAttribute()</code>：<strong>创建一个实例，空的 Person 对象</strong></p>
</li>
<li><p><code>binder = binderFactory.createBinder(webRequest, attribute, name)</code>：Web 数据绑定器，可以利用 Converters 将请求数据转成指定的数据类型，绑定到 JavaBean 中</p>
</li>
<li><p><code>bindRequestParameters(binder, webRequest)</code>：<strong>利用反射向目标对象填充数据</strong></p>
<p><code>servletBinder = (ServletRequestDataBinder) binder</code>：类型强转</p>
<p><code>servletBinder.bind(servletRequest)</code>：绑定数据</p>
<ul>
<li><p><code>mpvs = new MutablePropertyValues(request.getParameterMap())</code>：获取请求 URI 参数中的 k-v 键值对</p>
</li>
<li><p><code>addBindValues(mpvs, request)</code>：子类可以用来为请求添加额外绑定值</p>
</li>
<li><p><code>doBind(mpvs)</code>：真正的绑定的方法，调用 <code>applyPropertyValues</code> 应用参数值，然后调用 <code>setPropertyValues</code> 方法</p>
<p><code>AbstractPropertyAccessor#setPropertyValues()</code>：</p>
<ul>
<li><p><code>List&lt;PropertyValue&gt; propertyValues</code>：获取到所有的参数的值，就是 URI 上的所有的参数值</p>
</li>
<li><p><code>for (PropertyValue pv : propertyValues)</code>：遍历所有的参数值</p>
</li>
<li><p><code>setPropertyValue(pv)</code>：<strong>填充到空的 Person 实例中</strong></p>
<ul>
<li><p><code>nestedPa = getPropertyAccessorForPropertyPath(propertyName)</code>：获取属性访问器</p>
</li>
<li><p><code>tokens = getPropertyNameTokens()</code>：获取元数据的信息</p>
</li>
<li><p><code>nestedPa.setPropertyValue(tokens, pv)</code>：填充数据</p>
</li>
<li><p><code>processLocalProperty(tokens, pv)</code>：处理属性</p>
<ul>
<li><p><code>if (!Boolean.FALSE.equals(pv.conversionNecessary))</code>：数据是否需要转换了</p>
</li>
<li><p><code>if (pv.isConverted())</code>：数据已经转换过了，转换了直接赋值，没转换进行转换</p>
</li>
<li><p><code>oldValue = ph.getValue()</code>：获取未转换的数据</p>
</li>
<li><p><code>valueToApply = convertForProperty()</code>：进行数据转换</p>
<p><code>TypeConverterDelegate#convertIfNecessary</code>：进入该方法的逻辑</p>
<ul>
<li><p><code>if (conversionService.canConvert(sourceTypeDesc, typeDescriptor))</code>：判断能不能转换</p>
<p><code>GenericConverter converter = getConverter(sourceType, targetType)</code>：<strong>获取类型转换器</strong></p>
<ul>
<li><p><code>converter = this.converters.find(sourceType, targetType)</code>：寻找合适的转换器</p>
<ul>
<li><p><code>sourceCandidates = getClassHierarchy(sourceType.getType())</code>：原数据类型</p>
</li>
<li><p><code>targetCandidates = getClassHierarchy(targetType.getType())</code>：目标数据类型</p>
<pre><code class="java">for (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;
    //双重循环遍历，寻找合适的转换器
     for (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;
</code></pre>
</li>
<li><p><code>GenericConverter converter = getRegisteredConverter(..)</code>：匹配类型转换器</p>
</li>
<li><p><code>return converter</code>：返回转换器</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)</code>：开始转换</p>
<ul>
<li><code>converter = getConverter(sourceType, targetType)</code>：<strong>获取可用的转换器</strong></li>
<li><code>result = ConversionUtils.invokeConverter()</code>：执行转换方法<ul>
<li><code>converter.convert()</code>：<strong>调用转换器的转换方法</strong>（GenericConverter#convert）</li>
</ul>
</li>
<li><code>return handleResult(sourceType, targetType, result)</code>：返回结果</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ph.setValue(valueToApply)</code>：<strong>设置 JavaBean 属性</strong>（BeanWrapperImpl.BeanPropertyHandler）</p>
<ul>
<li><code>Method writeMethod</code>：获取写数据方法<ul>
<li><code>Class&lt;?&gt; cls = getClass0()</code>：获取 Class 对象</li>
<li><code>writeMethodName = Introspector.SET_PREFIX + getBaseName()</code>：<strong>set 前缀 + 属性名</strong></li>
<li><code>writeMethod = Introspector.findMethod(cls, writeMethodName, 1, args)</code>：获取只包含一个参数的 set 方法</li>
<li><code>setWriteMethod(writeMethod)</code>：加入缓存</li>
</ul>
</li>
<li><code>ReflectionUtils.makeAccessible(writeMethod)</code>：设置访问权限</li>
<li><code>writeMethod.invoke(getWrappedInstance(), value)</code>：执行方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>bindingResult = binder.getBindingResult()</code>：获取绑定的结果</p>
</li>
<li><p><code>mavContainer.addAllAttributes(bindingResultModel)</code>：<strong>把所有填充的参数放入 ModelAndViewContainer</strong></p>
</li>
<li><p><code>return attribute</code>：返回填充后的 Person 对象</p>
</li>
</ul>
<hr>
<h3 id="响应处理-1"><a href="#响应处理-1" class="headerlink" title="响应处理"></a>响应处理</h3><h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><p>以 Person 为例：</p>
<pre><code class="java">@ResponseBody          // 利用返回值处理器里面的消息转换器进行处理，而不是视图
@GetMapping(value = &quot;/person&quot;)
public Person getPerson()&#123;
    Person person = new Person();
    person.setAge(28);
    person.setBirth(new Date());
    person.setUserName(&quot;zhangsan&quot;);
    return person;
&#125;
</code></pre>
<p>直接进入方法执行完后的逻辑 ServletInvocableHandlerMethod#invokeAndHandle：</p>
<pre><code class="java">public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
                            Object... providedArgs) throws Exception &#123;
    // 【执行目标方法】，return person 对象
    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
    // 设置状态码
    setResponseStatus(webRequest);

    // 判断方法是否有返回值
    if (returnValue == null) &#123;
        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123;
            disableContentCachingIfNecessary(webRequest);
            mavContainer.setRequestHandled(true);
            return;
        &#125;
    &#125;    // 返回值是字符串
    else if (StringUtils.hasText(getResponseStatusReason())) &#123;
        // 设置请求处理完成
        mavContainer.setRequestHandled(true);
        return;
    // 设置请求没有处理完成，还需要进行返回值的逻辑
    mavContainer.setRequestHandled(false);
    Assert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);
    try &#123;
        // 【返回值的处理】
        this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
    &#125;
    catch (Exception ex) &#123;&#125;
&#125;
</code></pre>
<ul>
<li><strong>没有加 @ResponseBody 注解的返回数据按照视图处理的逻辑</strong>，ViewNameMethodReturnValueHandler（视图详解）</li>
<li>此例是加了注解的，返回的数据不是视图，HandlerMethodReturnValueHandlerComposite#handleReturnValue：</li>
</ul>
<pre><code class="java">public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)  &#123;
    // 获取合适的返回值处理器
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    if (handler == null) &#123;
        throw new IllegalArgumentException();
    &#125;
    // 使用处理器处理返回值（详解源码中的这两个函数）
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
&#125;
</code></pre>
<p>HandlerMethodReturnValueHandlerComposite#selectHandler：获取合适的返回值处理器</p>
<ul>
<li><p><code>boolean isAsyncValue = isAsyncReturnValue(value, returnType)</code>：是否是异步请求</p>
</li>
<li><p><code>for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers)</code>：遍历所有的返回值处理器</p>
<ul>
<li><code>RequestResponseBodyMethodProcessor#supportsReturnType</code>：<strong>处理标注 @ResponseBody 注解的返回值</strong></li>
<li><code>ModelAndViewMethodReturnValueHandler#supportsReturnType</code>：处理返回值类型是 ModelAndView 的处理器</li>
<li><code>ModelAndViewResolverMethodReturnValueHandler#supportsReturnType</code>：直接返回 true，处理所有数据</li>
</ul>
</li>
</ul>
<p>RequestResponseBodyMethodProcessor#handleReturnValue：处理返回值，要进行<strong>内容协商</strong></p>
<ul>
<li><p><code>mavContainer.setRequestHandled(true)</code>：设置请求处理完成</p>
</li>
<li><p><code>inputMessage = createInputMessage(webRequest)</code>：获取输入的数据</p>
</li>
<li><p><code>outputMessage = createOutputMessage(webRequest)</code>：获取输出的数据</p>
</li>
<li><p><code>writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage)</code>：使用消息转换器进行写出</p>
<ul>
<li><p><code>if (value instanceof CharSequence)</code>：判断返回的数据是不是字符类型</p>
</li>
<li><p><code>body = value</code>：把 value 赋值给 body，此时 body 中就是自定义方法执行完后的 Person 对象</p>
</li>
<li><p><code>if (isResourceType(value, returnType))</code>：当前数据是不是流数据</p>
</li>
<li><p><code>MediaType selectedMediaType</code>：<strong>内容协商后选择使用的类型，浏览器和服务器都支持的媒体（数据）类型</strong></p>
</li>
<li><p><code>MediaType contentType = outputMessage.getHeaders().getContentType()</code>：获取响应头的数据</p>
</li>
<li><p><code>if (contentType != null &amp;&amp; contentType.isConcrete())</code>：判断当前响应头中是否已经有确定的媒体类型</p>
<p><code>selectedMediaType = contentType</code>：前置处理已经使用了媒体类型，直接继续使用该类型</p>
</li>
<li><p><code>acceptableTypes = getAcceptableMediaTypes(request)</code>：<strong>获取浏览器支持的媒体类型，请求头字段</strong></p>
<ul>
<li><code>this.contentNegotiationManager.resolveMediaTypes()</code>：调用该方法</li>
<li><code>for(ContentNegotiationStrategy strategy:this.strategies)</code>：<strong>默认策略是提取请求头的字段的内容</strong>，策略类为HeaderContentNegotiationStrategy，可以配置添加其他类型的策略<ul>
<li><code>List&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request)</code>：解析 Accept 字段存储为 List<ul>
<li><code>headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT)</code>：获取请求头中 Accept 字段</li>
<li><code>List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(headerValues)</code>：解析成 List 集合</li>
<li><code>MediaType.sortBySpecificityAndQuality(mediaTypes)</code>：按照相对品质因数 q 降序排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
<li><p><code>producibleTypes = getProducibleMediaTypes(request, valueType, targetType)</code>：<strong>服务器能生成的媒体类型</strong></p>
<ul>
<li><code>request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE)</code>：从请求域获取默认的媒体类型<ul>
<li><code> for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters)</code>：遍历所有的消息转换器</li>
<li><code>converter.canWrite(valueClass, null)</code>：是否支持当前的类型</li>
<li><code> result.addAll(converter.getSupportedMediaTypes())</code>：把当前 MessageConverter 支持的所有类型放入 result</li>
</ul>
</li>
</ul>
</li>
<li><p><code>List&lt;MediaType&gt; mediaTypesToUse = new ArrayList&lt;&gt;()</code>：存储最佳匹配的集合</p>
</li>
<li><p><strong>内容协商：</strong></p>
<pre><code class="java">  for (MediaType requestedType : acceptableTypes) &#123;                // 遍历所有浏览器能接受的媒体类型
      for (MediaType producibleType : producibleTypes) &#123;        // 遍历所有服务器能产出的
          if (requestedType.isCompatibleWith(producibleType)) &#123;    // 判断类型是否匹配，最佳匹配
              // 数据协商匹配成功，一般有多种
              mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));
          &#125;
      &#125;
  &#125;
</code></pre>
</li>
<li><p><code>MediaType.sortBySpecificityAndQuality(mediaTypesToUse)</code>：按照相对品质因数 q 排序，降序排序，越大的越好</p>
</li>
<li><p><code>for (MediaType mediaType : mediaTypesToUse)</code>：<strong>遍历所有的最佳匹配</strong>，选择一种赋值给选择的类型</p>
</li>
<li><p><code>selectedMediaType = selectedMediaType.removeQualityValue()</code>：媒体类型去除相对品质因数</p>
</li>
<li><p><code>for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters)</code>：<strong>遍历所有的 HTTP 数据转换器</strong></p>
</li>
<li><p><code>GenericHttpMessageConverter genericConverter</code>：<strong>MappingJackson2HttpMessageConverter 可以将对象写为 JSON</strong></p>
</li>
<li><p><code>((GenericHttpMessageConverter) converter).canWrite()</code>：判断转换器是否可以写出给定的类型</p>
<p><code>AbstractJackson2HttpMessageConverter#canWrit</code></p>
<ul>
<li><p><code>if (!canWrite(mediaType))</code>：是否可以写出指定类型</p>
<ul>
<li><code>MediaType.ALL.equalsTypeAndSubtype(mediaType)</code>：是不是 <code>*/*</code> 类型</li>
<li><code>getSupportedMediaTypes()</code>：支持 <code>application/json</code> 和 <code>application/*+json</code> 两种类型<ul>
<li><code>return true</code>：返回 true</li>
</ul>
</li>
<li><code>objectMapper = selectObjectMapper(clazz, mediaType)</code>：选择可以使用的 objectMapper </li>
<li><code>causeRef = new AtomicReference&lt;&gt;()</code>：获取并发安全的引用</li>
<li><code>if (objectMapper.canSerialize(clazz, causeRef))</code>：objectMapper 可以序列化当前类</li>
<li><code>return true</code>：返回 true</li>
</ul>
</li>
<li><p><code> body = getAdvice().beforeBodyWrite()</code>：<strong>获取要响应的所有数据，就是 Person 对象</strong></p>
</li>
</ul>
</li>
<li><p><code>addContentDispositionHeader(inputMessage, outputMessage)</code>：检查路径</p>
</li>
<li><p><code>genericConverter.write(body, targetType, selectedMediaType, outputMessage)</code>：调用消息转换器的 write 方法</p>
<p><code>AbstractGenericHttpMessageConverter#write</code>：该类的方法</p>
<ul>
<li><p><code>addDefaultHeaders(headers, t, contentType)</code>：<strong>设置响应头中的数据类型</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
<li><p><code>writeInternal(t, type, outputMessage)</code>：<strong>数据写出为 JSON 格式</strong></p>
<ul>
<li><code>Object value = object</code>：value 引用 Person 对象</li>
<li><code>ObjectWriter objectWriter = objectMapper.writer()</code>：获取 ObjectWriter 对象</li>
<li><code>objectWriter.writeValue(generator, value)</code>：使用 ObjectWriter 写出数据为 JSON</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="协商策略"><a href="#协商策略" class="headerlink" title="协商策略"></a>协商策略</h4><p>开启基于请求参数的内容协商模式：（SpringBoot 方式）</p>
<pre><code class="yaml">spring.mvc.contentnegotiation:favor-parameter: true  # 开启请求参数内容协商模式
</code></pre>
<p>发请求： <a target="_blank" rel="noopener" href="http://localhost:8080/person?format=json%EF%BC%8C%E8%A7%A3%E6%9E%90">http://localhost:8080/person?format=json，解析</a> format</p>
<p>策略类为 ParameterContentNegotiationStrategy，运行流程如下：</p>
<ul>
<li><p><code>acceptableTypes = getAcceptableMediaTypes(request)</code>：获取浏览器支持的媒体类型</p>
<p><code>mediaTypes = strategy.resolveMediaTypes(request)</code>：解析请求 URL 参数中的数据</p>
<ul>
<li><p><code>return resolveMediaTypeKey(webRequest, getMediaTypeKey(webRequest))</code>：</p>
<p><code>getMediaTypeKey(webRequest)</code>：</p>
<ul>
<li><code>request.getParameter(getParameterName())</code>：获取 URL 中指定的需求的数据类型<ul>
<li><code>getParameterName()</code>：获取参数的属性名 format</li>
<li><code>getParameter()</code>：<strong>获取 URL 中 format 对应的数据</strong></li>
</ul>
</li>
</ul>
<p><code>resolveMediaTypeKey()</code>：解析媒体类型，封装成集合</p>
</li>
</ul>
</li>
</ul>
<p>自定义内容协商策略：</p>
<pre><code class="java">public class WebConfig implements WebMvcConfigurer &#123;
    @Bean
    public WebMvcConfigurer webMvcConfigurer() &#123;
        return new WebMvcConfigurer() &#123;
            @Override    //自定义内容协商策略
            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;
                Map&lt;String, MediaType&gt; mediaTypes = new HashMap&lt;&gt;();
                mediaTypes.put(&quot;json&quot;, MediaType.APPLICATION_JSON);
                mediaTypes.put(&quot;xml&quot;,MediaType.APPLICATION_XML);
                mediaTypes.put(&quot;person&quot;,MediaType.parseMediaType(&quot;application/x-person&quot;));
                // 指定支持解析哪些参数对应的哪些媒体类型
                ParameterContentNegotiationStrategy parameterStrategy = new ParameterContentNegotiationStrategy(mediaTypes);

                // 请求头解析
                HeaderContentNegotiationStrategy headStrategy = new HeaderContentNegotiationStrategy();

                // 添加到容器中，即可以解析请求头 又可以解析请求参数
                configurer.strategies(Arrays.asList(parameterStrategy,headStrategy));
            &#125;
            
            @Override     // 自定义消息转换器
            public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
                converters.add(new GuiguMessageConverter());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>也可以自定义 HttpMessageConverter，实现 HttpMessageConverter<T> 接口重写方法即可</T></p>
<hr>
<h3 id="视图解析"><a href="#视图解析" class="headerlink" title="视图解析"></a>视图解析</h3><h4 id="返回解析"><a href="#返回解析" class="headerlink" title="返回解析"></a>返回解析</h4><p>请求处理：</p>
<pre><code class="java">@GetMapping(&quot;/params&quot;)
public String param()&#123;
    return &quot;forward:/success&quot;;
    //return &quot;redirect:/success&quot;;
&#125;
</code></pre>
<p>进入执行方法逻辑 ServletInvocableHandlerMethod#invokeAndHandle，进入 <code>this.returnValueHandlers.handleReturnValue</code>：</p>
<pre><code class="java">public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)  &#123;
    // 获取合适的返回值处理器：调用 if (handler.supportsReturnType(returnType))判断是否支持
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    if (handler == null) &#123;
        throw new IllegalArgumentException();
    &#125;
    // 使用处理器处理返回值
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
&#125;
</code></pre>
<ul>
<li><p>ViewNameMethodReturnValueHandler#supportsReturnType：</p>
<pre><code class="java">public boolean supportsReturnType(MethodParameter returnType) &#123;
    Class&lt;?&gt; paramType = returnType.getParameterType();
    // 返回值是否是 void 或者是 CharSequence 字符序列，这里是字符序列
    return (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));
&#125;
</code></pre>
</li>
<li><p>ViewNameMethodReturnValueHandler#handleReturnValue：</p>
<pre><code class="java">public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
                              ModelAndViewContainer mavContainer, 
                              NativeWebRequest webRequest) throws Exception &#123;
    // 返回值是字符串，是 return &quot;forward:/success&quot;
    if (returnValue instanceof CharSequence) &#123;
        String viewName = returnValue.toString();
        // 【把视图名称设置进入 ModelAndViewContainer 中】
        mavContainer.setViewName(viewName);
        // 判断是否是重定向数据 `viewName.startsWith(&quot;redirect:&quot;)`
        if (isRedirectViewName(viewName)) &#123;
            // 如果是重定向，设置是重定向指令
            mavContainer.setRedirectModelScenario(true);
        &#125;
    &#125;
    else if (returnValue != null) &#123;
        // should not happen
        throw new UnsupportedOperationException();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="结果派发"><a href="#结果派发" class="headerlink" title="结果派发"></a>结果派发</h4><p>doDispatch() 中的 processDispatchResult：处理派发结果</p>
<pre><code class="java">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
                                   @Nullable HandlerExecutionChain mappedHandler, 
                                   @Nullable ModelAndView mv,
                                   @Nullable Exception exception) throws Exception &#123;
    boolean errorView = false;
    if (exception != null) &#123;
    &#125;
    // mv 是 ModelAndValue
    if (mv != null &amp;&amp; !mv.wasCleared()) &#123;
        // 渲染视图
        render(mv, request, response);
        if (errorView) &#123;
            WebUtils.clearErrorRequestAttributes(request);
        &#125;
    &#125;
    else &#123;&#125;  
&#125;
</code></pre>
<p>DispatcherServlet#render：</p>
<ul>
<li><p><code>Locale locale = this.localeResolver.resolveLocale(request)</code>：国际化相关</p>
</li>
<li><p><code>String viewName = mv.getViewName()</code>：视图名字，是请求转发 forward:&#x2F;success（响应数据解析并存入 ModelAndView）</p>
</li>
<li><p><code>view = resolveViewName(viewName, mv.getModelInternal(), locale, request)</code>：解析视图</p>
<ul>
<li><p><code>for (ViewResolver viewResolver : this.viewResolvers)</code>：<strong>遍历所有的视图解析器</strong></p>
<p><code>view = viewResolver.resolveViewName(viewName, locale)</code>：根据视图名字解析视图，调用内容协商视图处理器 ContentNegotiatingViewResolver 的方法</p>
<ul>
<li><p><code>attrs = RequestContextHolder.getRequestAttributes()</code>：获取请求的相关属性信息</p>
</li>
<li><p><code>requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest())</code>：获取最佳匹配的媒体类型，函数内进行了匹配的逻辑</p>
</li>
<li><p><code>candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes)</code>：获取候选的视图对象</p>
<ul>
<li><p><code>for (ViewResolver viewResolver : this.viewResolvers)</code>：遍历所有的视图解析器</p>
</li>
<li><p><code>View view = viewResolver.resolveViewName(viewName, locale)</code>：<strong>解析视图</strong></p>
<p><code>AbstractCachingViewResolver#resolveViewName</code>：</p>
<ul>
<li><p><code>returnview = createView(viewName, locale)</code>：UrlBasedViewResolver#createView</p>
<p><strong>请求转发</strong>：实例为 InternalResourceView</p>
<ul>
<li><p><code>if (viewName.startsWith(FORWARD_URL_PREFIX))</code>：视图名字是否是 <strong><code>forward:</code></strong> 的前缀</p>
</li>
<li><p><code>forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length())</code>：名字截取前缀</p>
</li>
<li><p><code>view = new InternalResourceView(forwardUrl)</code>：新建 InternalResourceView  对象并返回</p>
</li>
<li><p><code>return applyLifecycleMethods(FORWARD_URL_PREFIX, view)</code>：Spring 中的初始化操作</p>
</li>
</ul>
<p><strong>重定向</strong>：实例为 RedirectView </p>
<ul>
<li><code>if (viewName.startsWith(REDIRECT_URL_PREFIX))</code>：视图名字是否是 <strong><code>redirect:</code></strong> 的前缀</li>
<li><code>redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length())</code>：名字截取前缀</li>
<li><code>RedirectView view = new RedirectView()</code>：新建 RedirectView 对象并返回</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>bestView = getBestView(candidateViews, requestedMediaTypes, attrs)</code>：选出最佳匹配的视图对象</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>view.render(mv.getModelInternal(), request, response)</code>：<strong>页面渲染</strong></p>
<ul>
<li><p><code>mergedModel = createMergedOutputModel(model, request, response)</code>：把请求域中的数据封装到 model</p>
</li>
<li><p><code>prepareResponse(request, response)</code>：响应前的准备工作，设置一些响应头</p>
</li>
<li><p><code>renderMergedOutputModel(mergedModel, getRequestToExpose(request), response)</code>：渲染输出的数据</p>
<p><code>getRequestToExpose(request)</code>：获取 Servlet 原生的方式</p>
<p><strong>请求转发 InternalResourceView 的逻辑：请求域中的数据不丢失</strong></p>
<ul>
<li><code>exposeModelAsRequestAttributes(model, request)</code>：暴露 model 作为请求域的属性<ul>
<li><code>model.forEach()</code>：遍历 Model 中的数据</li>
<li><code>request.setAttribute(name, value)</code>：<strong>设置到请求域中</strong></li>
</ul>
</li>
<li><code>exposeHelpers(request)</code>：自定义接口</li>
<li><code>dispatcherPath = prepareForRendering(request, response)</code>：确定调度分派的路径，此例是 &#x2F;success</li>
<li><code>rd = getRequestDispatcher(request, dispatcherPath)</code>：<strong>获取 Servlet 原生的 RequestDispatcher 实现转发</strong></li>
<li><code>rd.forward(request, response)</code>：实现请求转发</li>
</ul>
<p><strong>重定向 RedirectView 的逻辑：请求域中的数据会丢失</strong></p>
<ul>
<li><code>targetUrl = createTargetUrl(model, request)</code>：获取目标 URL<ul>
<li><code>enc = request.getCharacterEncoding()</code>：设置编码 UTF-8</li>
<li><code>appendQueryProperties(targetUrl, model, enc)</code>：添加一些属性，比如 <code>url + ?name=123&amp;&amp;age=324</code></li>
</ul>
</li>
<li><code>sendRedirect(request, response, targetUrl, this.http10Compatible)</code>：重定向<ul>
<li><code>response.sendRedirect(encodedURL)</code>：<strong>使用 Servlet 原生方法实现重定向</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
</div><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><div class="story post-story"><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>名称：@RequestBody</p>
<p>类型：形参注解</p>
<p>位置：处理器类中的方法形参前方</p>
<p>作用：将异步提交数据<strong>转换</strong>成标准请求参数格式，并赋值给形参<br>范例：</p>
<pre><code class="java">@Controller //控制层
public class AjaxController &#123;
    @RequestMapping(&quot;/ajaxController&quot;)
    public String ajaxController(@RequestBody String message)&#123;
        System.out.println(message);
        return &quot;page.jsp&quot;;
    &#125;  
&#125;
</code></pre>
<ul>
<li>注解添加到 POJO  参数前方时，封装的异步提交数据按照 POJO  的属性格式进行关系映射<ul>
<li>POJO 中的属性如果请求数据中没有，属性值为 null</li>
<li>POJO 中没有的属性如果请求数据中有，不进行映射</li>
</ul>
</li>
<li>注解添加到集合参数前方时，封装的异步提交数据按照集合的存储结构进行关系映射</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/ajaxPojoToController&quot;)
//如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中
public String  ajaxPojoToController(@RequestBody User user)&#123;
    System.out.println(&quot;controller pojo :&quot;+user);
    return &quot;page.jsp&quot;;
&#125;

@RequestMapping(&quot;/ajaxListToController&quot;)
//如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式，数据将自动映射到集合参数
public String  ajaxListToController(@RequestBody List&lt;User&gt; userList)&#123;
    System.out.println(&quot;controller list :&quot;+userList);
    return &quot;page.jsp&quot;;
&#125;
</code></pre>
<p>ajax.jsp</p>
<pre><code class="html">&lt;%@page pageEncoding=&quot;UTF-8&quot; language=&quot;java&quot; contentType=&quot;text/html;UTF-8&quot; %&gt;

&lt;a href=&quot;javascript:void(0);&quot; id=&quot;testAjax&quot;&gt;访问springmvc后台controller&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;javascript:void(0);&quot; id=&quot;testAjaxPojo&quot;&gt;传递Json格式POJO&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;javascript:void(0);&quot; id=&quot;testAjaxList&quot;&gt;传递Json格式List&lt;/a&gt;&lt;br/&gt;
    
&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function () &#123;
        //为id=&quot;testAjax&quot;的组件绑定点击事件
        $(&quot;#testAjax&quot;).click(function()&#123;
            //发送异步调用
            $.ajax(&#123;
               //请求方式：POST请求
               type:&quot;POST&quot;,
               //请求的地址
               url:&quot;ajaxController&quot;,
               //请求参数（也就是请求内容）
               data:&#39;ajax message&#39;,
               //响应正文类型
               dataType:&quot;text&quot;,
               //请求正文的MIME类型
               contentType:&quot;application/text&quot;,
            &#125;);
        &#125;);
        
         //为id=&quot;testAjaxPojo&quot;的组件绑定点击事件
        $(&quot;#testAjaxPojo&quot;).click(function()&#123;
            $.ajax(&#123;
               type:&quot;POST&quot;,
               url:&quot;ajaxPojoToController&quot;,
               data:&#39;&#123;&quot;name&quot;:&quot;Jock&quot;,&quot;age&quot;:39&#125;&#39;,
               dataType:&quot;text&quot;,
               contentType:&quot;application/json&quot;,
            &#125;);
        &#125;);
        
        //为id=&quot;testAjaxList&quot;的组件绑定点击事件
        $(&quot;#testAjaxList&quot;).click(function()&#123;
            $.ajax(&#123;//.....
               data:&#39;[&#123;&quot;name&quot;:&quot;Jock&quot;,&quot;age&quot;:39&#125;,&#123;&quot;name&quot;:&quot;Jockme&quot;,&quot;age&quot;:40&#125;]&#39;&#125;)&#125;
    &#125;
&lt;/script&gt;
</code></pre>
<p>web.xml配置：请求响应章节请求中的web.xml配置</p>
<pre><code class="xml">CharacterEncodingFilter + DispatcherServlet
</code></pre>
<p>spring-mvc.xml：</p>
<pre><code class="xml">&lt;context:component-scan base-package=&quot;controller,domain&quot;/&gt;
&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;
&lt;mvc:annotation-driven/&gt;
</code></pre>
<hr>
<h3 id="响应数据-1"><a href="#响应数据-1" class="headerlink" title="响应数据"></a>响应数据</h3><p>注解：@ResponseBody</p>
<p>作用：将 Java 对象转为 json 格式的数据</p>
<p>方法返回值为 POJO 时，自动封装数据成 Json 对象数据：</p>
<pre><code class="java">@RequestMapping(&quot;/ajaxReturnJson&quot;)
@ResponseBody
public User ajaxReturnJson()&#123;
    System.out.println(&quot;controller return json pojo...&quot;);
    User user = new User(&quot;Jockme&quot;,40);
    return user;
&#125;  
</code></pre>
<p>方法返回值为 List 时，自动封装数据成 json 对象数组数据：</p>
<pre><code class="java">@RequestMapping(&quot;/ajaxReturnJsonList&quot;)
@ResponseBody
//基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据
public List ajaxReturnJsonList()&#123;
    System.out.println(&quot;controller return json list...&quot;);
    User user1 = new User(&quot;Tom&quot;,3);
    User user2 = new User(&quot;Jerry&quot;,5);

    ArrayList al = new ArrayList();
    al.add(user1);
    al.add(user2);
    return al;
&#125;
</code></pre>
<p>AJAX 文件：</p>
<pre><code class="js">//为id=&quot;testAjaxReturnString&quot;的组件绑定点击事件
$(&quot;#testAjaxReturnString&quot;).click(function()&#123;
    //发送异步调用
    $.ajax(&#123;
        type:&quot;POST&quot;,
        url:&quot;ajaxReturnString&quot;,
        //回调函数
        success:function(data)&#123;
            //打印返回结果
            alert(data);
        &#125;
    &#125;);
&#125;);

//为id=&quot;testAjaxReturnJson&quot;的组件绑定点击事件
$(&quot;#testAjaxReturnJson&quot;).click(function()&#123;
    $.ajax(&#123;
        type:&quot;POST&quot;,
        url:&quot;ajaxReturnJson&quot;,
        success:function(data)&#123;
            alert(data[&#39;name&#39;]+&quot; ,  &quot;+data[&#39;age&#39;]);
        &#125;
    &#125;);
&#125;);

//为id=&quot;testAjaxReturnJsonList&quot;的组件绑定点击事件
$(&quot;#testAjaxReturnJsonList&quot;).click(function()&#123;
    $.ajax(&#123;
        type:&quot;POST&quot;,
        url:&quot;ajaxReturnJsonList&quot;,
        success:function(data)&#123;
            alert(data);
            alert(data[0][&quot;name&quot;]);
            alert(data[1][&quot;age&quot;]);
        &#125;
    &#125;);
&#125;);
</code></pre>
<hr>
<h3 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h3><p>跨域访问：当通过域名 A 下的操作访问域名 B 下的资源时，称为跨域访问，跨域访问时，会出现无法访问的现象</p>
<p>环境搭建：</p>
<ul>
<li>为当前主机添加备用域名<ul>
<li>修改 windows 安装目录中的 host 文件</li>
<li>格式： ip 域名</li>
</ul>
</li>
<li>动态刷新 DNS<ul>
<li>命令： ipconfig &#x2F;displaydns</li>
<li>命令： ipconfig &#x2F;flushdns</li>
</ul>
</li>
</ul>
<p>跨域访问支持：</p>
<ul>
<li>名称：@CrossOrigin</li>
<li>类型：方法注解 、 类注解</li>
<li>位置：处理器类中的方法上方或类上方</li>
<li>作用：设置当前处理器方法 &#x2F; 处理器类中所有方法支持跨域访问</li>
<li>范例：</li>
</ul>
<pre><code class="java">@RequestMapping(&quot;/cross&quot;)
@ResponseBody
//使用@CrossOrigin开启跨域访问
//标注在处理器方法上方表示该方法支持跨域访问
//标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问
@CrossOrigin
public User cross(HttpServletRequest request)&#123;
    System.out.println(&quot;controller cross...&quot; + request.getRequestURL());
    User user = new User(&quot;Jockme&quot;,36);
    return user;
&#125;
</code></pre>
<ul>
<li>jsp 文件</li>
</ul>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot; id=&quot;testCross&quot;&gt;跨域访问&lt;/a&gt;&lt;br/&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function () &#123;
        //为id=&quot;testCross&quot;的组件绑定点击事件
        $(&quot;#testCross&quot;).click(function()&#123;
            //发送异步调用
            $.ajax(&#123;
               type:&quot;POST&quot;,
               url:&quot;http://127.0.0.1/cross&quot;,
               //回调函数
               success:function(data)&#123;
                   alert(&quot;跨域调用信息反馈:&quot; + data[&#39;name&#39;] + &quot;,&quot; + data[&#39;age&#39;]);
               &#125;
            &#125;);
        &#125;);
    &#125;);
&lt;/script&gt;
</code></pre>
<hr>
</div><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><div class="story post-story"><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>拦截器（Interceptor）是一种动态拦截方法调用的机制</p>
<p>作用：</p>
<ol>
<li>在指定的方法调用前后执行预先设定后的的代码</li>
<li>阻止原始方法的执行</li>
</ol>
<p>核心原理：AOP 思想</p>
<p>拦截器链：多个拦截器按照一定的顺序，对原始被调用功能进行增强  </p>
<p>拦截器和过滤器对比：</p>
<ol>
<li><p>归属不同： Filter 属于 Servlet 技术， Interceptor 属于 SpringMVC 技术</p>
</li>
<li><p>拦截内容不同： Filter 对所有访问进行增强， Interceptor 仅针对 SpringMVC 的访问进行增强  </p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-过滤器和拦截器的运行机制.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-过滤器和拦截器的运行机制.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:67%;"></li>
</ol>
<hr>
<h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><h4 id="前置处理"><a href="#前置处理" class="headerlink" title="前置处理"></a>前置处理</h4><p>原始方法之前运行：</p>
<pre><code class="java">public boolean preHandle(HttpServletRequest request,
                         HttpServletResponse response,
                         Object handler) throws Exception &#123;
    System.out.println(&quot;preHandle&quot;);
    return true;
&#125;
</code></pre>
<ul>
<li>参数：<ul>
<li>request：请求对象</li>
<li>response：响应对象</li>
<li>handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装<ul>
<li>handler：public String controller.InterceptorController.handleRun</li>
<li>handler.getClass()：org.springframework.web.method.HandlerMethod</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回值为 false，被拦截的处理器将不执行</li>
</ul>
</li>
</ul>
<hr>
<h4 id="后置处理-1"><a href="#后置处理-1" class="headerlink" title="后置处理"></a>后置处理</h4><p>原始方法运行后运行，如果原始方法被拦截，则不执行：</p>
<pre><code class="java">public void postHandle(HttpServletRequest request,
                       HttpServletResponse response,
                       Object handler,
                       ModelAndView modelAndView) throws Exception &#123;
    System.out.println(&quot;postHandle&quot;);
&#125;
</code></pre>
<p>参数：</p>
<ul>
<li>modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整</li>
</ul>
<hr>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>拦截器最后执行的方法，无论原始方法是否执行：</p>
<pre><code class="java">public void afterCompletion(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler,
                            Exception ex) throws Exception &#123;
    System.out.println(&quot;afterCompletion&quot;);
&#125;
</code></pre>
<p>参数：</p>
<ul>
<li>ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理</li>
</ul>
<hr>
<h3 id="拦截配置"><a href="#拦截配置" class="headerlink" title="拦截配置"></a>拦截配置</h3><p>拦截路径：</p>
<ul>
<li><code>/**</code>：表示拦截所有映射</li>
<li><code>/* </code>：表示拦截所有&#x2F;开头的映射</li>
<li><code>/user/*</code>：表示拦截所有 &#x2F;user&#x2F; 开头的映射</li>
<li><code>/user/add*</code>：表示拦截所有 &#x2F;user&#x2F; 开头，且具体映射名称以 add 开头的映射</li>
<li><code>/user/*All</code>：表示拦截所有 &#x2F;user&#x2F; 开头，且具体映射名称以 All 结尾的映射</li>
</ul>
<pre><code class="xml">&lt;mvc:interceptors&gt;
    &lt;!--开启具体的拦截器的使用，可以配置多个--&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--设置拦截器的拦截路径，支持*通配--&gt;       
        &lt;mvc:mapping path=&quot;/handleRun*&quot;/&gt;
        &lt;!--设置拦截排除的路径，配置/**或/*，达到快速配置的目的--&gt;
        &lt;mvc:exclude-mapping path=&quot;/b*&quot;/&gt;
        &lt;!--指定具体的拦截器类--&gt;
        &lt;bean class=&quot;MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<hr>
<h3 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h3><p><strong>责任链模式</strong>：责任链模式是一种行为模式</p>
<p>特点：沿着一条预先设定的任务链顺序执行，每个节点具有独立的工作任务<br>优势：</p>
<ul>
<li>独立性：只关注当前节点的任务，对其他任务直接放行到下一节点</li>
<li>隔离性：具备链式传递特征，无需知晓整体链路结构，只需等待请求到达后进行处理即可</li>
<li>灵活性：可以任意修改链路结构动态新增或删减整体链路责任</li>
<li>解耦：将动态任务与原始任务解耦</li>
</ul>
<p>缺点：</p>
<ul>
<li>链路过长时，处理效率低下</li>
<li>可能存在节点上的循环引用现象，造成死循环，导致系统崩溃</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-多拦截器配置.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-多拦截器配置.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom:67%;">



<hr>
<h3 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h3><p>DispatcherServlet#doDispatch 方法中：</p>
<pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
    try &#123;
        // 获取映射器以及映射器的所有拦截器（运行原理部分详解了源码）
        mappedHandler = getHandler(processedRequest);
        // 前置处理，返回 false 代表条件成立
        if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;
            //请求从这里直接结束
            return;
        &#125;
        //所有拦截器都返回 true，执行目标方法
        mv = ha.handle(processedRequest, response, mappedHandler.getHandler())
        // 倒序执行所有拦截器的后置处理方法
        mappedHandler.applyPostHandle(processedRequest, response, mv);
    &#125; catch (Exception ex) &#123;
        //异常处理机制
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    &#125;
&#125;
</code></pre>
<p>HandlerExecutionChain#applyPreHandle：前置处理</p>
<pre><code class="java">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
    //遍历所有的拦截器
    for (int i = 0; i &lt; this.interceptorList.size(); i++) &#123;
        HandlerInterceptor interceptor = this.interceptorList.get(i);
        //执行前置处理，如果拦截器返回 false，则条件成立，不在执行其他的拦截器，直接返回 false，请求直接结束
        if (!interceptor.preHandle(request, response, this.handler)) &#123;
            triggerAfterCompletion(request, response, null);
            return false;
        &#125;
        this.interceptorIndex = i;
    &#125;
    return true;
&#125;
</code></pre>
<p>HandlerExecutionChain#applyPostHandle：后置处理</p>
<pre><code class="java">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)
    throws Exception &#123;
    //倒序遍历
    for (int i = this.interceptorList.size() - 1; i &gt;= 0; i--) &#123;
        HandlerInterceptor interceptor = this.interceptorList.get(i);
        interceptor.postHandle(request, response, this.handler, mv);
    &#125;
&#125;
</code></pre>
<p>DispatcherServlet#triggerAfterCompletion 底层调用 HandlerExecutionChain#triggerAfterCompletion：</p>
<ul>
<li><p>前面的步骤有任何异常都会直接倒序触发 afterCompletion</p>
</li>
<li><p>页面成功渲染有异常，也会倒序触发 afterCompletion</p>
</li>
</ul>
<pre><code class="java">void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) &#123;
    //倒序遍历
    for (int i = this.interceptorIndex; i &gt;= 0; i--) &#123;
        HandlerInterceptor interceptor = this.interceptorList.get(i);
        try &#123;
            //执行异常处理的方法
            interceptor.afterCompletion(request, response, this.handler, ex);
        &#125;
        catch (Throwable ex2) &#123;
            logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);
        &#125;
    &#125;
&#125;
</code></pre>
<p>拦截器的执行流程：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-拦截器工作流程.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-拦截器工作流程.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" style="zoom: 50%;">



<p>参考文章：<a target="_blank" rel="noopener" href="https://www.yuque.com/atguigu/springboot/vgzmgh#wtPLU">https://www.yuque.com/atguigu/springboot/vgzmgh#wtPLU</a></p>
<hr>
<h3 id="自定义-2"><a href="#自定义-2" class="headerlink" title="自定义"></a>自定义</h3><ul>
<li><p>Contoller层</p>
<pre><code class="java">@Controller
public class InterceptorController &#123;
    @RequestMapping(&quot;/handleRun&quot;)
    public String handleRun() &#123;
        System.out.println(&quot;业务处理器运行------------main&quot;);
        return &quot;page.jsp&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>自定义拦截器需要实现 HandleInterceptor 接口</p>
<pre><code class="java">//自定义拦截器需要实现HandleInterceptor接口
public class MyInterceptor implements HandlerInterceptor &#123;
    //处理器运行之前执行
    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler) throws Exception &#123;
        System.out.println(&quot;前置运行----a1&quot;);
        //返回值为false将拦截原始处理器的运行
        //如果配置多拦截器，返回值为false将终止当前拦截器后面配置的拦截器的运行
        return true;
    &#125;

    //处理器运行之后执行
    @Override
    public void postHandle(HttpServletRequest request,
                           HttpServletResponse response,
                           Object handler,
                           ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;后置运行----b1&quot;);
    &#125;

    //所有拦截器的后置执行全部结束后，执行该操作
    @Override
    public void afterCompletion(HttpServletRequest request,
                                HttpServletResponse response,
                                Object handler,
                                Exception ex) throws Exception &#123;
        System.out.println(&quot;完成运行----c1&quot;);
    &#125;
&#125;
</code></pre>
<p>说明：三个方法的运行顺序为    preHandle → postHandle → afterCompletion，如果 preHandle 返回值为 false，三个方法仅运行preHandle</p>
</li>
<li><p>web.xml：</p>
<pre><code class="xml">CharacterEncodingFilter + DispatcherServlet
</code></pre>
</li>
<li><p>配置拦截器：spring-mvc.xml</p>
<pre><code class="xml">&lt;mvc:annotation-driven/&gt;
&lt;context:component-scan base-package=&quot;interceptor,controller&quot;/&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/handleRun&quot;/&gt;
        &lt;bean class=&quot;interceptor.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<p>注意：配置顺序为<strong>先配置执行位置，后配置执行类</strong></p>
</li>
</ul>
<hr>
</div><h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><div class="story post-story"><h3 id="处理器-1"><a href="#处理器-1" class="headerlink" title="处理器"></a>处理器</h3><p>异常处理器： <strong>HandlerExceptionResolver</strong> 接口</p>
<p>类继承该接口的以后，当开发出现异常后会执行指定的功能</p>
<pre><code class="java">@Component
public class ExceptionResolver implements HandlerExceptionResolver &#123;
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object handler,
                                         Exception ex) &#123;
        System.out.println(&quot;异常处理器正在执行中&quot;);
        ModelAndView modelAndView = new ModelAndView();
        //定义异常现象出现后，反馈给用户查看的信息
        modelAndView.addObject(&quot;msg&quot;,&quot;出错啦！ &quot;);
        //定义异常现象出现后，反馈给用户查看的页面
        modelAndView.setViewName(&quot;error.jsp&quot;);
        return modelAndView;
    &#125;
&#125;
</code></pre>
<p>根据异常的种类不同，进行分门别类的管理，返回不同的信息：</p>
<pre><code class="java">public class ExceptionResolver implements HandlerExceptionResolver &#123;
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object handler,
                                         Exception ex) &#123;
        System.out.println(&quot;my exception is running ....&quot; + ex);
        ModelAndView modelAndView = new ModelAndView();
        if( ex instanceof NullPointerException)&#123;
            modelAndView.addObject(&quot;msg&quot;,&quot;空指针异常&quot;);
        &#125;else if ( ex instanceof  ArithmeticException)&#123;
            modelAndView.addObject(&quot;msg&quot;,&quot;算数运算异常&quot;);
        &#125;else&#123;
            modelAndView.addObject(&quot;msg&quot;,&quot;未知的异常&quot;);
        &#125;
        modelAndView.setViewName(&quot;error.jsp&quot;);
        return modelAndView;
    &#125;
&#125;
</code></pre>
<p>模拟错误：</p>
<pre><code class="java">@Controller
public class UserController &#123;
    @RequestMapping(&quot;/save&quot;)
    @ResponseBody
    public String save(@RequestBody String name) &#123;
        //模拟业务层发起调用产生了异常
//        int i = 1/0;
//        String str = null;
//        str.length();

        return &quot;error.jsp&quot;;
    &#125;
</code></pre>
<hr>
<h3 id="注解开发-3"><a href="#注解开发-3" class="headerlink" title="注解开发"></a>注解开发</h3><p>使用注解实现异常分类管理，开发异常处理器</p>
<p>@ControllerAdvice 注解：</p>
<ul>
<li><p>类型：类注解</p>
</li>
<li><p>位置：异常处理器类上方</p>
</li>
<li><p>作用：设置当前类为异常处理器类</p>
</li>
<li><p>格式：</p>
<pre><code class="java">@Component
//声明该类是一个Controller的通知类，声明后该类就会被加载成异常处理器
@ControllerAdvice
public class ExceptionAdvice &#123;
&#125;  
</code></pre>
</li>
</ul>
<p>@ExceptionHandler 注解：</p>
<ul>
<li><p>类型：方法注解</p>
</li>
<li><p>位置：异常处理器类中针对指定异常进行处理的方法上方</p>
</li>
<li><p>作用：设置指定异常的处理方式</p>
</li>
<li><p>说明：处理器方法可以设定多个</p>
</li>
<li><p>格式：</p>
<pre><code class="java">@Component
@ControllerAdvice
public class ExceptionAdvice &#123;
    //类中定义的方法携带@ExceptionHandler注解的会被作为异常处理器，后面添加实际处理的异常类型
    @ExceptionHandler(NullPointerException.class)
    @ResponseBody
    public String doNullException(Exception ex)&#123;
        return &quot;空指针异常&quot;;
    &#125;

    @ExceptionHandler(Exception.class)
    @ResponseBody
    public String doException(Exception ex)&#123;
        return &quot;all Exception&quot;;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>@ResponseStatus 注解：</p>
<ul>
<li><p>类型：类注解、方法注解</p>
</li>
<li><p>位置：异常处理器类、方法上方</p>
</li>
<li><p>参数：</p>
<p>value：出现错误指定返回状态码</p>
<p>reason：出现错误返回的错误信息</p>
</li>
</ul>
<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>web.xml</p>
<pre><code class="java">DispatcherServlet + CharacterEncodingFilter
</code></pre>
</li>
<li><p>ajax.jsp</p>
<pre><code class="jsp">&lt;%@page pageEncoding=&quot;UTF-8&quot; language=&quot;java&quot; contentType=&quot;text/html;UTF-8&quot; %&gt;

&lt;a href=&quot;javascript:void(0);&quot; id=&quot;testException&quot;&gt;点击&lt;/a&gt;&lt;br/&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function () &#123;
        $(&quot;#testException&quot;).click(function()&#123;
            $.ajax(&#123;
                contentType:&quot;application/json&quot;,
                type:&quot;POST&quot;,
                url:&quot;save&quot;,
                /*通过修改参数，激活自定义异常的出现*/
                // name长度低于8位出现业务异常
                // age小于0出现业务异常
                // age大于100出现系统异常
                // age类型如果无法匹配将转入其他类别异常
                data:&#39;&#123;&quot;name&quot;:&quot;JockSuperMan&quot;,&quot;age&quot;:&quot;-1&quot;&#125;&#39;,
                dataType:&quot;text&quot;,
                //回调函数
                success:function(data)&#123;
                    alert(data);
                &#125;
            &#125;);
        &#125;);
    &#125;);
&lt;/script&gt;
</code></pre>
</li>
<li><p>spring-mvc.xml</p>
<pre><code class="xml">&lt;mvc:annotation-driven/&gt;
&lt;context:component-scan base-package=&quot;com.seazean&quot;/&gt;
&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;
</code></pre>
</li>
<li><p>java &#x2F; controller &#x2F; UserController</p>
<pre><code class="java">@Controller
public class UserController &#123;
    @RequestMapping(&quot;/save&quot;)
    @ResponseBody
    public List&lt;User&gt; save(@RequestBody User user) &#123;
        System.out.println(&quot;user controller save is running ...&quot;);
        //对用户的非法操作进行判定，并包装成异常对象进行处理，便于统一管理
        if(user.getName().trim().length() &lt; 8)&#123;
            throw new BusinessException(&quot;对不起，用户名长度不满足要求，请重新输入！&quot;);
        &#125;
        if(user.getAge() &lt; 0)&#123;
            throw new BusinessException(&quot;对不起，年龄必须是0到100之间的数字！&quot;);
        &#125;
        if(user.getAge() &gt; 100)&#123;
            throw new SystemException(&quot;服务器连接失败，请尽快检查处理！&quot;);
        &#125;

        User u1 = new User(&quot;Tom&quot;,3);
        User u2 = new User(&quot;Jerry&quot;,5);
        ArrayList&lt;User&gt; al = new ArrayList&lt;User&gt;();
        al.add(u1);al.add(u2);
        return al;
    &#125;
&#125;
</code></pre>
</li>
<li><p>自定义异常</p>
<pre><code class="java">//自定义异常继承RuntimeException，覆盖父类所有的构造方法
public class BusinessException extends RuntimeException &#123;覆盖父类所有的构造方法&#125;
</code></pre>
<pre><code class="java">public class SystemException extends RuntimeException &#123;&#125;
</code></pre>
</li>
<li><p>通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息</p>
<pre><code class="java">@Component
@ControllerAdvice
public class ProjectExceptionAdvice &#123;
    @ExceptionHandler(BusinessException.class)
    public String doBusinessException(Exception ex, Model m)&#123;
        //使用参数Model将要保存的数据传递到页面上，功能等同于ModelAndView
        //业务异常出现的消息要发送给用户查看
        m.addAttribute(&quot;msg&quot;,ex.getMessage());
        return &quot;error.jsp&quot;;
    &#125;

    @ExceptionHandler(SystemException.class)
    public String doSystemException(Exception ex, Model m)&#123;
        //系统异常出现的消息不要发送给用户查看，发送统一的信息给用户看
        m.addAttribute(&quot;msg&quot;,&quot;服务器出现问题，请联系管理员！&quot;);
        return &quot;error.jsp&quot;;
    &#125;

    @ExceptionHandler(Exception.class)
    public String doException(Exception ex, Model m)&#123;
        m.addAttribute(&quot;msg&quot;,ex.getMessage());
        //将ex对象保存起来
        return &quot;error.jsp&quot;;
    &#125;

&#125;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><div class="story post-story"><h3 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h3><p>上传文件过程：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>MultipartResolver接口：</p>
<ul>
<li>MultipartResolver 接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装</li>
<li>MultipartResolver 接口底层实现类 CommonsMultipartResovler</li>
<li>CommonsMultipartResovler 并未自主实现文件上传下载对应的功能，而是调用了 apache 文件上传下载组件</li>
</ul>
<p>文件上传下载实现：</p>
<ul>
<li><p>导入坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>页面表单 fileupload.jsp</p>
<pre><code class="html">&lt;form method=&quot;post&quot; action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
</li>
<li><p>web.xml</p>
<pre><code class="xml">DispatcherServlet + CharacterEncodingFilter
</code></pre>
</li>
<li><p>控制器</p>
<pre><code class="java">@PostMapping(&quot;/upload&quot;)
public String upload(@RequestParam(&quot;email&quot;) String email,
                     @RequestParam(&quot;username&quot;) String username,
                     @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg) throws IOException &#123;

    if(!headerImg.isEmpty())&#123;
        //保存到文件服务器，OSS服务器
        String originalFilename = headerImg.getOriginalFilename();
        headerImg.transferTo(new File(&quot;H:\\cache\\&quot; + originalFilename));
    &#125;
    return &quot;main&quot;;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="名称问题"><a href="#名称问题" class="headerlink" title="名称问题"></a>名称问题</h3><p>MultipartFile 参数中封装了上传的文件的相关信息。</p>
<ol>
<li><p>文件命名问题， 获取上传文件名，并解析文件名与扩展名</p>
<pre><code class="java">file.getOriginalFilename();
</code></pre>
</li>
<li><p>文件名过长问题</p>
</li>
<li><p>文件保存路径</p>
<pre><code class="java">ServletContext context = request.getServletContext();
String realPath = context.getRealPath(&quot;/uploads&quot;);
File file = new File(realPath + &quot;/&quot;);
if(!file.exists()) file.mkdirs();
</code></pre>
</li>
<li><p>重名问题</p>
<pre><code class="java">String uuid = UUID.randomUUID.toString().replace(&quot;-&quot;, &quot;&quot;).toUpperCase();
</code></pre>
</li>
</ol>
<pre><code class="java">@Controller
public class FileUploadController &#123;
    @RequestMapping(value = &quot;/fileupload&quot;)
    //参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，表单名称与参数名相同
    public String fileupload(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request) throws IOException &#123;
        System.out.println(&quot;file upload is running ...&quot;+file);
//        MultipartFile参数中封装了上传的文件的相关信息
//        System.out.println(file.getSize());
//        System.out.println(file.getBytes().length);
//        System.out.println(file.getContentType());
//        System.out.println(file.getName());
//        System.out.println(file.getOriginalFilename());
//        System.out.println(file.isEmpty());
        //首先判断是否是空文件，也就是存储空间占用为0的文件
        if(!file.isEmpty())&#123;
            //如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现）
            //获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用
            String fileName = file.getOriginalFilename();
            //设置保存的路径
            String realPath = request.getServletContext().getRealPath(&quot;/images&quot;);
            //保存文件的方法，通常文件名使用随机生成策略产生，避免文件名冲突问题
            file.transferTo(new File(realPath,file.getOriginalFilename()));
        &#125;
        //测试一次性上传多个文件
        if(!file1.isEmpty())&#123;
            String fileName = file1.getOriginalFilename();
            //可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可
            String realPath = request.getServletContext().getRealPath(&quot;/images&quot;);
            file1.transferTo(new File(realPath,file1.getOriginalFilename()));
        &#125;
        if(!file2.isEmpty())&#123;
            String fileName = file2.getOriginalFilename();
            String realPath = request.getServletContext().getRealPath(&quot;/images&quot;);
            file2.transferTo(new File(realPath,file2.getOriginalFilename()));
        &#125;
        return &quot;page.jsp&quot;;
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="源码解析-3"><a href="#源码解析-3" class="headerlink" title="源码解析"></a>源码解析</h3><p>StandardServletMultipartResolver 是文件上传解析器</p>
<p>DispatcherServlet#doDispatch：</p>
<pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
    // 判断当前请求是不是文件上传请求
    processedRequest = checkMultipart(request);
    // 文件上传请求会对 request 进行包装，导致两者不相等，此处赋值为 true，代表已经被解析
    multipartRequestParsed = (processedRequest != request);
&#125;
</code></pre>
<p>DispatcherServlet#checkMultipart：</p>
<ul>
<li><code>if (this.multipartResolver != null &amp;&amp; this.multipartResolver.isMultipart(request))</code>：判断是否是文件请求<ul>
<li><code>StandardServletMultipartResolver#isMultipart</code>：根据开头是否符合 multipart&#x2F;form-data 或者 multipart&#x2F;</li>
</ul>
</li>
<li><code>return this.multipartResolver.resolveMultipart(request)</code>：把请求封装成 StandardMultipartHttpServletRequest 对象</li>
</ul>
<p>开始执行 ha.handle() 目标方法进行数据的解析</p>
<ul>
<li><p>RequestPartMethodArgumentResolver#supportsParameter：支持解析文件上传数据</p>
<pre><code class="java">public boolean supportsParameter(MethodParameter parameter) &#123;
    // 参数上有 @RequestPart 注解
    if (parameter.hasParameterAnnotation(RequestPart.class)) &#123;
        return true;
    &#125;
&#125;
</code></pre>
</li>
<li><p>RequestPartMethodArgumentResolver#resolveArgument：解析参数数据，封装成 MultipartFile 对象</p>
<ul>
<li><code>RequestPart requestPart = parameter.getParameterAnnotation(RequestPart.class)</code>：获取注解的相关信息</li>
<li><code>String name = getPartName(parameter, requestPart)</code>：获取上传文件的名字</li>
<li><code>Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument()</code>：解析参数<ul>
<li><code>List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name)</code>：获取文件的所有数据</li>
</ul>
</li>
</ul>
</li>
<li><p><code>return doInvoke(args)</code>：解析完成执行自定义的方法，完成上传功能</p>
</li>
</ul>
<hr>
</div><h2 id="实用技术"><a href="#实用技术" class="headerlink" title="实用技术"></a>实用技术</h2><div class="story post-story"><h3 id="校验框架"><a href="#校验框架" class="headerlink" title="校验框架"></a>校验框架</h3><h4 id="校验概述"><a href="#校验概述" class="headerlink" title="校验概述"></a>校验概述</h4><p>表单校验保障了数据有效性、安全性  </p>
<p>校验分类：客户端校验和服务端校验</p>
<ul>
<li>格式校验<ul>
<li>客户端：使用 js 技术，利用正则表达式校验</li>
<li>服务端：使用校验框架</li>
</ul>
</li>
<li>逻辑校验<ul>
<li>客户端：使用ajax发送要校验的数据，在服务端完成逻辑校验，返回校验结果</li>
<li>服务端：接收到完整的请求后，在执行业务操作前，完成逻辑校验</li>
</ul>
</li>
</ul>
<p>表单校验框架：</p>
<ul>
<li><p>JSR（Java Specification Requests）：Java 规范提案 </p>
</li>
<li><p>303：提供bean属性相关校验规则</p>
</li>
<li><p>JCP（Java Community Process）：Java社区</p>
</li>
<li><p>Hibernate框架中包含一套独立的校验框架hibernate-validator </p>
</li>
<li><p>导入坐标：</p>
<pre><code class="xml">&lt;!--导入校验的jsr303规范--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.validation&lt;/groupId&gt;
    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--导入校验框架实现技术--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;6.1.0.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>tomcat7：搭配 hibernate-validator 版本 5.<em>.</em>.Final</li>
<li>tomcat8.5：搭配 hibernate-validator 版本 6.<em>.</em>.Final</li>
</ul>
<hr>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="开启校验"><a href="#开启校验" class="headerlink" title="开启校验"></a>开启校验</h5><p>名称：@Valid、@Validated</p>
<p>类型：形参注解</p>
<p>位置：处理器类中的实体类类型的方法形参前方</p>
<p>作用：设定对当前实体类类型参数进行校验</p>
<p>范例：  </p>
<pre><code class="java">@RequestMapping(value = &quot;/addemployee&quot;)
public String addEmployee(@Valid Employee employee) &#123;
    System.out.println(employee);
&#125;
</code></pre>
<h5 id="校验规则"><a href="#校验规则" class="headerlink" title="校验规则"></a>校验规则</h5><p>名称：@NotNull</p>
<p>类型：属性注解等</p>
<p>位置：实体类属性上方</p>
<p>作用：设定当前属性校验规则</p>
<p>范例：每个校验规则所携带的参数不同，根据校验规则进行相应的调整，具体的校验规则查看对应的校验框架进行获取</p>
<pre><code class="java">public class Employee&#123;
    @NotNull(message = &quot;姓名不能为空&quot;)
    private String name;//员工姓名
&#125;  
</code></pre>
<h5 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h5><pre><code class="java">@RequestMapping(value = &quot;/addemployee&quot;)
//Errors对象用于封装校验结果，如果不满足校验规则，对应的校验结果封装到该对象中，包含校验的属性名和校验不通过返回的消息
public String addEmployee(@Valid Employee employee, Errors errors, Model model)&#123;
    System.out.println(employee);
    //判定Errors对象中是否存在未通过校验的字段
    if(errors.hasErrors())&#123;
        for(FieldError error : errors.getFieldErrors())&#123;
            //将校验结果添加到Model对象中，用于页面显示，返回json数据即可
            model.addAttribute(error.getField(),error.getDefaultMessage());
        &#125;
        //当出现未通过校验的字段时，跳转页面到原始页面，进行数据回显
        return &quot;addemployee.jsp&quot;;
    &#125;
    return &quot;success.jsp&quot;;
&#125;  
</code></pre>
<p>通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示，页面获取后台封装的校验结果信息  </p>
<pre><code class="html">&lt;form action=&quot;/addemployee&quot; method=&quot;post&quot;&gt;
    员工姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;span style=&quot;color:red&quot;&gt;$&#123;name&#125;&lt;/span&gt;&lt;br/&gt;
    员工年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;span style=&quot;color:red&quot;&gt;$&#123;age&#125;&lt;/span&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<hr>
<h4 id="多规则校验"><a href="#多规则校验" class="headerlink" title="多规则校验"></a>多规则校验</h4><ul>
<li><p>同一个属性可以添加多个校验器  </p>
<pre><code class="java">public class Employee&#123;
    @NotBlank(message = &quot;姓名不能为空&quot;)
    private String name;//员工姓名

    @NotNull(message = &quot;请输入年龄&quot;)
    @Max(value = 60,message = &quot;年龄最大值60&quot;)
    @Min(value = 18,message = &quot;年龄最小值18&quot;)
    private Integer age;//员工年龄
&#125;
</code></pre>
</li>
<li><p>三种判定空校验器的区别<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E4%B8%89%E7%A7%8D%E5%88%A4%E5%AE%9A%E7%A9%BA%E6%A3%80%E9%AA%8C%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E4%B8%89%E7%A7%8D%E5%88%A4%E5%AE%9A%E7%A9%BA%E6%A3%80%E9%AA%8C%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
</ul>
<hr>
<h4 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h4><p>名称：@Valid</p>
<p>类型：属性注解</p>
<p>位置：实体类中的引用类型属性上方</p>
<p>作用：设定当前应用类型属性中的属性开启校验</p>
<p>范例：</p>
<pre><code class="java">public class Employee &#123;
    //实体类中的引用类型通过标注@Valid注解，设定开启当前引用类型字段中的属性参与校验
    @Valid
    private Address address;
&#125;
</code></pre>
<p>注意：开启嵌套校验后，被校验对象内部需要添加对应的校验规则  </p>
<pre><code class="java">//嵌套校验的实体中，对每个属性正常添加校验规则即可
public class Address implements Serializable &#123;
    @NotBlank(message = &quot;请输入省份名称&quot;)
    private String provinceName;//省份名称

    @NotBlank(message = &quot;请输入邮政编码&quot;)
    @Size(max = 6,min = 6,message = &quot;邮政编码由6位组成&quot;)
    private String zipCode;//邮政编码
&#125;
</code></pre>
<hr>
<h4 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h4><p>分组校验的介绍</p>
<ul>
<li>同一个模块，根据执行的业务不同，需要校验的属性会有不同<ul>
<li>新增用户</li>
<li>修改用户</li>
</ul>
</li>
<li>对不同种类的属性进行分组，在校验时可以指定参与校验的字段所属的组类别<ul>
<li>定义组（通用）</li>
<li>为属性设置所属组，可以设置多个</li>
<li>开启组校验</li>
</ul>
</li>
</ul>
<p>domain：</p>
<pre><code class="java">//用于设定分组校验中的组名，当前接口仅提供字节码，用于识别
public interface GroupOne &#123;
&#125;
</code></pre>
<pre><code class="java">public class Employee&#123;
    @NotBlank(message = &quot;姓名不能为空&quot;,groups = &#123;GroupA.class&#125;)
    private String name;//员工姓名

    @NotNull(message = &quot;请输入年龄&quot;,groups = &#123;GroupA.class&#125;)
    @Max(value = 60,message = &quot;年龄最大值60&quot;)//不加Group的校验不生效
    @Min(value = 18,message = &quot;年龄最小值18&quot;)
    private Integer age;//员工年龄

    @Valid
    private Address address;
    //......
&#125;
</code></pre>
<p>controller：</p>
<pre><code class="java">@Controller
public class EmployeeController &#123;
    @RequestMapping(value = &quot;/addemployee&quot;)
    public String addEmployee(@Validated(&#123;GroupA.class&#125;) Employee employee, Errors errors, Model m)&#123;
        if(errors.hasErrors())&#123;
            List&lt;FieldError&gt; fieldErrors = errors.getFieldErrors();
            System.out.println(fieldErrors.size());
            for(FieldError error : fieldErrors)&#123;
                m.addAttribute(error.getField(),error.getDefaultMessage());
            &#125;
            return &quot;addemployee.jsp&quot;;
        &#125;
        return &quot;success.jsp&quot;;
    &#125;
&#125;
</code></pre>
<p>jsp：</p>
<pre><code class="html">&lt;form action=&quot;/addemployee&quot; method=&quot;post&quot;&gt;&lt;%--页面使用$&#123;&#125;获取后台传递的校验信息--%&gt;
    员工姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;span style=&quot;color:red&quot;&gt;$&#123;name&#125;&lt;/span&gt;&lt;br/&gt;
    员工年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;span style=&quot;color:red&quot;&gt;$&#123;age&#125;&lt;/span&gt;&lt;br/&gt;
    &lt;%--注意，引用类型的校验未通过信息不是通过对象进行封装的，直接使用对象名.属性名的格式作为整体属性字符串进行保存的，和使用者的属性传递方式有关，不具有通用性，仅适用于本案例--%&gt;
    省：&lt;input type=&quot;text&quot; name=&quot;address.provinceName&quot;&gt;&lt;span style=&quot;color:red&quot;&gt;$&#123;requestScope[&#39;address.provinceName&#39;]&#125;&lt;/span&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
/form&gt;
</code></pre>
<hr>
<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>Lombok 用标签方式代替构造器、getter&#x2F;setter、toString() 等方法</p>
<p>引入依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>下载插件：IDEA 中 File → Settings → Plugins，搜索安装 Lombok 插件</p>
<p>常用注解：</p>
<pre><code class="java">@NoArgsConstructor        // 无参构造
@AllArgsConstructor        // 全参构造
@Data                    // set + get
@ToString                // toString
@EqualsAndHashCode        // hashConde + equals
</code></pre>
<p>简化日志：</p>
<pre><code class="java">@Slf4j
@RestController
public class HelloController &#123;
    @RequestMapping(&quot;/hello&quot;)
    public String handle01(@RequestParam(&quot;name&quot;) String name)&#123;
        log.info(&quot;请求进来了....&quot;);
        return &quot;Hello, Spring!&quot; + &quot;你好：&quot; + name;
    &#125;
&#125;
</code></pre>
<hr>
<h1 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h1></div><h2 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h2><div class="story post-story"><h3 id="Boot介绍"><a href="#Boot介绍" class="headerlink" title="Boot介绍"></a>Boot介绍</h3><p>SpringBoot 提供了一种快速使用 Spring 的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率</p>
<p>SpringBoot 功能：</p>
<ul>
<li><p>自动配置，自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素选择使用哪个配置，该过程是SpringBoot 自动完成的</p>
</li>
<li><p>起步依赖，起步依赖本质上是一个 Maven 项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能</p>
</li>
<li><p>辅助功能，提供了一些大型项目中常见的非功能性特性，如内嵌 web 服务器、安全、指标，健康检测、外部配置等</p>
</li>
</ul>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a></p>
<hr>
<h3 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h3><p>普通构建：</p>
<ol>
<li><p>创建 Maven 项目</p>
</li>
<li><p>导入 SpringBoot 起步依赖</p>
<pre><code class="xml">&lt;!--springboot 工程需要继承的父工程--&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;!--web 开发的起步依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</li>
<li><p>定义 Controller</p>
<pre><code class="java">@RestController
public class HelloController &#123;
    @RequestMapping(&quot;/hello&quot;)
    public String hello()&#123;
        return &quot; hello Spring Boot !&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>编写引导类</p>
<pre><code class="java">// 引导类，SpringBoot项目的入口
@SpringBootApplication
public class HelloApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(HelloApplication.class, args);
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p>快速构建：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-IDEA%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-IDEA%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<hr>
</div><h2 id="自动装配-1"><a href="#自动装配-1" class="headerlink" title="自动装配"></a>自动装配</h2><div class="story post-story"><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在 spring-boot-starter-parent 中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。在各种 starter 中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。工程继承 parent，引入 starter 后，通过依赖传递，就可以简单方便获得需要的 jar 包，并且不会存在版本冲突，自动版本仲裁机制</p>
<hr>
<h3 id="底层注解"><a href="#底层注解" class="headerlink" title="底层注解"></a>底层注解</h3><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>@SpringBootApplication：启动注解，实现 SpringBoot 的自动部署</p>
<ul>
<li>参数 scanBasePackages：可以指定扫描范围</li>
<li>默认扫描当前引导类所在包及其子包</li>
</ul>
<p>假如所在包为 com.example.springbootenable，扫描配置包 com.example.config 的信息，三种解决办法：</p>
<ol>
<li><p>使用 @ComponentScan 扫描 com.example.config 包</p>
</li>
<li><p>使用 @Import 注解加载类，这些类都会被 Spring 创建并放入 ioc 容器，默认组件的名字就是<strong>全类名</strong></p>
</li>
<li><p>对 @Import 注解进行封装</p>
</li>
</ol>
<pre><code class="java">//1.@ComponentScan(&quot;com.example.config&quot;)
//2.@Import(UserConfig.class)
@EnableUser
@SpringBootApplication
public class SpringbootEnableApplication &#123;

    public static void main(String[] args) &#123;
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args);
        //获取Bean
        Object user = context.getBean(&quot;user&quot;);
        System.out.println(user);

    &#125;
&#125;
</code></pre>
<p>UserConfig：</p>
<pre><code class="java">@Configuration
public class UserConfig &#123;
    @Bean
    public User user() &#123;
        return new User();
    &#125;
&#125;
</code></pre>
<p>EnableUser 注解类：</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(UserConfig.class)//@Import注解实现Bean的动态加载
public @interface EnableUser &#123;
&#125;
</code></pre>
<hr>
<h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>@Configuration：设置当前类为 SpringBoot 的配置类</p>
<ul>
<li>proxyBeanMethods &#x3D; true：Full 全模式，每个 @Bean 方法被调用多少次返回的组件都是单实例的，默认值，类组件之间<strong>有依赖关系</strong>，方法会被调用得到之前单实例组件</li>
<li>proxyBeanMethods &#x3D; false：Lite 轻量级模式，每个 @Bean 方法被调用多少次返回的组件都是新创建的，类组件之间<strong>无依赖关系</strong>用 Lite 模式加速容器启动过程</li>
</ul>
<pre><code class="java">@Configuration(proxyBeanMethods = true)
public class MyConfig &#123;
    @Bean //给容器中添加组件。以方法名作为组件的 id。返回类型就是组件类型。返回的值，就是组件在容器中的实例
    public User user()&#123;
        User user = new User(&quot;zhangsan&quot;, 18);
        return user;
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><h5 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h5><p>Condition 是 Spring4.0 后引入的条件化配置接口，通过实现 Condition 接口可以完成有条件的加载相应的 Bean</p>
<p>注解：@Conditional</p>
<p>作用：条件装配，满足 Conditional 指定的条件则进行组件注入，加上方法或者类上，作用范围不同</p>
<p>使用：@Conditional 配合 Condition 的实现类（ClassCondition）进行使用</p>
<p>ConditionContext 类API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ConfigurableListableBeanFactory  getBeanFactory()</td>
<td>获取到 IOC 使用的 beanfactory</td>
</tr>
<tr>
<td>ClassLoader getClassLoader()</td>
<td>获取类加载器</td>
</tr>
<tr>
<td>Environment getEnvironment()</td>
<td>获取当前环境信息</td>
</tr>
<tr>
<td>BeanDefinitionRegistry getRegistry()</td>
<td>获取到 bean 定义的注册类</td>
</tr>
</tbody></table>
<ul>
<li><p>ClassCondition：</p>
<pre><code class="java">public class ClassCondition implements Condition &#123;
    /**
     * context 上下文对象。用于获取环境，IOC容器，ClassLoader对象
     * metadata 注解元对象。 可以用于获取注解定义的属性值
     */
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;
      
        //1.需求： 导入Jedis坐标后创建Bean
        //思路：判断redis.clients.jedis.Jedis.class文件是否存在
        boolean flag = true;
        try &#123;
            Class&lt;?&gt; cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            flag = false;
        &#125;
        return flag;
    &#125;
&#125;
</code></pre>
</li>
<li><p>UserConfig：</p>
<pre><code class="java">@Configuration
public class UserConfig &#123;
    @Bean
    @Conditional(ClassCondition.class)
    public User user()&#123;
        return new User();
    &#125;
&#125;
</code></pre>
</li>
<li><p>启动类：</p>
<pre><code class="java">@SpringBootApplication
public class SpringbootConditionApplication &#123;
    public static void main(String[] args) &#123;
        //启动SpringBoot应用，返回Spring的IOC容器
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootConditionApplication.class, args);

        Object user = context.getBean(&quot;user&quot;);
        System.out.println(user);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><p>将类的判断定义为动态的，判断哪个字节码文件存在可以动态指定</p>
<ul>
<li><p>自定义条件注解类</p>
<pre><code class="java">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(ClassCondition.class)
public @interface ConditionOnClass &#123;
    String[] value();
&#125;
</code></pre>
</li>
<li><p>ClassCondition</p>
<pre><code class="java">public class ClassCondition implements Condition &#123;
    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata) &#123;

        //需求：通过注解属性值value指定坐标后创建bean
        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes
                                (ConditionOnClass.class.getName());
        //map = &#123;value=&#123;属性值&#125;&#125;
        //获取所有的
        String[] value = (String[]) map.get(&quot;value&quot;);

        boolean flag = true;
        try &#123;
            for (String className : value) &#123;
                Class&lt;?&gt; cls = Class.forName(className);
            &#125;
        &#125; catch (Exception e) &#123;
            flag = false;
        &#125;
        return flag;
    &#125;
&#125;
</code></pre>
</li>
<li><p>UserConfig</p>
<pre><code class="java">@Configuration
public class UserConfig &#123;
    @Bean
    @ConditionOnClass(&quot;com.alibaba.fastjson.JSON&quot;)//JSON加载了才注册 User 到容器
    public User user()&#123;
        return new User();
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试 User 对象的创建</p>
</li>
</ul>
<hr>
<h5 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h5><p>SpringBoot 提供的常用条件注解：</p>
<p>@ConditionalOnProperty：判断<strong>配置文件</strong>中是否有对应属性和值才初始化 Bean</p>
<pre><code class="java">@Configuration
public class UserConfig &#123;
    @Bean
    @ConditionalOnProperty(name = &quot;it&quot;, havingValue = &quot;seazean&quot;)
    public User user() &#123;
        return new User();
    &#125;
&#125;
</code></pre>
<pre><code class="properties">it=seazean
</code></pre>
<p>@ConditionalOnClass：判断环境中是否有对应类文件才初始化 Bean</p>
<p>@ConditionalOnMissingClass：判断环境中是否有对应类文件才初始化 Bean</p>
<p>@ConditionalOnMissingBean：判断环境中没有对应Bean才初始化 Bean</p>
<hr>
<h4 id="ImportRes"><a href="#ImportRes" class="headerlink" title="ImportRes"></a>ImportRes</h4><p>使用 bean.xml 文件生成配置 bean，如果需要继续复用 bean.xml，@ImportResource 导入配置文件即可</p>
<pre><code class="java">@ImportResource(&quot;classpath:beans.xml&quot;)
public class MyConfig &#123;
    //...
&#125;
</code></pre>
<pre><code class="xml">&lt;beans ...&gt;
    &lt;bean id=&quot;haha&quot; class=&quot;com.lun.boot.bean.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;hehe&quot; class=&quot;com.lun.boot.bean.Pet&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;tomcat&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<hr>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>@ConfigurationProperties：读取到 properties 文件中的内容，并且封装到 JavaBean 中</p>
<p>配置文件：</p>
<pre><code class="properties">mycar.brand=BYD
mycar.price=100000
</code></pre>
<p>JavaBean 类：</p>
<pre><code class="java">@Component    //导入到容器内
@ConfigurationProperties(prefix = &quot;mycar&quot;)//代表配置文件的前缀
public class Car &#123;
    private String brand;
    private Integer price;
&#125;
</code></pre>
<hr>
<h3 id="装配原理"><a href="#装配原理" class="headerlink" title="装配原理"></a>装配原理</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>应用启动：</p>
<pre><code class="java">@SpringBootApplication
public class BootApplication &#123;
    public static void main(String[] args) &#123;
        // 启动代码
        SpringApplication.run(BootApplication.class, args);
    &#125;
&#125;
</code></pre>
<p>SpringApplication 构造方法：</p>
<ul>
<li><p><code>this.resourceLoader = resourceLoader</code>：资源加载器，初始为 null</p>
</li>
<li><p><code>this.webApplicationType = WebApplicationType.deduceFromClasspath()</code>：判断当前应用的类型，是响应式还是 Web 类</p>
</li>
<li><p><code>this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories()</code>：<strong>获取引导器</strong></p>
<ul>
<li>去 <strong><code>META-INF/spring.factories</code></strong> 文件中找 org.springframework.boot.Bootstrapper</li>
<li>寻找的顺序：classpath → spring-beans → boot-devtools → springboot → boot-autoconfigure</li>
</ul>
</li>
<li><p><code>setInitializers(getSpringFactoriesInstances(ApplicationContextInitializer.class))</code>：<strong>获取初始化器</strong></p>
<ul>
<li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.context.ApplicationContextInitializer</li>
</ul>
</li>
<li><p><code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))</code>：<strong>获取监听器</strong></p>
<ul>
<li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.context.ApplicationListener</li>
</ul>
</li>
<li><p><code>this.mainApplicationClass = deduceMainApplicationClass()</code>：获取出 main 程序类</p>
</li>
</ul>
<p>SpringApplication#run(String… args)：创建 IOC 容器并实现了自动装配</p>
<ul>
<li><p><code>StopWatch stopWatch = new StopWatch()</code>：停止监听器，<strong>监控整个应用的启停</strong></p>
</li>
<li><p><code>stopWatch.start()</code>：记录应用的启动时间</p>
</li>
<li><p><code>bootstrapContext = createBootstrapContext()</code>：<strong>创建引导上下文环境</strong></p>
<ul>
<li><code>bootstrapContext = new DefaultBootstrapContext()</code>：创建默认的引导类环境</li>
<li><code>this.bootstrapRegistryInitializers.forEach()</code>：遍历所有的引导器调用 initialize 方法完成初始化设置</li>
</ul>
</li>
<li><p><code>configureHeadlessProperty()</code>：让当前应用进入 headless 模式</p>
</li>
<li><p><code>listeners = getRunListeners(args)</code>：<strong>获取所有 RunListener（运行监听器）</strong></p>
<ul>
<li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.boot.SpringApplicationRunListener</li>
</ul>
</li>
<li><p><code>listeners.starting(bootstrapContext, this.mainApplicationClass)</code>：遍历所有的运行监听器调用 starting 方法</p>
</li>
<li><p><code>applicationArguments = new DefaultApplicationArguments(args)</code>：获取所有的命令行参数</p>
</li>
<li><p><code>environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments)</code>：<strong>准备环境</strong></p>
<ul>
<li><p><code>environment = getOrCreateEnvironment()</code>：返回或创建基础环境信息对象</p>
<ul>
<li><code>switch (this.webApplicationType)</code>：<strong>根据当前应用的类型创建环境</strong><ul>
<li><code>case SERVLET</code>：Web 应用环境对应 ApplicationServletEnvironment</li>
<li><code>case REACTIVE</code>：响应式编程对应 ApplicationReactiveWebEnvironment</li>
<li><code>default</code>：默认为 Spring 环境 ApplicationEnvironment</li>
</ul>
</li>
</ul>
</li>
<li><p><code>configureEnvironment(environment, applicationArguments.getSourceArgs())</code>：读取所有配置源的属性值配置环境</p>
</li>
<li><p><code>ConfigurationPropertySources.attach(environment)</code>：属性值绑定环境信息</p>
<ul>
<li><code>sources.addFirst(ATTACHED_PROPERTY_SOURCE_NAME,..)</code>：把 configurationProperties 放入环境的属性信息头部</li>
</ul>
</li>
<li><p><code>listeners.environmentPrepared(bootstrapContext, environment)</code>：运行监听器调用 environmentPrepared()，EventPublishingRunListener 发布事件通知所有的监听器当前环境准备完成</p>
</li>
<li><p><code>DefaultPropertiesPropertySource.moveToEnd(environment)</code>：移动 defaultProperties 属性源到环境中的最后一个源</p>
</li>
<li><p><code>bindToSpringApplication(environment)</code>：与容器绑定当前环境</p>
</li>
<li><p><code>ConfigurationPropertySources.attach(environment)</code>：重新将属性值绑定环境信息</p>
</li>
<li><p><code>sources.remove(ATTACHED_PROPERTY_SOURCE_NAME)</code>：从环境信息中移除 configurationProperties </p>
</li>
<li><p><code>sources.addFirst(ATTACHED_PROPERTY_SOURCE_NAME,..)</code>：把 configurationProperties 重新放入环境信息</p>
</li>
</ul>
</li>
<li><p><code>configureIgnoreBeanInfo(environment)</code>：<strong>配置忽略的 bean</strong></p>
</li>
<li><p><code>printedBanner = printBanner(environment)</code>：打印 SpringBoot 标志</p>
</li>
<li><p><code>context = createApplicationContext()</code>：<strong>创建 IOC 容器</strong></p>
<p><code>switch (this.webApplicationType)</code>：根据当前应用的类型创建 IOC 容器</p>
<ul>
<li><code>case SERVLET</code>：Web 应用环境对应 AnnotationConfigServletWebServerApplicationContext</li>
<li><code>case REACTIVE</code>：响应式编程对应 AnnotationConfigReactiveWebServerApplicationContext</li>
<li><code>default</code>：默认为 Spring 环境 AnnotationConfigApplicationContext</li>
</ul>
</li>
<li><p><code>context.setApplicationStartup(this.applicationStartup)</code>：设置一个启动器</p>
</li>
<li><p><code>prepareContext()</code>：配置 IOC 容器的基本信息</p>
<ul>
<li><p><code>postProcessApplicationContext(context)</code>：后置处理流程</p>
</li>
<li><p><code>applyInitializers(context)</code>：获取所有的<strong>初始化器调用 initialize() 方法</strong>进行初始化</p>
</li>
<li><p><code>listeners.contextPrepared(context)</code>：所有的运行监听器调用 environmentPrepared() 方法，EventPublishingRunListener 发布事件通知 IOC 容器准备完成</p>
</li>
<li><p><code>listeners.contextLoaded(context)</code>：所有的运行监听器调用 contextLoaded() 方法，通知 IOC 加载完成</p>
</li>
</ul>
</li>
<li><p><code>refreshContext(context)</code>：<strong>刷新 IOC 容器</strong></p>
<ul>
<li>Spring 的容器启动流程</li>
<li><code>invokeBeanFactoryPostProcessors(beanFactory)</code>：<strong>实现了自动装配</strong></li>
<li><code>onRefresh()</code>：<strong>创建 WebServer</strong> 使用该接口</li>
</ul>
</li>
<li><p><code>afterRefresh(context, applicationArguments)</code>：留给用户自定义容器刷新完成后的处理逻辑</p>
</li>
<li><p><code>stopWatch.stop()</code>：记录应用启动完成的时间</p>
</li>
<li><p><code>callRunners(context, applicationArguments)</code>：调用所有 runners</p>
</li>
<li><p><code>listeners.started(context)</code>：所有的运行监听器调用 started() 方法</p>
</li>
<li><p><code>listeners.running(context)</code>：所有的运行监听器调用 running() 方法</p>
<ul>
<li><p>获取容器中的 ApplicationRunner、CommandLineRunner</p>
</li>
<li><p><code>AnnotationAwareOrderComparator.sort(runners)</code>：合并所有 runner 并且按照 @Order 进行排序</p>
</li>
<li><p><code>callRunner()</code>：遍历所有的 runner，调用 run 方法</p>
</li>
</ul>
</li>
<li><p><code>handleRunFailure(context, ex, listeners)</code>：<strong>处理异常</strong>，出现异常进入该逻辑</p>
<ul>
<li><code>handleExitCode(context, exception)</code>：处理错误代码</li>
<li><code>listeners.failed(context, exception)</code>：运行监听器调用 failed() 方法</li>
<li><code>reportFailure(getExceptionReporters(context), exception)</code>：通知异常</li>
</ul>
</li>
</ul>
<hr>
<h4 id="注解分析"><a href="#注解分析" class="headerlink" title="注解分析"></a>注解分析</h4><p>SpringBoot 定义了一套接口规范，这套规范规定 SpringBoot 在启动时会扫描外部引用 jar 包中的 <code>META-INF/spring.factories</code> 文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作，对于外部的 jar 包，直接引入一个 starter 即可</p>
<p>@SpringBootApplication 注解是 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合</p>
<ul>
<li><p>@SpringBootApplication 注解</p>
<pre><code class="java">@Inherited
@SpringBootConfiguration    //代表 @SpringBootApplication 拥有了该注解的功能
@EnableAutoConfiguration    //同理
@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)
// 扫描被 @Component (@Service,@Controller)注解的 bean，容器中将排除TypeExcludeFilter 和 AutoConfigurationExcludeFilter
public @interface SpringBootApplication &#123; &#125;
</code></pre>
</li>
<li><p>@SpringBootConfiguration 注解：</p>
<pre><code class="java">@Configuration    // 代表是配置类
@Indexed
public @interface SpringBootConfiguration &#123;
    @AliasFor(annotation = Configuration.class)
    boolean proxyBeanMethods() default true;
&#125;
</code></pre>
<p>@AliasFor 注解：表示别名，可以注解到自定义注解的两个属性上表示这两个互为别名，两个属性其实是同一个含义相互替代</p>
</li>
<li><p>@ComponentScan 注解：默认扫描当前类所在包及其子级包下的所有文件</p>
</li>
<li><p><strong>@EnableAutoConfiguration 注解：启用 SpringBoot 的自动配置机制</strong></p>
<pre><code class="java">@AutoConfigurationPackage    
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration &#123; 
    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;
    Class&lt;?&gt;[] exclude() default &#123;&#125;; 
    String[] excludeName() default &#123;&#125;;
&#125;
</code></pre>
<ul>
<li><p>@AutoConfigurationPackage：<strong>将添加该注解的类所在的 package 作为自动配置 package 进行管理</strong>，把启动类所在的包设置一次，为了给各种自动配置的第三方库扫描用，比如带 @Mapper 注解的类，Spring 自身是不能识别的，但自动配置的 Mybatis 需要扫描用到，而 ComponentScan 只是用来扫描注解类，并没有提供接口给三方使用</p>
<pre><code class="java">@Import(AutoConfigurationPackages.Registrar.class)    // 利用 Registrar 给容器中导入组件
public @interface AutoConfigurationPackage &#123; 
    String[] basePackages() default &#123;&#125;;    //自动配置包，指定了配置类的包
    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;
&#125;
</code></pre>
<p><code>register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]))</code>：注册 BD</p>
<ul>
<li><code>new PackageImports(metadata).getPackageNames()</code>：获取添加当前注解的类的所在包</li>
<li><code>registry.registerBeanDefinition(BEAN, new BasePackagesBeanDefinition(packageNames))</code>：存放到容器中<ul>
<li><code>new BasePackagesBeanDefinition(packageNames)</code>：把当前主类所在的包名封装到该对象中</li>
</ul>
</li>
</ul>
</li>
<li><p>@Import(AutoConfigurationImportSelector.class)：<strong>自动装配的核心类</strong></p>
<p>容器刷新时执行：<strong>invokeBeanFactoryPostProcessors()</strong> → invokeBeanDefinitionRegistryPostProcessors() → postProcessBeanDefinitionRegistry() → processConfigBeanDefinitions() → parse() → process() → processGroupImports() → getImports() → process() → <strong>AutoConfigurationImportSelector#getAutoConfigurationEntry()</strong></p>
<pre><code class="java">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;
    if (!isEnabled(annotationMetadata)) &#123;
        return EMPTY_ENTRY;
    &#125;
    // 获取注解属性，@SpringBootApplication 注解的 exclude 属性和 excludeName 属性
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    // 获取所有需要自动装配的候选项
    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
    // 去除重复的选项
    configurations = removeDuplicates(configurations);
    // 获取注解配置的排除的自动装配类
    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    // 移除所有的配置的不需要自动装配的类
    configurations.removeAll(exclusions);
    // 过滤，条件装配
    configurations = getConfigurationClassFilter().filter(configurations);
    // 获取 AutoConfigurationImportListener 类的监听器调用 onAutoConfigurationImportEvent 方法
    fireAutoConfigurationImportEvents(configurations, exclusions);
    // 包装成 AutoConfigurationEntry 返回
    return new AutoConfigurationEntry(configurations, exclusions);
&#125;
</code></pre>
<p>AutoConfigurationImportSelector#getCandidateConfigurations：<strong>获取自动配置的候选项</strong></p>
<ul>
<li><p><code>List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames()</code>：加载自动配置类</p>
<p>参数一：<code>getSpringFactoriesLoaderFactoryClass()</code>：获取 @EnableAutoConfiguration 注解类</p>
<p>参数二：<code>getBeanClassLoader()</code>：获取类加载器</p>
<ul>
<li><code>factoryTypeName = factoryType.getName()</code>：@EnableAutoConfiguration 注解的全类名</li>
<li><code>return loadSpringFactories(classLoaderToUse).getOrDefault()</code>：加载资源<ul>
<li><code>urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION)</code>：获取资源类</li>
<li><code>FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;</code>：<strong>加载的资源的位置</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><code>return configurations</code>：返回所有自动装配类的候选项</p>
</li>
</ul>
</li>
<li><p>从 spring-boot-autoconfigure-2.5.3.jar&#x2F;META-INF&#x2F;spring.factories 文件中寻找 EnableAutoConfiguration 字段，获取自动装配类，<strong>进行条件装配，按需装配</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="装配流程"><a href="#装配流程" class="headerlink" title="装配流程"></a>装配流程</h4><p>Spring Boot 通过 <code>@EnableAutoConfiguration</code> 开启自动装配，通过 SpringFactoriesLoader 加载 <code>META-INF/spring.factories</code> 中的自动配置类实现自动装配，自动配置类其实就是通过 <code>@Conditional</code> 注解按需加载的配置类，想要其生效必须引入 <code>spring-boot-starter-xxx</code> 包实现起步依赖</p>
<ul>
<li>SpringBoot 先加载所有的自动配置类 xxxxxAutoConfiguration</li>
<li>每个自动配置类进行<strong>条件装配</strong>，默认都会绑定配置文件指定的值（xxxProperties 和配置文件进行了绑定）</li>
<li>SpringBoot 默认会在底层配好所有的组件，如果用户自己配置了<strong>以用户的优先</strong></li>
<li><strong>定制化配置：</strong><ul>
<li>用户可以使用 @Bean 新建自己的组件来替换底层的组件</li>
<li>用户可以去看这个组件是获取的配置文件前缀值，在配置文件中修改</li>
</ul>
</li>
</ul>
<p>以 DispatcherServletAutoConfiguration 为例：</p>
<pre><code class="java">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
// 类中的 Bean 默认不是单例
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
// 条件装配，环境中有 DispatcherServlet 类才进行自动装配
@ConditionalOnClass(DispatcherServlet.class)
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration &#123;
    // 注册的 DispatcherServlet 的 BeanName
    public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = &quot;dispatcherServlet&quot;;

    @Configuration(proxyBeanMethods = false)
    @Conditional(DefaultDispatcherServletCondition.class)
    @ConditionalOnClass(ServletRegistration.class)
    // 绑定配置文件的属性，从配置文件中获取配置项
    @EnableConfigurationProperties(WebMvcProperties.class)
    protected static class DispatcherServletConfiguration &#123;
        
        // 给容器注册一个 DispatcherServlet，起名字为 dispatcherServlet
        @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
        public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) &#123;
            // 新建一个 DispatcherServlet 设置相关属性
            DispatcherServlet dispatcherServlet = new DispatcherServlet();
            // spring.mvc 中的配置项获取注入，没有就填充默认值
            dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());
            // ......
            // 返回该对象注册到容器内
            return dispatcherServlet;
        &#125;

        @Bean
        // 容器中有这个类型组件才进行装配
        @ConditionalOnBean(MultipartResolver.class)
        // 容器中没有这个名字 multipartResolver 的组件
        @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
        // 方法名就是 BeanName
        public MultipartResolver multipartResolver(MultipartResolver resolver) &#123;
            // 给 @Bean 标注的方法传入了对象参数，这个参数就会从容器中找，因为用户自定义了该类型，以用户配置的优先
            // 但是名字不符合规范，所以获取到该 Bean 并返回到容器一个规范的名称：multipartResolver
            return resolver;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 将配置文件中的 spring.mvc 前缀的属性与该类绑定
@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)    
public class WebMvcProperties &#123; &#125;
</code></pre>
<hr>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>SpringBoot 在项目启动时，会对几个监听器进行回调，可以实现监听器接口，在项目启动时完成一些操作</p>
<p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p>
<ul>
<li><p>MyApplicationRunner</p>
<p><strong>自定义监听器的启动时机</strong>：MyApplicationRunner 和 MyCommandLineRunner 都是当项目启动后执行，使用 @Component 放入容器即可使用</p>
<pre><code class="java">//当项目启动后执行run方法
@Component
public class MyApplicationRunner implements ApplicationRunner &#123;
    @Override
    public void run(ApplicationArguments args) throws Exception &#123;
        System.out.println(&quot;ApplicationRunner...run&quot;);
        System.out.println(Arrays.asList(args.getSourceArgs()));//properties配置信息
    &#125;
&#125; 
</code></pre>
</li>
<li><p>MyCommandLineRunner</p>
<pre><code class="java">@Component
public class MyCommandLineRunner implements CommandLineRunner &#123;
    @Override
    public void run(String... args) throws Exception &#123;
        System.out.println(&quot;CommandLineRunner...run&quot;);
        System.out.println(Arrays.asList(args));
    &#125;
&#125;
</code></pre>
</li>
<li><p>MyApplicationContextInitializer 的启用要<strong>在 resource 文件夹下添加 META-INF&#x2F;spring.factories</strong></p>
<pre><code class="properties">org.springframework.context.ApplicationContextInitializer=\
com.example.springbootlistener.listener.MyApplicationContextInitializer
</code></pre>
<pre><code class="java">@Component
public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) &#123;
        System.out.println(&quot;ApplicationContextInitializer....initialize&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>MySpringApplicationRunListener 的使用要添加<strong>构造器</strong></p>
<pre><code class="java">public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;
    //构造器
    public MySpringApplicationRunListener(SpringApplication sa, String[] args) &#123;
    &#125;

    @Override
    public void starting() &#123;
        System.out.println(&quot;starting...项目启动中&quot;);//输出SPRING之前
    &#125;

    @Override
    public void environmentPrepared(ConfigurableEnvironment environment) &#123;
        System.out.println(&quot;environmentPrepared...环境对象开始准备&quot;);
    &#125;

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;contextPrepared...上下文对象开始准备&quot;);
    &#125;

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;contextLoaded...上下文对象开始加载&quot;);
    &#125;

    @Override
    public void started(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;started...上下文对象加载完成&quot;);
    &#125;

    @Override
    public void running(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;running...项目启动完成，开始运行&quot;);
    &#125;

    @Override
    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;
        System.out.println(&quot;failed...项目启动失败&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><div class="story post-story"><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>SpringBoot 是基于约定的，很多配置都有默认值，如果想使用自己的配置替换默认配置，可以使用 application.properties 或者 application.yml（application.yaml）进行配置</p>
<ul>
<li>默认配置文件名称：application</li>
<li>在同一级目录下优先级为：properties &gt; yml &gt; yaml</li>
</ul>
<p>例如配置内置 Tomcat 的端口</p>
<ul>
<li><p>properties：</p>
<pre><code class="properties">server.port=8080
</code></pre>
</li>
<li><p>yml：</p>
<pre><code class="yaml">server: port: 8080
</code></pre>
</li>
<li><p>yaml：</p>
<pre><code class="yaml">server: port: 8080
</code></pre>
</li>
</ul>
<hr>
<h4 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h4><p>所有位置的配置文件都会被加载，互补配置，<strong>高优先级配置内容会覆盖低优先级配置内容</strong></p>
<p>扫描配置文件的位置按优先级<strong>从高到底</strong>：</p>
<ul>
<li><p><code>file:./config/</code>：<strong>当前项目</strong>下的 &#x2F;config 目录下</p>
</li>
<li><p><code>file:./</code>：当前项目的根目录，Project工程目录</p>
</li>
<li><p><code>classpath:/config/</code>：classpath 的 &#x2F;config 目录</p>
</li>
<li><p><code>classpath:/</code>：classpath 的根目录，就是 resoureces 目录</p>
</li>
</ul>
<p>项目外部配置文件加载顺序：外部配置文件的使用是为了对内部文件的配合</p>
<ul>
<li><p>命令行：在 package 打包后的 target 目录下，使用该命令</p>
<pre><code class="sh">java -jar myproject.jar --server.port=9000
</code></pre>
</li>
<li><p>指定配置文件位置</p>
<pre><code class="sh">java -jar myproject.jar --spring.config.location=e://application.properties
</code></pre>
</li>
<li><p>按优先级从高到底选择配置文件的加载命令</p>
<pre><code class="sh">java -jar myproject.jar
</code></pre>
</li>
</ul>
<hr>
<h3 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h3><p>基本语法：</p>
<ul>
<li><p>大小写敏感</p>
</li>
<li><p><strong>数据值前边必须有空格，作为分隔符</strong></p>
</li>
<li><p>使用缩进表示层级关系</p>
</li>
<li><p>缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应空格数目可能不同，导致层次混乱）</p>
</li>
<li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p>
</li>
<li><p>‘’#” 表示注释，从这个字符一直到行尾，都会被解析器忽略</p>
<pre><code class="yaml">server: 
    port: 8080  
    address: 127.0.0.1
</code></pre>
</li>
</ul>
<p>数据格式：</p>
<ul>
<li><p>纯量：单个的、不可再分的值</p>
<pre><code class="yaml">msg1: &#39;hello \n world&#39;  # 单引忽略转义字符
msg2: &quot;hello \n world&quot;  # 双引识别转义字符
</code></pre>
</li>
<li><p>对象：键值对集合，Map、Hash</p>
<pre><code class="yaml">person:  
   name: zhangsan
   age: 20
# 行内写法
person: &#123;name: zhangsan&#125;
</code></pre>
<p>注意：不建议使用 JSON，应该使用 yaml 语法</p>
</li>
<li><p>数组：一组按次序排列的值，List、Array</p>
<pre><code class="yaml">address:
  - beijing
  - shanghai
# 行内写法
address: [beijing,shanghai]
</code></pre>
<pre><code class="yaml">allPerson    #List&lt;Person&gt;
  - &#123;name:lisi, age:18&#125;
  - &#123;name:wangwu, age:20&#125;
# 行内写法
allPerson: [&#123;name:lisi, age:18&#125;, &#123;name:wangwu, age:20&#125;]
</code></pre>
</li>
<li><p>参数引用：</p>
<pre><code class="yaml">name: lisi 
person:
  name: $&#123;name&#125; # 引用上边定义的name值
</code></pre>
</li>
</ul>
<hr>
<h3 id="获取配置"><a href="#获取配置" class="headerlink" title="获取配置"></a>获取配置</h3><p>三种获取配置文件的方式：</p>
<ul>
<li><p>注解 @Value</p>
<pre><code class="java">@RestController
public class HelloController &#123;
    @Value(&quot;$&#123;name&#125;&quot;)
    private String name;

    @Value(&quot;$&#123;person.name&#125;&quot;)
    private String name2;

    @Value(&quot;$&#123;address[0]&#125;&quot;)
    private String address1;

    @Value(&quot;$&#123;msg1&#125;&quot;)
    private String msg1;

    @Value(&quot;$&#123;msg2&#125;&quot;)
    private String msg2;
    
    @RequestMapping(&quot;/hello&quot;)
    public String hello()&#123;
        System.out.println(&quot;所有的数据&quot;);
        return &quot; hello Spring Boot !&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>Evironment 对象</p>
<pre><code class="java">@Autowired
private Environment env;

@RequestMapping(&quot;/hello&quot;)
public String hello() &#123;
    System.out.println(env.getProperty(&quot;person.name&quot;));
    System.out.println(env.getProperty(&quot;address[0]&quot;));
    return &quot; hello Spring Boot !&quot;;
&#125;
</code></pre>
</li>
<li><p>注解 @ConfigurationProperties 配合 @Component 使用</p>
<p><strong>注意</strong>：参数 prefix 一定要指定</p>
<pre><code class="java">@Component    //不扫描该组件到容器内，无法完成自动装配
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person &#123;
    private String name;
    private int age;
    private String[] address;
&#125;
</code></pre>
<pre><code class="java">@Autowired
private Person person;

@RequestMapping(&quot;/hello&quot;)
public String hello() &#123;
    System.out.println(person);
    //Person&#123;name=&#39;zhangsan&#39;, age=20, address=[beijing, shanghai]&#125;
    return &quot; hello Spring Boot !&quot;;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="配置提示"><a href="#配置提示" class="headerlink" title="配置提示"></a>配置提示</h3><p>自定义的类和配置文件绑定一般没有提示，添加如下依赖可以使用提示：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;

&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
                    &lt;/exclude&gt;
                &lt;/excludes&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<hr>
<h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><p>@Profile：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件</p>
<ul>
<li>加了环境标识的 bean，只有这个环境被激活的时候才能注册到容器中，默认是 default 环境</li>
<li>写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效</li>
<li>没有标注环境标识的 bean 在，任何环境下都是加载的</li>
</ul>
<p>Profile 的配置：</p>
<ul>
<li><p><strong>profile 是用来完成不同环境下，配置动态切换功能</strong></p>
</li>
<li><p><strong>profile 配置方式</strong>：多 profile 文件方式，提供多个配置文件，每个代表一种环境</p>
<ul>
<li>application-dev.properties&#x2F;yml 开发环境</li>
<li>application-test.properties&#x2F;yml 测试环境</li>
<li>sapplication-pro.properties&#x2F;yml 生产环境</li>
</ul>
</li>
<li><p>yml 多文档方式：在 yml 中使用  — 分隔不同配置</p>
<pre><code class="yacas">---
server:
  port: 8081
spring:
  profiles:dev
---
server:
  port: 8082
spring:
  profiles:test
---
server:
  port: 8083
spring:
  profiles:pro
---
</code></pre>
</li>
<li><p><strong>profile 激活方式</strong></p>
<ul>
<li><p>配置文件：在配置文件中配置：spring.profiles.active&#x3D;dev</p>
<pre><code class="properties">spring.profiles.active=dev
</code></pre>
</li>
<li><p>虚拟机参数：在VM options 指定：<code>-Dspring.profiles.active=dev</code></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-profile%E6%BF%80%E6%B4%BB%E6%96%B9%E5%BC%8F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-profile%E6%BF%80%E6%B4%BB%E6%96%B9%E5%BC%8F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
</li>
<li><p>命令行参数：<code>java –jar xxx.jar  --spring.profiles.active=dev</code></p>
<p>在 Program arguments 里输入，也可以先 package</p>
</li>
</ul>
</li>
</ul>
<hr>
</div><h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><div class="story post-story"><h3 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h3><p>SpringBoot 自动配置了很多约定，大多场景都无需自定义配置</p>
<ul>
<li>内容协商视图解析器 ContentNegotiatingViewResolver 和 BeanName 视图解析器 BeanNameViewResolver</li>
<li>支持静态资源（包括 webjars）和静态 index.html 页支持</li>
<li>自动注册相关类：Converter、GenericConverter、Formatter</li>
<li>内容协商处理器：HttpMessageConverters</li>
<li>国际化：MessageCodesResolver</li>
</ul>
<p>开发规范：</p>
<ul>
<li>使用 <code>@Configuration</code> + <code>WebMvcConfigurer</code> 自定义规则，不使用 <code>@EnableWebMvc</code> 注解</li>
<li>声明 <code>WebMvcRegistrations</code> 的实现类改变默认底层组件</li>
<li>使用 <code>@EnableWebMvc</code> + <code>@Configuration</code> + <code>DelegatingWebMvcConfiguration</code> 全面接管 SpringMVC</li>
</ul>
<hr>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><h4 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h4><p>默认的静态资源路径是 classpath 下的，优先级由高到低为：&#x2F;META-INF&#x2F;resources、&#x2F;resources、 &#x2F;static、&#x2F;public  的包内，<code>/</code> 表示当前项目的根路径</p>
<p>静态映射 <code>/**</code> ，表示请求 <code>/ + 静态资源名</code> 就直接去默认的资源路径寻找请求的资源</p>
<p>处理原理：静请求去寻找 Controller 处理，不能处理的请求就会交给静态资源处理器，静态资源也找不到就响应 404 页面</p>
<ul>
<li><p>修改默认资源路径：</p>
<pre><code class="yaml">spring:
  web:
    resources:
      static-locations:: [classpath:/haha/]
</code></pre>
</li>
<li><p>修改静态资源访问前缀，默认是 <code>/**</code>：</p>
<pre><code class="yaml">spring:
  mvc:
    static-path-pattern: /resources/**
</code></pre>
<p>访问 URL：<a target="_blank" rel="noopener" href="http://localhost:8080/resources/">http://localhost:8080/resources/</a> + 静态资源名，将所有资源<strong>重定位</strong>到 <code>/resources/</code></p>
</li>
<li><p>webjar 访问资源：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js%EF%BC%8C%E5%90%8E%E9%9D%A2%E5%9C%B0%E5%9D%80%E8%A6%81%E6%8C%89%E7%85%A7%E4%BE%9D%E8%B5%96%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84">http://localhost:8080/webjars/jquery/3.5.1/jquery.js，后面地址要按照依赖里面的包路径</a></p>
</li>
</ul>
<hr>
<h4 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h4><p>静态资源路径下 index.html 默认作为欢迎页面，访问 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 出现该页面，使用 welcome page 功能不能修改前缀</p>
<p>网页标签上的小图标可以自定义规则，把资源重命名为 favicon.ico 放在静态资源目录下即可</p>
<hr>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>SpringMVC 功能的自动配置类 WebMvcAutoConfiguration：</p>
<pre><code class="java">public class WebMvcAutoConfiguration &#123;
    //当前项目的根路径
    private static final String SERVLET_LOCATION = &quot;/&quot;;
&#125;
</code></pre>
<ul>
<li><p>内部类 WebMvcAutoConfigurationAdapter：</p>
<pre><code class="java">@Import(EnableWebMvcConfiguration.class)
// 绑定 spring.mvc、spring.web、spring.resources 相关的配置属性
@EnableConfigurationProperties(&#123; WebMvcProperties.class,ResourceProperties.class, WebProperties.class &#125;)
@Order(0)
public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware &#123;
    //有参构造器所有参数的值都会从容器中确定
    public WebMvcAutoConfigurationAdapter(/*参数*/) &#123;
            this.resourceProperties = resourceProperties.hasBeenCustomized() ? resourceProperties
                    : webProperties.getResources();
            this.mvcProperties = mvcProperties;
            this.beanFactory = beanFactory;
            this.messageConvertersProvider = messageConvertersProvider;
            this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();
            this.dispatcherServletPath = dispatcherServletPath;
            this.servletRegistrations = servletRegistrations;
            this.mvcProperties.checkConfiguration();
    &#125;
&#125;
</code></pre>
<ul>
<li>ResourceProperties resourceProperties：获取和 spring.resources 绑定的所有的值的对象</li>
<li>WebMvcProperties mvcProperties：获取和 spring.mvc 绑定的所有的值的对象</li>
<li>ListableBeanFactory beanFactory：Spring 的 beanFactory</li>
<li>HttpMessageConverters：找到所有的 HttpMessageConverters</li>
<li>ResourceHandlerRegistrationCustomizer：找到 资源处理器的自定义器。</li>
<li>DispatcherServletPath：项目路径</li>
<li>ServletRegistrationBean：给应用注册 Servlet、Filter</li>
</ul>
</li>
<li><p>WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter.addResourceHandler()：两种静态资源映射规则</p>
<pre><code class="java">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
    //配置文件设置 spring.resources.add-mappings: false，禁用所有静态资源
    if (!this.resourceProperties.isAddMappings()) &#123;
        logger.debug(&quot;Default resource handling disabled&quot;);//被禁用
        return;
    &#125;
    //注册webjars静态资源的映射规则    映射            路径
    addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;);
    //注册静态资源路径的映射规则         默认映射 staticPathPattern = &quot;/**&quot; 
    addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;
        //staticLocations = CLASSPATH_RESOURCE_LOCATIONS
        registration.addResourceLocations(this.resourceProperties.getStaticLocations());
        if (this.servletContext != null) &#123;
            ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);
            registration.addResourceLocations(resource);
        &#125;
    &#125;);
&#125;
</code></pre>
<pre><code class="java">@ConfigurationProperties(&quot;spring.web&quot;)
public class WebProperties &#123;
    public static class Resources &#123;
        //默认资源路径，优先级从高到低
        static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,
                                                 &quot;classpath:/resources/&quot;, 
                                                 &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;
        private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
        //可以进行规则重写
        public void setStaticLocations(String[] staticLocations) &#123;
            this.staticLocations = appendSlashIfNecessary(staticLocations);
            this.customized = true;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>WebMvcAutoConfiguration.EnableWebMvcConfiguration.welcomePageHandlerMapping()：欢迎页</p>
<pre><code class="java">//spring.web 属性
@EnableConfigurationProperties(WebProperties.class)
public static class EnableWebMvcConfiguration &#123;
    @Bean
    public WelcomePageHandlerMapping welcomePageHandlerMapping(/*参数*/) &#123;
        WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
            new TemplateAvailabilityProviders(applicationContext), 
            applicationContext, getWelcomePage(),
            //staticPathPattern = &quot;/**&quot;
            this.mvcProperties.getStaticPathPattern());
        return welcomePageHandlerMapping;
    &#125;
&#125;
WelcomePageHandlerMapping(/*参数*/) &#123;
    //所以限制 staticPathPattern 必须为 /** 才能启用该功能
    if (welcomePage != null &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123;
        logger.info(&quot;Adding welcome page: &quot; + welcomePage);
        //重定向
        setRootViewName(&quot;forward:index.html&quot;);
    &#125;
    else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;
        logger.info(&quot;Adding welcome page template: index&quot;);
        setRootViewName(&quot;index&quot;);
    &#125;
&#125;
</code></pre>
<p>WelcomePageHandlerMapping，访问 &#x2F; 能访问到 index.html</p>
</li>
</ul>
<hr>
<h3 id="Rest映射"><a href="#Rest映射" class="headerlink" title="Rest映射"></a>Rest映射</h3><p>开启 Rest 功能</p>
<pre><code class="yaml">spring:
  mvc:
    hiddenmethod:
      filter:
        enabled: true   #开启页面表单的Rest功能
</code></pre>
<p>源码分析，注入了 HiddenHttpMethodFilte 解析 Rest 风格的访问：</p>
<pre><code class="java">public class WebMvcAutoConfiguration &#123;
    @Bean
    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
    @ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;)
    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;
        return new OrderedHiddenHttpMethodFilter();
    &#125;
&#125;
</code></pre>
<p>详细源码解析：SpringMVC → 基本操作 → Restful → 识别原理</p>
<p>Web 部分源码详解：SpringMVC → 运行原理</p>
<hr>
<h3 id="内嵌容器"><a href="#内嵌容器" class="headerlink" title="内嵌容器"></a>内嵌容器</h3><p>SpringBoot 嵌入式 Servlet 容器，默认支持的 WebServe：Tomcat、Jetty、Undertow</p>
<p>配置方式：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt; &lt;!--必须要把内嵌的 Tomcat 容器--&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Web 应用启动，SpringBoot 导入 Web 场景包 tomcat，创建一个 Web 版的 IOC 容器：</p>
<ul>
<li><p><code>SpringApplication.run(BootApplication.class, args)</code>：应用启动</p>
</li>
<li><p><code>ConfigurableApplicationContext.run()</code>：</p>
<ul>
<li><p><code>context = createApplicationContext()</code>：<strong>创建容器</strong></p>
<ul>
<li><p><code>applicationContextFactory = ApplicationContextFactory.DEFAULT</code></p>
<pre><code class="java">ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; &#123;
    try &#123;
        switch (webApplicationType) &#123;
            case SERVLET:
                // Servlet 容器，继承自 ServletWebServerApplicationContext
                return new AnnotationConfigServletWebServerApplicationContext();
            case REACTIVE:
                // 响应式编程
                return new AnnotationConfigReactiveWebServerApplicationContext();
            default:
                // 普通 Spring 容器
                return new AnnotationConfigApplicationContext();
        &#125;
    &#125; catch (Exception ex) &#123;
        throw new IllegalStateException();
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>applicationContextFactory.create(this.webApplicationType)</code>：根据应用类型创建容器</p>
</li>
</ul>
</li>
<li><p><code>refreshContext(context)</code>：容器启动刷新</p>
</li>
</ul>
</li>
</ul>
<p>内嵌容器工作流程：</p>
<ul>
<li><p>Spring 容器启动逻辑中，在实例化非懒加载的单例 Bean 之前有一个方法 **onRefresh()**，留给子类去扩展，Web 容器就是重写这个方法创建 WebServer</p>
<pre><code class="java">protected void onRefresh() &#123;
    //省略....
    createWebServer();
&#125;
private void createWebServer() &#123;
    ServletWebServerFactory factory = getWebServerFactory();
    this.webServer = factory.getWebServer(getSelfInitializer());
    createWebServer.end();
&#125;
</code></pre>
<p>获取 WebServer 工厂 ServletWebServerFactory，并且获取的数量不等于 1 会报错，Spring 底层有三种：</p>
<p><code>TomcatServletWebServerFactory</code>、<code>JettyServletWebServerFactory</code>、<code>UndertowServletWebServerFactory</code></p>
</li>
<li><p><strong>自动配置类 ServletWebServerFactoryAutoConfiguration</strong> 导入了 ServletWebServerFactoryConfiguration（配置类），根据条件装配判断系统中到底导入了哪个 Web 服务器的包，创建出服务器并启动</p>
</li>
<li><p>默认是 web-starter 导入 tomcat 包，容器中就有 TomcatServletWebServerFactory，创建出 Tomcat 服务器并启动，</p>
<pre><code class="java">public TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) &#123;
    // 初始化
       initialize();
&#125;
</code></pre>
<p>初始化方法 initialize 中有启动方法：<code>this.tomcat.start()</code></p>
</li>
</ul>
<hr>
<h3 id="自定义-3"><a href="#自定义-3" class="headerlink" title="自定义"></a>自定义</h3><h4 id="定制规则"><a href="#定制规则" class="headerlink" title="定制规则"></a>定制规则</h4><pre><code class="java">@Configuration
public class MyWebMvcConfigurer implements WebMvcConfigurer &#123;
    @Bean
    public WebMvcConfigurer webMvcConfigurer() &#123;
        return new WebMvcConfigurer() &#123;
            //进行一些方法重写，来实现自定义的规则
            //比如添加一些解析器和拦截器，就是对原始容器功能的增加
        &#125;
    &#125;
    //也可以不加 @Bean，直接从这里重写方法进行功能增加
&#125;
</code></pre>
<hr>
<h4 id="定制容器"><a href="#定制容器" class="headerlink" title="定制容器"></a>定制容器</h4><p>@EnableWebMvc：全面接管 SpringMVC，所有规则全部自己重新配置</p>
<ul>
<li><p>@EnableWebMvc + WebMvcConfigurer + @Bean  全面接管SpringMVC</p>
</li>
<li><p>@Import(DelegatingWebMvcConfiguration.<strong>class</strong>)，该类继承 WebMvcConfigurationSupport，自动配置了一些非常底层的组件，只能保证 SpringMVC 最基本的使用</p>
</li>
</ul>
<p>原理：自动配置类 <strong>WebMvcAutoConfiguration</strong> 里面的配置要能生效，WebMvcConfigurationSupport 类不能被加载，所以 @EnableWebMvc 导致配置类失效，从而接管了 SpringMVC</p>
<pre><code class="java">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
public class WebMvcAutoConfiguration &#123;&#125;
</code></pre>
<p>注意：一般不适用此注解</p>
<hr>
</div><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><div class="story post-story"><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>导入 starter：</p>
<pre><code class="xml">&lt;!--导入 JDBC 场景--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--导入 MySQL 驱动--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;!--版本对应你的 MySQL 版本&lt;version&gt;5.1.49&lt;/version&gt;--&gt;
&lt;/dependency&gt;
</code></pre>
<p>单独导入 MySQL 驱动是因为不确定用户使用的什么数据库</p>
<p>配置文件：</p>
<pre><code class="yaml">spring:
  datasource:
    url: jdbc:mysql://192.168.0.107:3306/db1?useSSL=false    # 不加 useSSL 会警告
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver
</code></pre>
<p>测试文件：</p>
<pre><code class="java">@Slf4j
@SpringBootTest
class Boot05WebAdminApplicationTests &#123;

    @Autowired
    JdbcTemplate jdbcTemplate;

    @Test
    void contextLoads() &#123;
        Long res = jdbcTemplate.queryForObject(&quot;select count(*) from account_tbl&quot;, Long.class);
        log.info(&quot;记录总数：&#123;&#125;&quot;, res);
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>DataSourceAutoConfiguration：数据源的自动配置</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceAutoConfiguration &#123;
    
    @Conditional(PooledDataSourceCondition.class) 
    @ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)
    @Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,
            DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class&#125;)
    protected static class PooledDataSourceConfiguration &#123;&#125;
&#125;
// 配置项
@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
public class DataSourceProperties implements BeanClassLoaderAware, InitializingBean &#123;&#125;
</code></pre>
<ul>
<li>底层默认配置好的连接池是：<strong>HikariDataSource</strong></li>
<li>数据库连接池的配置，是容器中没有 DataSource 才自动配置的</li>
<li>修改数据源相关的配置：spring.datasource</li>
</ul>
<p>相关配置：</p>
<ul>
<li>DataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置</li>
<li>JdbcTemplateAutoConfiguration： JdbcTemplate 的自动配置<ul>
<li>可以修改这个配置项 @ConfigurationProperties(prefix &#x3D; <strong>“spring.jdbc”</strong>) 来修改JdbcTemplate</li>
<li><code>@AutoConfigureAfter(DataSourceAutoConfiguration.class)</code>：在 DataSource 装配后装配</li>
</ul>
</li>
<li>JndiDataSourceAutoConfiguration： jndi 的自动配置</li>
<li>XADataSourceAutoConfiguration： 分布式事务相关</li>
</ul>
<hr>
<h3 id="Druid-2"><a href="#Druid-2" class="headerlink" title="Druid"></a>Druid</h3><p>导入坐标：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">@Configuration
@ConditionalOnClass(DruidDataSource.class)
@AutoConfigureBefore(DataSourceAutoConfiguration.class)
@EnableConfigurationProperties(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)
@Import(&#123;DruidSpringAopConfiguration.class,
    DruidStatViewServletConfiguration.class,
    DruidWebStatFilterConfiguration.class,
    DruidFilterConfiguration.class&#125;)
public class DruidDataSourceAutoConfigure &#123;&#125;
</code></pre>
<p>自动配置：</p>
<ul>
<li><p>扩展配置项 <strong>spring.datasource.druid</strong></p>
</li>
<li><p>DruidSpringAopConfiguration： 监控 SpringBean，配置项为 <code>spring.datasource.druid.aop-patterns</code></p>
</li>
<li><p>DruidStatViewServletConfiguration：监控页的配置项为 <code>spring.datasource.druid.stat-view-servlet</code>，默认开启</p>
</li>
<li><p>DruidWebStatFilterConfiguration：Web 监控配置项为 <code>spring.datasource.druid.web-stat-filter</code>，默认开启</p>
</li>
<li><p>DruidFilterConfiguration：所有 Druid 自己 filter 的配置</p>
</li>
</ul>
<p>配置示例：</p>
<pre><code class="yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/db_account
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver

    druid:
      aop-patterns: com.atguigu.admin.*  #监控SpringBean
      filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）

      stat-view-servlet:   # 配置监控页功能
        enabled: true
        login-username: admin    #项目启动访问：http://localhost:8080/druid ，账号和密码是 admin
        login-password: admin
        resetEnable: false

      web-stat-filter:  # 监控web
        enabled: true
        urlPattern: /*
        exclusions: &#39;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#39;


      filter:
        stat:    # 对上面filters里面的stat的详细配置
          slow-sql-millis: 1000
          logSlowSql: true
          enabled: true
        wall:
          enabled: true
          config:
            drop-table-allow: false
</code></pre>
<p>配置示例：<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p>
<p>配置项列表：<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8</a></p>
<hr>
<h3 id="MyBatis-1"><a href="#MyBatis-1" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><p>导入坐标：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li><p>编写 MyBatis 相关配置：application.yml</p>
<pre><code class="yaml"># 配置mybatis规则
mybatis:
#  config-location: classpath:mybatis/mybatis-config.xml  建议不写
  mapper-locations: classpath:mybatis/mapper/*.xml
  configuration:
    map-underscore-to-camel-case: true
    
 #可以不写全局配置文件，所有全局配置文件的配置都放在 configuration 配置项中即可
</code></pre>
</li>
<li><p>定义表和实体类</p>
<pre><code class="java">public class User &#123;
    private int id;
    private String username;
    private String password;
&#125;
</code></pre>
</li>
<li><p>编写 dao 和 mapper 文件&#x2F;纯注解开发</p>
<p>dao：**@Mapper 注解必须加，使用自动装配的 package，否则在启动类指定 @MapperScan() 扫描路径（不建议）**</p>
<pre><code class="java">@Mapper  //必须加Mapper
@Repository
public interface UserXmlMapper &#123;
    public List&lt;User&gt; findAll();
&#125;
</code></pre>
<p>mapper.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.seazean.springbootmybatis.mapper.UserXmlMapper&quot;&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
        select * from t_user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>纯注解开发</p>
<pre><code class="java">@Mapper
@Repository
public interface UserMapper &#123;
    @Select(&quot;select * from t_user&quot;)
    public List&lt;User&gt; findAll();
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="自动配置-1"><a href="#自动配置-1" class="headerlink" title="自动配置"></a>自动配置</h4><p>MybatisAutoConfiguration：</p>
<pre><code class="java">@EnableConfigurationProperties(MybatisProperties.class)    //MyBatis配置项绑定类。
@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)
public class MybatisAutoConfiguration &#123;
    @Bean
      @ConditionalOnMissingBean
      public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123;
        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
        return factory.getObject();
    &#125;
    
    @org.springframework.context.annotation.Configuration
       @Import(AutoConfiguredMapperScannerRegistrar.class)
       @ConditionalOnMissingBean(&#123; MapperFactoryBean.class, MapperScannerConfigurer.class &#125;)
       public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean &#123;&#125;
&#125;

@ConfigurationProperties(prefix = &quot;mybatis&quot;)
public class MybatisProperties &#123;&#125;
</code></pre>
<ul>
<li>配置文件：<code>mybatis</code></li>
<li>自动配置了 SqlSessionFactory</li>
<li>导入 <code>AutoConfiguredMapperScannerRegistra</code> 实现 @Mapper 的扫描</li>
</ul>
<hr>
<h4 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>自动配置类：MybatisPlusAutoConfiguration </p>
<p>只需要 Mapper 继承 <strong>BaseMapper</strong> 就可以拥有 CRUD 功能</p>
<hr>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li><p>配置redis相关属性</p>
<pre><code class="yaml">spring:
  redis:
    host: 127.0.0.1 # redis的主机ip
    port: 6379
</code></pre>
</li>
<li><p>注入 RedisTemplate 模板</p>
<pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringbootRedisApplicationTests &#123;
    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void testSet() &#123;
        //存入数据
        redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;zhangsan&quot;);
    &#125;
    @Test
    public void testGet() &#123;
        //获取数据
        Object name = redisTemplate.boundValueOps(&quot;name&quot;).get();
        System.out.println(name);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="自动配置-2"><a href="#自动配置-2" class="headerlink" title="自动配置"></a>自动配置</h4><p>RedisAutoConfiguration 自动配置类</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)
public class RedisAutoConfiguration &#123;
    @Bean
    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    &#125;

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    &#125;

&#125;
</code></pre>
<ul>
<li><p>配置项：<code>spring.redis</code></p>
</li>
<li><p>自动导入了连接工厂配置类：LettuceConnectionConfiguration、JedisConnectionConfiguration</p>
</li>
<li><p>自动注入了模板类：RedisTemplate&lt;Object, Object&gt; 、StringRedisTemplate，k v 都是 String 类型</p>
</li>
<li><p>使用 @Autowired 注入模板类就可以操作 redis</p>
</li>
</ul>
<hr>
</div><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><div class="story post-story"><h3 id="Junit5"><a href="#Junit5" class="headerlink" title="Junit5"></a>Junit5</h3><p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，由三个不同的子模块组成：</p>
<ul>
<li><p>JUnit Platform：在 JVM 上启动测试框架的基础，不仅支持 Junit 自制的测试引擎，其他测试引擎也可以接入</p>
</li>
<li><p>JUnit Jupiter：提供了 JUnit5 的新的编程模型，是 JUnit5 新特性的核心，内部包含了一个测试引擎，用于在 Junit Platform 上运行</p>
</li>
<li><p>JUnit Vintage：JUnit Vintage 提供了兼容 JUnit4.x、Junit3.x 的测试引擎</p>
<p>注意：SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖，如果需要兼容 Junit4 需要自行引入</p>
</li>
</ul>
<pre><code class="java">@SpringBootTest
class Boot05WebAdminApplicationTests &#123;
    @Test
    void contextLoads() &#123; &#125;
&#125;
</code></pre>
<hr>
<h3 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h3><p>JUnit5 的注解如下：</p>
<ul>
<li><p>@Test：表示方法是测试方法，但是与 JUnit4 的 @Test 不同，它的职责非常单一不能声明任何属性，拓展的测试将会由 Jupiter 提供额外测试，包是 <code>org.junit.jupiter.api.Test</code></p>
</li>
<li><p>@ParameterizedTest：表示方法是参数化测试</p>
</li>
<li><p>@RepeatedTest：表示方法可重复执行</p>
</li>
<li><p>@DisplayName：为测试类或者测试方法设置展示名称</p>
</li>
<li><p>@BeforeEach：表示在每个单元测试之前执行</p>
</li>
<li><p>@AfterEach：表示在每个单元测试之后执行</p>
</li>
<li><p>@BeforeAll：表示在所有单元测试之前执行</p>
</li>
<li><p>@AfterAll：表示在所有单元测试之后执行</p>
</li>
<li><p>@Tag：表示单元测试类别，类似于 JUnit4 中的 @Categories</p>
</li>
<li><p>@Disabled：表示测试类或测试方法不执行，类似于 JUnit4 中的 @Ignore</p>
</li>
<li><p>@Timeout：表示测试方法运行如果超过了指定时间将会返回错误</p>
</li>
<li><p>@ExtendWith：为测试类或测试方法提供扩展类引用</p>
</li>
</ul>
<hr>
<h3 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h3><h4 id="简单断言"><a href="#简单断言" class="headerlink" title="简单断言"></a>简单断言</h4><p>断言（assertions）是测试方法中的核心，用来对测试需要满足的条件进行验证，断言方法都是 org.junit.jupiter.api.Assertions 的静态方法</p>
<p>用来对单个值进行简单的验证：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody></table>
<pre><code class="java">@Test
@DisplayName(&quot;simple assertion&quot;)
public void simple() &#123;
     assertEquals(3, 1 + 2, &quot;simple math&quot;);
     assertNull(null);
     assertNotNull(new Object());
&#125;
</code></pre>
<hr>
<h4 id="数组断言"><a href="#数组断言" class="headerlink" title="数组断言"></a>数组断言</h4><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</p>
<pre><code class="java">@Test
@DisplayName(&quot;array assertion&quot;)
public void array() &#123;
     assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);
&#125;
</code></pre>
<hr>
<h4 id="组合断言"><a href="#组合断言" class="headerlink" title="组合断言"></a>组合断言</h4><p>assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为验证的断言，可以通过 lambda 表达式提供这些断言</p>
<pre><code class="java">@Test
@DisplayName(&quot;assert all&quot;)
public void all() &#123;
    assertAll(&quot;Math&quot;,
              () -&gt; assertEquals(2, 1 + 1),
              () -&gt; assertTrue(1 &gt; 0)
       );
&#125;
</code></pre>
<hr>
<h4 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h4><p>Assertions.assertThrows()，配合函数式编程就可以进行使用</p>
<pre><code class="java">@Test
@DisplayName(&quot;异常测试&quot;)
public void exceptionTest() &#123;
    ArithmeticException exception = Assertions.assertThrows(
        //扔出断言异常
        ArithmeticException.class, () -&gt; System.out.println(1 / 0)
    );
&#125;
</code></pre>
<hr>
<h4 id="超时断言"><a href="#超时断言" class="headerlink" title="超时断言"></a>超时断言</h4><p>Assertions.assertTimeout() 为测试方法设置了超时时间</p>
<pre><code class="java">@Test
@DisplayName(&quot;超时测试&quot;)
public void timeoutTest() &#123;
    //如果测试方法时间超过1s将会异常
    Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));
&#125;
</code></pre>
<hr>
<h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>通过 fail 方法直接使得测试失败</p>
<pre><code class="java">@Test
@DisplayName(&quot;fail&quot;)
public void shouldFail() &#123;
    fail(&quot;This should fail&quot;);
&#125;
</code></pre>
<hr>
<h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>JUnit 5 中的前置条件（assumptions）类似于断言，不同之处在于<strong>不满足的断言会使得测试方法失败</strong>，而不满足的<strong>前置条件只会使得测试方法的执行终止</strong>，前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要</p>
<pre><code class="java">@DisplayName(&quot;测试前置条件&quot;)
@Test
void testassumptions()&#123;
    Assumptions.assumeTrue(false,&quot;结果不是true&quot;);
    System.out.println(&quot;111111&quot;);

&#125;
</code></pre>
<hr>
<h3 id="嵌套测试"><a href="#嵌套测试" class="headerlink" title="嵌套测试"></a>嵌套测试</h3><p>JUnit 5 可以通过 Java 中的内部类和 @Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起，在内部类中可以使用 @BeforeEach 和 @AfterEach 注解，而且嵌套的层次没有限制</p>
<pre><code class="java">@DisplayName(&quot;A stack&quot;)
class TestingAStackDemo &#123;

    Stack&lt;Object&gt; stack;

    @Test
    @DisplayName(&quot;is instantiated with new Stack()&quot;)
    void isInstantiatedWithNew() &#123;
        assertNull(stack)
    &#125;

    @Nested
    @DisplayName(&quot;when new&quot;)
    class WhenNew &#123;

        @BeforeEach
        void createNewStack() &#123;
            stack = new Stack&lt;&gt;();
        &#125;

        @Test
        @DisplayName(&quot;is empty&quot;)
        void isEmpty() &#123;
            assertTrue(stack.isEmpty());
        &#125;

        @Test
        @DisplayName(&quot;throws EmptyStackException when popped&quot;)
        void throwsExceptionWhenPopped() &#123;
            assertThrows(EmptyStackException.class, stack::pop);
        &#125;
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="参数测试"><a href="#参数测试" class="headerlink" title="参数测试"></a>参数测试</h3><p>参数化测试是 JUnit5 很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能</p>
<p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<ul>
<li><p>@ValueSource：为参数化测试指定入参来源，支持八大基础类以及 String 类型、Class 类型</p>
</li>
<li><p>@NullSource：表示为参数化测试提供一个 null 的入参</p>
</li>
<li><p>@EnumSource：表示为参数化测试提供一个枚举入参</p>
</li>
<li><p>@CsvFileSource：表示读取指定 CSV 文件内容作为参数化测试入参</p>
</li>
<li><p>@MethodSource：表示读取指定方法的返回值作为参数化测试入参（注意方法返回需要是一个流）</p>
</li>
</ul>
<hr>
</div><h2 id="指标监控"><a href="#指标监控" class="headerlink" title="指标监控"></a>指标监控</h2><div class="story post-story"><h3 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h3><p>每一个微服务在云上部署以后，都需要对其进行监控、追踪、审计、控制等，SpringBoot 抽取了 Actuator 场景，使得每个微服务快速引用即可获得生产级别的应用监控、审计等功能</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>暴露所有监控信息为 HTTP：</p>
<pre><code class="yaml">management:
  endpoints:
    enabled-by-default: true #暴露所有端点信息
    web:
      exposure:
        include: &#39;*&#39;  #以web方式暴露
</code></pre>
<p>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/actuator/[beans/health/metrics/]">http://localhost:8080/actuator/[beans/health/metrics/]</a></p>
<p>可视化界面：<a target="_blank" rel="noopener" href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></p>
<hr>
<h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>默认所有的 Endpoint 除过 shutdown 都是开启的</p>
<pre><code class="yaml">management:
  endpoints:
    enabled-by-default: false    #禁用所有的
  endpoint:                        #手动开启一部分
    beans:
      enabled: true
    health:
      enabled: true
</code></pre>
<p>端点：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auditevents</code></td>
<td>暴露当前应用程序的审核事件信息。需要一个 <code>AuditEventRepository</code> 组件</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>显示应用程序中所有 Spring Bean 的完整列表</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>暴露可用的缓存</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>显示自动配置的所有条件信息，包括匹配或不匹配的原因</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>显示所有 <code>@ConfigurationProperties</code></td>
</tr>
<tr>
<td><code>env</code></td>
<td>暴露 Spring 的属性 <code>ConfigurableEnvironment</code></td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>显示已应用的所有 Flyway 数据库迁移。 需要一个或多个 Flyway 组件。</td>
</tr>
<tr>
<td><code>health</code></td>
<td>显示应用程序运行状况信息</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>显示 HTTP 跟踪信息，默认情况下 100 个 HTTP 请求-响应需要一个 <code>HttpTraceRepository</code> 组件</td>
</tr>
<tr>
<td><code>info</code></td>
<td>显示应用程序信息</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>显示 Spring integrationgraph，需要依赖 <code>spring-integration-core</code></td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>显示和修改应用程序中日志的配置</td>
</tr>
<tr>
<td><code>liquibase</code></td>
<td>显示已应用的所有 Liquibase 数据库迁移，需要一个或多个 Liquibase 组件</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>显示当前应用程序的指标信息。</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>显示所有 <code>@RequestMapping</code> 路径列表</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>显示应用程序中的计划任务</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>允许从 Spring Session 支持的会话存储中检索和删除用户会话，需要使用 Spring Session 的基于 Servlet 的 Web 应用程序</td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>使应用程序正常关闭，默认禁用</td>
</tr>
<tr>
<td><code>startup</code></td>
<td>显示由 <code>ApplicationStartup</code> 收集的启动步骤数据。需要使用 <code>SpringApplication</code> 进行配置 <code>BufferingApplicationStartup</code></td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>执行线程转储</td>
</tr>
</tbody></table>
<p>应用程序是 Web 应用程序（Spring MVC，Spring WebFlux 或 Jersey），则可以使用以下附加端点：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>heapdump</code></td>
<td>返回 <code>hprof</code> 堆转储文件。</td>
</tr>
<tr>
<td><code>jolokia</code></td>
<td>通过 HTTP 暴露 JMX bean（需要引入 Jolokia，不适用于 WebFlux），需要引入依赖 <code>jolokia-core</code></td>
</tr>
<tr>
<td><code>logfile</code></td>
<td>返回日志文件的内容（如果已设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性），支持使用 HTTP Range标头来检索部分日志文件的内容。</td>
</tr>
<tr>
<td><code>prometheus</code></td>
<td>以 Prometheus 服务器可以抓取的格式公开指标，需要依赖 <code>micrometer-registry-prometheus</code></td>
</tr>
</tbody></table>
<p>常用 Endpoint：</p>
<ul>
<li><p>Health：监控状况</p>
</li>
<li><p>Metrics：运行时指标</p>
</li>
<li><p>Loggers：日志记录</p>
</li>
</ul>
<hr>
</div><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><div class="story post-story"><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p>
<ul>
<li>jar 包 (官方推荐，默认)</li>
<li>war 包</li>
</ul>
<p><strong>更改 pom 文件中的打包方式为 war</strong></p>
<ul>
<li><p>修改启动类</p>
<pre><code class="java">@SpringBootApplication
public class SpringbootDeployApplication extends SpringBootServletInitializer &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringbootDeployApplication.class, args);
    &#125;

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder b) &#123;
        return b.sources(SpringbootDeployApplication.class);
    &#125;
&#125;
</code></pre>
</li>
<li><p>指定打包的名称</p>
<pre><code class="xml">&lt;packaging&gt;war&lt;/packaging&gt;
&lt;build&gt;
     &lt;finalName&gt;springboot&lt;/finalName&gt;
     &lt;plugins&gt;
         &lt;plugin&gt;
             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
             &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
         &lt;/plugin&gt;
     &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
</li>
</ul>
<hr>
<h1 id="Cloud"><a href="#Cloud" class="headerlink" title="Cloud"></a>Cloud</h1></div><h2 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h2><div class="story post-story"><p>SpringCloud 是分布式微服务的一站式解决方案，是多种微服务落地技术的集合体，俗称微服务全家桶</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-组件概览"></p>
<p>参考文档：<a target="_blank" rel="noopener" href="https://www.yuque.com/mrlinxi/pxvr4g/wcwd39">https://www.yuque.com/mrlinxi/pxvr4g/wcwd39</a></p>
<hr>
</div><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><div class="story post-story"><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。Eureka 采用了 CS(Client-Server) 的设计架构，Eureka Server 是服务注册中心，系统中的其他微服务使用 Eureka 的客户端连接到 Eureka Server 并维持心跳连接</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Eureka%E5%92%8CDubbo%E5%AF%B9%E6%AF%94.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Eureka%E5%92%8CDubbo%E5%AF%B9%E6%AF%94.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Eureka和Dubbo对比"></p>
<ul>
<li><p>Eureka Server 提供服务注册服务：各个微服务节点通过配置启动后，会在 EurekaServer 中进行注册，EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，并且具有可视化界面</p>
</li>
<li><p>Eureka Client 通过注册中心进行访问：用于简化 Eureka Server的交互，客户端也具备一个内置的、使用轮询 (round-robin) 负载算法的负载均衡器。在应用启动后将会向 Eureka Server 发送心跳（默认周期为30秒），如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，将会从服务注册表中把这个服务节点移除（默认 90 秒）</p>
</li>
</ul>
<hr>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>服务器端主启动类增加 @EnableEurekaServer 注解，指定该模块作为 Eureka 注册中心的服务器</p>
<p>构建流程如下：</p>
<ul>
<li><p>主启动类</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaServer  // 表示当前是Eureka的服务注册中心
public class EurekaMain7001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaMain7001.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>修改 pom 文件</p>
<pre><code class="xml">1.x:    server跟client合在一起
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
&lt;/dependency&gt;
2.x： server跟client分开
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>修改  application.yml 文件</p>
<pre><code class="yaml">server:
  port: 7001

eureka:
  instance:
    hostname: localhost # eureka服务端的实例名称
  client:
    # false表示不向注册中心注册自己。
    register-with-eureka: false
    # false表示自己端就是注册中心，职责就是维护服务实例，并不需要去检索服务
    fetch-registry: false
  service-url:
    # 设置与 Eureka Server 交互的地址查询服务和注册服务都需要依赖这个地址。
    defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
</li>
<li><p>游览器访问 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001</a></p>
</li>
</ul>
<hr>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><p>服务器端主启动类需要增加 @EnableEurekaClient 注解，表示这是一个 Eureka 客户端，要注册进 EurekaServer 中</p>
<ul>
<li><p>主启动类：PaymentMain8001</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
public class PaymentMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8001.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>修改 pom 文件：添加一个 Eureka-Client 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>写 yml 文件</p>
<pre><code class="yaml">server:
  port: 8001
 
eureka:
  client:
    # 表示将自己注册进EurekaServer默认为true
    register-with-eureka: true
    # 表示可以从Eureka抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url: 
      defaultZone: http://localhost:7001/eureka
  instance:
    instance-id: payment8001 # 只暴露服务名，不带有主机名
    prefer-ip-address: true  # 访问信息有 IP 信息提示(鼠标停留在服务名称上时)
</code></pre>
</li>
<li><p>游览器访问 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001</a></p>
</li>
</ul>
<hr>
<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><ul>
<li><p>主启动类：PaymentMain8001</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
@EnableDiscoveryClient
public class PaymentMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8001.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>pom 文件同生产者</p>
</li>
<li><p>写 yml 文件</p>
<pre><code class="yaml">server:
  port: 80

# 微服务名称
spring:
 application:
  name: cloud-order-service
eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url: 
      defaultZone: http://localhost:7001/eureka
</code></pre>
</li>
<li><p>浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001</a></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Eureka%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Eureka%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Eureka可视化界面"></p>
</li>
</ul>
<hr>
<h4 id="集群构建"><a href="#集群构建" class="headerlink" title="集群构建"></a>集群构建</h4><h5 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h5><p>Server 端高可用集群原理：实现负载均衡和故障容错，互相注册，相互守望</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Eureka%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Eureka%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Eureka集群原理"></p>
<p>多台 Eureka 服务器，每一台 Eureka 服务器需要有自己的主机名，同时各服务器需要相互注册</p>
<ul>
<li><p>Eureka1：</p>
<pre><code class="yaml">server:
  port: 7001

eureka:
  instance:
    hostname: eureka7001.com
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
    # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。
      # 单机就是自己
      # defaultZone: http://eureka7001.com:7001/eureka/
      # 集群指向其他eureka
      #defaultZone: http://eureka7002.com:7002/eureka/
      # 写成这样可以直接通过可视化页面跳转到7002
      defaultZone: http://eureka7002.com:7002/
</code></pre>
</li>
<li><p>Eureka2：</p>
<pre><code class="yaml">server:
  port: 7002

eureka:
  instance:
    hostname: eureka7002.com
  client:
    register-with-eureka: false
    fetch-registry: false
    service-url:
      #写成这样可以直接通过可视化页面跳转到7001
      defaultZone: http://eureka7001.com:7001/
</code></pre>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaServer
public class EurekaMain7002 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaMain7002.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>访问 <a target="_blank" rel="noopener" href="http://eureka7001.com:7001/">http://eureka7001.com:7001</a> 和 <a href="http://eureka7002.com:7002：">http://eureka7002.com:7002：</a></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-EurekaServer%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%88%90%E5%8A%9F.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-EurekaServer%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%88%90%E5%8A%9F.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-EurekaServer集群构建成功"></p>
</li>
<li><p>RPC 调用：controller.OrderController</p>
<pre><code class="java">@RestController
@Slf4j
public class OrderController &#123;
    public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;

    @Autowired
    private RestTemplate restTemplate;
    
    // CommonResult 是一个公共的返回类型
    @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) long id) &#123;
        // 返回对象为响应体中数据转化成的对象，基本上可以理解为JSON
        return restTemplate.getForObject(PAYMENT_URL + &quot;/payment/get/&quot; + id, CommonResult.class);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><p>构建 PaymentMain8001 的服务集群</p>
<ul>
<li><p>主启动类</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
@EnableDiscoveryClient
public class PaymentMain8002 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8002.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>写 yml 文件：端口修改，并且 spring.application.name 均为 cloud-payment-service</p>
<pre><code class="yaml">server:
  port: 8002

spring:
  application:
    name: cloud-payment-service
    
eureka:
  client:
    # 表示将自己注册进EurekaServer默认为true
    register-with-eureka: true
    # 表示可以从Eureka抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetch-registry: true
    service-url: 
      defaultZone: http://localhost:7001/eureka
</code></pre>
</li>
</ul>
<hr>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>消费者端的 Controller</p>
<pre><code class="java">// public static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;
public static final String PAYMENT_URL = &quot;http://localhost:8002&quot;;
</code></pre>
<p>由于已经建立了生产者集群，所以可以进行负载均衡的操作：</p>
<ul>
<li><p>Controller：只修改 PAYMENT_URL 会报错，因为 CLOUD-PAYMENT-SERVICE 对应多个微服务，需要规则来判断调用哪个端口</p>
<pre><code class="java">public static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;;
</code></pre>
</li>
<li><p>使用 @LoadBlanced 注解赋予 RestTemplate 负载均衡的能力，增加 config.ApplicationContextConfig 文件：</p>
<pre><code class="java">@Configuration
public class ApplicationContextConfig &#123;
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate() &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>服务发现：对于注册进 Eureka 里面的微服务，可以通过服务发现来获得该服务的信息</p>
<ul>
<li><p>主启动类增加注解 @EnableDiscoveryClient：</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
@EnableDiscoveryClient
public class PaymentMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8001.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>修改生产者的 Controller</p>
<pre><code class="java">@RestController
@Slf4j
public class PaymentController &#123;
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @GetMapping(value = &quot;/payment/discovery&quot;)
    public Object discovery() &#123;
        List&lt;String&gt; services = discoveryClient.getServices();
        for (String service : services) &#123;
            log.info(&quot;**** element:&quot; + service);
        &#125;

        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;PAYMENT-SERVICE&quot;);
        for (ServiceInstance instance : instances) &#123;
            log.info(instance.getServiceId() + &quot;\t&quot; + instance.getHost() + &quot;\t&quot; + instance.getPort());
        &#125;
        return this.discoveryClient;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h4><p>保护模式用于客户端和 EurekaServer 之间存在网络分区场景下的保护，一旦进入保护模式 EurekaServer 将会尝试保护其服务注册表中的信息，不在删除服务注册表中的数据，属于 CAP 里面的 AP 思想（可用性和分区容错性）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Eureka自我保护机制"></p>
<p>如果一定时间内丢失大量该微服务的实例，这时 Eureka 就会开启自我保护机制，不会剔除该服务。 因为这个现象可能是因为网络暂时不通，出现了 Eureka 的假死、拥堵、卡顿，客户端恢复后还能正常发送心跳</p>
<p>禁止自我保护：</p>
<ul>
<li><p>Server：</p>
<pre><code class="yaml">eureka:
  server:
    # 关闭自我保护机制，不可用的服务直接删除
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 2000
</code></pre>
</li>
<li><p>Client：</p>
<pre><code class="yaml">eureka:
  instance:
    # Eureka客户端向服务端发送心跳的时间间隔默认30秒 
    lease-renewal-interval-in-seconds: 1
    # Eureka服务端在收到最后一次心跳后，90s没有收到心跳，剔除服务
    lease-expiration-duration-in-seconds: 2
</code></pre>
</li>
</ul>
<hr>
<h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><h4 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Consul 是开源的分布式服务发现和配置管理系统，采用 Go 语言开发，官网：<a target="_blank" rel="noopener" href="https://developer.hashicorp.com/consul">https://developer.hashicorp.com/consul</a></p>
<ul>
<li>提供了微服务系统中心的服务治理，配置中心，控制总线等功能</li>
<li>基于 Raft 协议，支持健康检查，同时支持 HTTP 和 DNS 协议支持跨数据中心的 WAN 集群</li>
<li>提供图形界面</li>
</ul>
<p>下载 Consul 后，运行指令：<code>consul -version</code></p>
<pre><code class="bash">D:\Program Files\Java&gt;consul -version
Consul v1.15.1
Revision 7c04b6a0
Build Date 2023-03-07T20:35:33Z
Protocol 2 spoken by default, understands 2 to 3 (.....)
</code></pre>
<p>启动命令：</p>
<pre><code class="bash">consul agent -dev
</code></pre>
<p>访问浏览器：<a target="_blank" rel="noopener" href="http://localhost:8500/">http://localhost:8500/</a></p>
<p>中文文档：<a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a></p>
<hr>
<h4 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h4><p>无需 Server 端代码的编写</p>
<p>生产者：</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：</p>
<pre><code class="yaml">###consul 服务端口号
server:
  port: 8006

spring:
  application:
    name: consul-provider-payment
  ####consul注册中心地址
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: $&#123;spring.application.name&#125;
</code></pre>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@SpringBootApplication
@EnableDiscoveryClient
public class PaymentMain8006 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8006.class, args);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>消费者：</p>
<ul>
<li><p>application.yml：</p>
<pre><code class="yaml">###consul服务端口号
server:
  port: 80

spring:
  application:
    name: cloud-consumer-order
  ####consul注册中心地址
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        #hostname: 127.0.0.1
        service-name: $&#123;spring.application.name&#125;
</code></pre>
</li>
<li><p>主启动类：同生产者</p>
</li>
<li><p>配置类：</p>
<pre><code class="java">@Configuration
public class ApplicationContextConfig &#123;
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate() &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
</li>
<li><p>业务类 Controller：</p>
<pre><code class="java">@RestController
@Slf4j
public class OrderConsulController &#123;
    public static final String INVOKE_URL = &quot;http://cloud-provider-pament&quot;;

    @Resource
    private RestTemplate restTemplate;

    @GetMapping(&quot;/consumer/payment/consul&quot;)
    public String paymentInfo() &#123;
        return restTemplate.getForObject(INVOKE_URL, String.class);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><div class="story post-story"><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>SpringCloud Ribbon 是基于 Netflix Ribbon 实现的一套负载均衡工具，提供客户端的软件负载均衡算法和服务调用，Ribbon 客户端组件提供一系列完善的配置项如连接超时，重试等</p>
<p>官网： <a target="_blank" rel="noopener" href="https://github.com/Netflix/ribbon/wiki/Getting-Started">https://github.com/Netflix/ribbon/wiki/Getting-Started</a> （已进入维护模式，未来替换为 Load Banlancer）</p>
<p>负载均衡 Load Balance (LB) 就是将用户的请求平摊的分配到多个服务上，从而达到系统的 HA（高可用）</p>
<p><strong>常见的负载均衡算法：</strong></p>
<ul>
<li><p>轮询：为请求选择健康池中的第一个后端服务器，然后按顺序往后依次选择</p>
</li>
<li><p>最小连接：优先选择连接数最少，即压力最小的后端服务器，在会话较长的情况下可以采取这种方式</p>
</li>
<li><p>散列：根据请求源的 IP 的散列（hash）来选择要转发的服务器，可以一定程度上保证特定用户能连接到相同的服务器，如果应用需要处理状态而要求用户能连接到和之前相同的服务器，可以采取这种方式</p>
</li>
</ul>
<p>Ribbon 本地负载均衡客户端与 Nginx 服务端负载均衡区别：</p>
<ul>
<li>Nginx 是服务器负载均衡，客户端所有请求都会交给 Nginx，然后由 Nginx 实现转发请求，即负载均衡是由服务端实现的</li>
<li>Ribbon 本地负载均衡，在调用微服务接口时会在注册中心上获取注册信息服务列表，然后缓存到 JVM 本地，从而在本地实现 RPC 远程服务调用技术</li>
</ul>
<p>集中式 LB 和进程内 LB 的对比：</p>
<ul>
<li>集中式 LB：在服务的消费方和提供方之间使用独立的 LB 设施（如 Nginx），由该设施把访问请求通过某种策略转发至服务的提供方</li>
<li>进程内 LB：将 LB 逻辑集成到消费方，消费方从服务注册中心获知有哪些服务可用，然后从中选择出一个服务器，Ribbon 属于该类</li>
</ul>
<hr>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>Ribbon 是一个软负载均衡的客户端组件</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Ribbon%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Ribbon%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Ribbon架构原理"></p>
<ul>
<li>第一步先选择 EurekaServer，优先选择在同一个区域内负载较少的 Server</li>
<li>第二步根据用户指定的策略，再从 Server 取到的服务注册列表中选择一个地址</li>
</ul>
<hr>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>Ribbon 核心组件 IRule 接口，主要实现类：</p>
<ul>
<li>RoundRobinRule：轮询</li>
<li>RandomRule：随机</li>
<li>RetryRule：先按照 RoundRobinRule 的策略获取服务，如果获取服务失败则在指定时间内会进行重试</li>
<li>WeightedResponseTimeRule：对 RoundRobinRule 的扩展，响应速度越快的实例选择权重越大，越容易被选择</li>
<li>BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li>
<li>AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例</li>
<li>ZoneAvoidanceRule：默认规则，复合判断 Server 所在区域的性能和 Server 的可用性选择服务器</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-IRule%E7%B1%BB%E5%9B%BE.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-IRule%E7%B1%BB%E5%9B%BE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-IRule类图"></p>
<p>注意：官方文档明确给出了警告，自定义负载均衡配置类不能放在 @ComponentScan 所扫描的当前包下以及子包下</p>
<p>更换负载均衡算法方式：</p>
<ul>
<li><p>自定义负载均衡配置类 MySelfRule：</p>
<pre><code class="java">@Configuration
public class MySelfRule &#123;
    @Bean
    public IRule myRule() &#123;
        return new RandomRule();//定义为随机负载均衡算法
    &#125;
&#125;
</code></pre>
</li>
<li><p>主启动类添加 @RibbonCilent 注解</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
// 指明访问的服务CLOUD-PAYMENT-SERVICE，以及指定负载均衡策略
@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration= MySelfRule.class)
public class OrderMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderMain80.class, args);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Feign 是一个声明式 WebService 客户端，能让编写 Web 客户端更加简单，只要创建一个接口并添加注解 @Feign 即可，可以与 Eureka 和 Ribbon 组合使用支持负载均衡，所以一般<strong>用在消费者端</strong></p>
<p>OpenFeign 在 Feign 的基础上支持了 SpringMVC 注解，并且 @FeignClient 注解可以解析 @RequestMapping 注解下的接口，并通过动态代理的方式产生实现类，在实现类中做负载均衡和服务调用</p>
<p>优点：利用 RestTemplate 对 HTTP 请求的封装处理，形成了一套模版化的调用方法。但是对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以一个微服务接口上面标注一个 @Feign 注解，就可以完成包装依赖服务的调用</p>
<hr>
<h4 id="基本使用-5"><a href="#基本使用-5" class="headerlink" title="基本使用"></a>基本使用</h4><p>@FeignClient(“provider name”) 注解使用规则：</p>
<ul>
<li>声明的方法签名必须和 provider 微服务中的 controller 中的方法签名一致</li>
<li>如果需要传递参数，那么 <code>@RequestParam</code> 、<code>@RequestBody</code> 、<code>@PathVariable</code> 也需要加上</li>
</ul>
<p>改造消费者服务</p>
<ul>
<li><p>引入 pom 依赖：OpenFeign 整合了 Ribbon，具有负载均衡的功能</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：不将其注册到 Eureka 作为微服务</p>
<pre><code class="yaml">server:
  port: 80

eureka:
  client:
    # 表示不将其注入Eureka作为微服务，不作为Eureak客户端了，而是作为Feign客户端
    register-with-eureka: false
    service-url:
      # 集群版
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
</code></pre>
</li>
<li><p>主启动类：开启 Feign</p>
<pre><code class="java">@SpringBootApplication
@EnableFeignClients //不作为Eureak客户端了，而是作为Feign客户端
public class OrderOpenFeignMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderOpenFeignMain80.class, args);
    &#125;

&#125;
</code></pre>
</li>
<li><p>新建 Service 接口：PaymentFeignService 接口和 @FeignClient 注解，完成 Feign 的包装调用</p>
<pre><code class="java">@Component
@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;) // 作为一个Feign功能绑定的的接口
public interface PaymentFeignService &#123;
    @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) long id);
    
    @GetMapping(&quot;/payment/feign/timeout&quot;)
    public String paymentFeignTimeout();
&#125;
</code></pre>
</li>
<li><p>Controller：</p>
<pre><code class="java">@RestController
@Slf4j
public class OrderFeignController &#123;
    @Autowired
    private PaymentFeignService paymentFeignService;

    @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) long id) &#123;
        // 返回对象为响应体中数据转化成的对象，基本上可以理解为JSON
        return paymentFeignService.getPaymentById(id);
    &#125;
    
    @GetMapping(&quot;/consumer/payment/feign/timeout&quot;)
    public String paymentFeignTimeout() &#123;
        // openfeign-ribbon，客户端一般默认等待1s
        return paymentFeignService.paymentFeignTimeout();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h4><p>Feign 默认是支持 Ribbon，Feign 客户端的负载均衡和超时控制都由 Ribbon 控制</p>
<p>设置 Feign 客户端的超时等待时间：</p>
<pre><code class="yaml">ribbon:
  #指的是建立连接后从服务器读取到可用资源所用的时间
  ReadTimeout: 5000
  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间
  ConnectTimeout: 5000
</code></pre>
<p>演示超时现象：OpenFeign 默认等待时间为 1 秒钟，超过后会报错</p>
<ul>
<li><p>服务提供方 Controller：</p>
<pre><code class="java">@GetMapping(&quot;/payment/feign/timeout&quot;)
public String paymentFeignTimeout() &#123;
    try &#123;
        TimeUnit.SECONDS.sleep(3);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    return serverPort;
&#125;
</code></pre>
</li>
<li><p>消费者 PaymentFeignService 和 OrderFeignController 参考上一小节代码</p>
</li>
<li><p>测试报错：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-OpenFeign%E8%B6%85%E6%97%B6%E9%94%99%E8%AF%AF.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-OpenFeign%E8%B6%85%E6%97%B6%E9%94%99%E8%AF%AF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-OpenFeign超时错误">!](C:\Users\Seazean\Desktop\123\Cloud-OpenFeign超时错误.png)</p>
</li>
</ul>
<hr>
<h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>Feign 提供了日志打印功能，可以通过配置来调整日志级别，从而了解 Feign 中 HTTP 请求的细节</p>
<table>
<thead>
<tr>
<th>NONE</th>
<th>默认的，不显示任何日志</th>
</tr>
</thead>
<tbody><tr>
<td>BASIC</td>
<td>仅记录请求方法、URL、响应状态码及执行时间</td>
</tr>
<tr>
<td>HEADERS</td>
<td>除了 BASIC 中定义的信息之外，还有请求和响应的头信息</td>
</tr>
<tr>
<td>FULL</td>
<td>除了 HEADERS 中定义的信息外，还有请求和响应的正文及元数据</td>
</tr>
</tbody></table>
<p>配置在消费者端</p>
<ul>
<li><p>新建 config.FeignConfig 文件：配置日志 Bean</p>
<pre><code class="java">@Configuration
public class FeignConfig &#123;
    @Bean
    Logger.Level feignLoggerLevel() &#123;
        return Logger.Level.FULL;
    &#125;
&#125;
</code></pre>
</li>
<li><p>application.yml：</p>
<pre><code class="yaml">logging:
  level:
    # feign 日志以什么级别监控哪个接口
    com.atguigu.springcloud.service.PaymentFeignService: debug
</code></pre>
</li>
<li><p>Debug 后查看后台日志</p>
</li>
</ul>
<hr>
</div><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><div class="story post-story"><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Hystrix 是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖会出现调用失败，比如超时、异常等，Hystrix 能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</p>
<p>断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间地占用，避免了故障在分布式系统中的蔓延，乃至雪崩</p>
<ul>
<li>服务降级 Fallback：系统不可用时需要一个兜底的解决方案或备选响应，向调用方返回一个可处理的响应</li>
<li>服务熔断 Break：达到最大服务访问后，直接拒绝访问</li>
<li>服务限流 Flowlimit：高并发操作时严禁所有请求一次性过来拥挤，一秒钟 N 个，有序排队进行</li>
</ul>
<p>官方文档：<a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p>
<hr>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><h5 id="案例构建"><a href="#案例构建" class="headerlink" title="案例构建"></a>案例构建</h5><p>生产者模块：</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>主启动类：开启 Feign</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
@EnableCircuitBreaker // 降级使用
public class PaymentHystrixMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentHystrixMain8001.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>Controller：</p>
<pre><code class="java">@RestController
@Slf4j
public class PaymentController &#123;
    @Resource
    private PaymentService paymentService;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    // 正常访问
    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    private String paymentInfo_Ok(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return paymentService.paymentInfo_Ok(id);
    &#125;
    // 超时
    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    private String paymentInfo_Timeout(@PathVariable(&quot;id&quot;) Integer id) &#123;
        // service 层有 Thread.sleep() 操作，保证超时
        return paymentService.paymentInfo_Timeout(id);
    &#125;
&#125;
</code></pre>
</li>
<li><p>Service：</p>
<pre><code class="java">@Service
public class PaymentService &#123;
    public String paymentInfo_Ok(Integer id) &#123;
        return &quot;线程池: &quot; + Thread.currentThread().getName() + &quot;paymentInfo_OK, id:  &quot; + id&quot;;
    &#125;

    public String paymentInfo_Timeout(Integer id) &#123;
        int timeNumber = 3;
        try &#123;
            TimeUnit.SECONDS.sleep(timeNumber);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;线程池: &quot; + Thread.currentThread().getName() + &quot; payment_Timeout, id:  &quot; + id;
    &#125;
&#125;
</code></pre>
</li>
<li><p>jmeter 压测两个接口，发现接口 paymentInfo_Ok 也变的卡顿</p>
</li>
</ul>
<p>消费者模块：</p>
<ul>
<li><p>Service 接口：</p>
<pre><code class="java">@Component
@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)
public interface PaymentHystrixService &#123;
    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_Ok(@PathVariable(&quot;id&quot;) Integer id);

    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_Timeout(@PathVariable(&quot;id&quot;) Integer id);
&#125;
</code></pre>
</li>
<li><p>Controller：</p>
<pre><code class="java">@RestController
@Slf4j
public class OrderHystirxController &#123;
    @Resource
    PaymentHystrixService paymentHystrixService;

    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_Ok(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return paymentHystrixService.paymentInfo_Ok(id);
    &#125;

    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_Timeout(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return paymentHystrixService.paymentInfo_Timeout(id);
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试：使用的是 Feign 作为客户端，默认 1s 没有得到响应就会报超时错误，进行并发压测</p>
</li>
<li><p>解决：</p>
<ul>
<li>超时导致服务器变慢（转圈）：超时不再等待</li>
<li>出错（宕机或程序运行出错）：出错要有兜底</li>
</ul>
</li>
</ul>
<hr>
<h5 id="降级操作"><a href="#降级操作" class="headerlink" title="降级操作"></a>降级操作</h5><p>生产者端和消费者端都可以进行服务降级，使用 @HystrixCommand 注解指定降级后的方法</p>
<p>生产者端：主启动类添加新注解 @EnableCircuitBreaker，业务类（Service）方法进行如下修改，</p>
<pre><code class="java">// 模拟拥堵的情况
@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeoutHandler&quot;, commandProperties = &#123;
    //规定这个线程的超时时间是3s，3s后就由fallbackMethod指定的方法“兜底”（服务降级）
    @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;3000&quot;)
&#125;)
public String paymentInfo_Timeout(Integer id) &#123;
    // 超时或者出错
&#125;

public String paymentInfo_TimeoutHandler(Integer id) &#123;
    return &quot;线程池：&quot; + Thread.currentThread().getName() + &quot; paymentInfo_TimeoutHandler, id: &quot; + id&quot;;
&#125;
</code></pre>
<p>服务降级的方法和业务处理的方法混杂在了一块，耦合度很高，并且每个方法配置一个服务降级方法</p>
<ul>
<li>在业务类Controller上加 @DefaultProperties(defaultFallback &#x3D; “method_name”) 注解</li>
<li>在需要服务降级的方法上标注 @HystrixCommand 注解，如果 @HystrixCommand 里没有指明 fallbackMethod，就默认使用 @DefaultProperties 中指明的降级服务</li>
</ul>
<pre><code class="java">@RestController
@Slf4j
@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)
public class OrderHystrixController &#123;
    @Resource
    PaymentHystrixService paymentHystrixService;

    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_Ok(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return paymentHystrixService.paymentInfo_OK(id);
    &#125;

    @HystrixCommand
    public String paymentInfo_Timeout(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return paymentHystrixService.paymentInfo_Timeout(id);
    &#125;

    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return &quot;fallback&quot;;
    &#125;

    // 下面是全局fallback方法
    public String payment_Global_FallbackMethod() &#123;
        return &quot;Global fallback&quot;;
    &#125;
&#125;
</code></pre>
<p>客户端调用服务端，遇到服务端宕机或关闭等极端情况，为 Feign 客户端定义的接口添加一个服务降级实现类即可实现解耦</p>
<ul>
<li><p>application.yml：配置文件中开启了 Hystrix</p>
<pre><code class="yaml"># 用于服务降级 在注解 @FeignClient中添加fallbackFactory属性值
feign:
  hystrix:
    enabled: true  #在Feign中开启Hystrix
</code></pre>
</li>
<li><p>Service：统一为接口里面的方法进行异常处理，服务异常找 PaymentFallbackService，来统一进行服务降级的处理</p>
<pre><code class="java">@Component
@FeignClient(value = &quot;PROVIDER-HYSTRIX-PAYMENT&quot;, fallback = PaymentFallbackService.class)
public interface PaymentHystrixService &#123;

    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);

    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_Timeout(@PathVariable(&quot;id&quot;) Integer id);
&#125;
</code></pre>
</li>
<li><p>PaymentFallbackService：</p>
<pre><code class="java">@Component
public class PaymentFallbackService implements PaymentHystrixService &#123;
    @Override
    public String paymentInfo_OK(Integer id) &#123;
        return &quot;------PaymentFallbackService-paymentInfo_Ok, fallback&quot;;
    &#125;

    @Override
    public String paymentInfo_Timeout(Integer id) &#123;
        return &quot;------PaymentFallbackService-paymentInfo_Timeout, fallback&quot;;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h4><h5 id="熔断类型"><a href="#熔断类型" class="headerlink" title="熔断类型"></a>熔断类型</h5><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息</p>
<p>Hystrix 会监控微服务间调用的状况，当失败的调用到一定阈值，缺省时 5 秒内 20 次调用失败，就会启动熔断机制；当检测到该节点微服务调用响应正常后（检测方式是尝试性放开请求），自动恢复调用链路</p>
<ul>
<li>熔断打开：请求不再进行调用当前服务，再有请求调用时将不会调用主逻辑，而是直接调用降级 fallback。实现了自动的发现错误并将降级逻辑切换为主逻辑，减少响应延迟效果。内部设置时钟一般为 MTTR（Mean time to repair，平均故障处理时间），当打开时长达到所设时钟则进入半熔断状态</li>
<li>熔断关闭：熔断关闭不会对服务进行熔断，服务正常调用</li>
<li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断，反之继续熔断</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Hystrix%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Hystrix%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Hystrix熔断机制"></p>
<hr>
<h5 id="熔断操作"><a href="#熔断操作" class="headerlink" title="熔断操作"></a>熔断操作</h5><p>涉及到断路器的四个重要参数：<strong>快照时间窗、请求总数阀值、窗口睡眠时间、错误百分比阀值</strong></p>
<ul>
<li>circuitBreaker.enabled：是否开启断路器</li>
<li>metrics.rollingStats.timeInMilliseconds：快照时间窗口，断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的 10 秒</li>
<li>circuitBreaker.requestVolumeThreshold：请求总数阀值，该属性设置在快照时间窗内（默认 10s）使断路器跳闸的最小请求数量（默认是 20），如果 10s 内请求数小于设定值，就算请求全部失败也不会触发断路器</li>
<li>circuitBreaker.sleepWindowInMilliseconds：窗口睡眠时间，短路多久以后开始尝试是否恢复进入半开状态，默认 5s</li>
<li>circuitBreaker.errorThresholdPercentage：错误百分比阀值，失败率达到多少后将断路器打开</li>
</ul>
<pre><code class="java"> //总的意思就是在n(10)毫秒内的时间窗口期内，m次请求中有p% (60%)的请求失败了，那么断路器启动
@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;, commandProperties = &#123;
        @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),
        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;), 
        @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;),
        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;)  
&#125;)
public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id) &#123;
    if (id &lt; 0) &#123;
        throw new RuntimeException(&quot;******id 不能负数&quot;);
    &#125;
    String serialNumber = IdUtil.simpleUUID();  // 等价于UUID.randomUUID().toString()

    return Thread.currentThread().getName() + &quot;\t&quot; + &quot;调用成功，流水号: &quot; + serialNumber;
&#125;
</code></pre>
<ul>
<li>开启：满足一定的阈值（默认 10 秒内超过 20 个请求次数）、失败率达到阈值（默认 10 秒内超过 50% 的请求失败）</li>
<li>关闭：一段时间之后（默认是 5 秒），断路器是半开状态，会让其中一个请求进行转发，如果成功断路器会关闭，反之继续开启</li>
</ul>
<hr>
<h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p>具体工作流程：</p>
<ol>
<li><p>创建 HystrixCommand（用在依赖的服务返回单个操作结果的时候） 或 HystrixObserableCommand（用在依赖的服务返回多个操作结果的时候） 对象</p>
</li>
<li><p>命令执行，其中 HystrixComand 实现了下面前两种执行方式，而 HystrixObservableCommand 实现了后两种执行方式</p>
<ul>
<li><p>execute()：同步执行，从依赖的服务返回一个单一的结果对象， 或是在发生错误的时候抛出异常</p>
</li>
<li><p>queue()：异步执行， 直接返回 一个 Future 对象， 其中包含了服务执行结束时要返回的单一结果对象</p>
</li>
<li><p>observe()：返回 Observable 对象，代表了操作的多个结果，它是一个 Hot Obserable（不论事件源是否有订阅者，都会在创建后对事件进行发布，所以对于 Hot Observable 的每个订阅者都有可能是从事件源的中途开始的，并可能只是看到了整个操作的局部过程）</p>
</li>
<li><p>toObservable()：同样会返回 Observable 对象，也代表了操作的多个结果，但它返回的是一个 Cold Observable（没有订阅者的时候并不会发布事件，而是进行等待，直到有订阅者之后才发布事件，所以对于 Cold Observable 的订阅者，它可以保证从一开始看到整个操作的全部过程）</p>
</li>
</ul>
</li>
<li><p>若当前命令的请求缓存功能是被启用的，并且该命令缓存命中，那么缓存的结果会立即以 Observable 对象的形式返回</p>
</li>
<li><p>检查断路器是否为打开状态，如果断路器是打开的，那么 Hystrix 不会执行命令，而是转接到 fallback 处理逻辑（第 8 步）；如果断路器是关闭的，检查是否有可用资源来执行命令（第 5 步）</p>
</li>
<li><p>线程池&#x2F;请求队列&#x2F;信号量是否占满，如果命令依赖服务的专有线程池和请求队列，或者信号量（不使用线程池时）已经被占满， 那么 Hystrix 也不会执行命令， 而是转接到 fallback 处理逻辑（第 8 步）</p>
</li>
<li><p>Hystrix 会根据我们编写的方法来决定采取什么样的方式去请求依赖服务</p>
<ul>
<li>HystrixCommand.run()：返回一个单一的结果，或者抛出异常</li>
<li>HystrixObservableCommand.construct()：返回一个Observable 对象来发射多个结果，或通过 onError 发送错误通知</li>
</ul>
</li>
<li><p>Hystrix会将”成功”、”失败”、”拒绝”、”超时”等信息报告给断路器，而断路器会维护一组计数器来统计这些数据。断路器会使用这些统计数据来决定是否要将断路器打开，来对某个依赖服务的请求进行”熔断&#x2F;短路”</p>
</li>
<li><p>当命令执行失败的时候，Hystrix 会进入 fallback 尝试回退处理，通常也称该操作为”服务降级”，而能够引起服务降级情况：</p>
<ul>
<li>第 4 步：当前命令处于”熔断&#x2F;短路”状态，断路器是打开的时候</li>
<li>第 5 步：当前命令的线程池、请求队列或 者信号量被占满的时候</li>
<li>第 6 步：HystrixObservableCommand.construct() 或 HystrixCommand.run() 抛出异常的时候</li>
</ul>
</li>
<li><p>当 Hystrix 命令执行成功之后， 它会将处理结果直接返回或是以 Observable 的形式返回</p>
</li>
</ol>
<p>注意：如果、没有为命令实现降级逻辑或者在降级处理逻辑中抛出了异常， Hystrix 依然会返回一个 Observable 对象， 但是它不会发射任何结果数据，而是通过 onError 方法通知命令立即中断请求，并通过 onError() 方法将引起命令失败的异常发送给调用者</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Hystrix%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Hystrix%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Hystrix工作流程"></p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">https://github.com/Netflix/Hystrix/wiki/How-it-Works</a></p>
<hr>
<h4 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h4><p>Hystrix 提供了准实时的调用监控（Hystrix Dashboard），Hystrix 会持续的记录所有通过 Hystrix 发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等，Netflix 通过 <code>hystrix-metrics-event-stream</code> 项目实现了对以上指标的监控，Spring Cloud 提供了 Hystrix Dashboard 的整合，对监控内容转化成可视化页面</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：只需要端口即可</p>
<pre><code class="yaml">server:
  port: 9001
</code></pre>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@SpringBootApplication
@EnableHystrixDashboard // 开启Hystrix仪表盘
public class HystrixDashboardMain9001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(HystrixDashboardMain9001.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>所有微服务（生产者）提供类 8001&#x2F;8002&#x2F;8003 都需要监控依赖配置</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>启动测试：<a target="_blank" rel="noopener" href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Hystrix可视化界面.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Hystrix可视化界面.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Hystrix可视化界面" style="zoom: 67%;">
</li>
<li><p>新版本 Hystrix 需要在需要监控的微服务端的主启动类中指定监控路径，不然会报错</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient  // 本服务启动后会自动注册进eureka服务中
@EnableCircuitBreaker  // 对hystrixR熔断机制的支持
public class PaymentHystrixMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentHystrixMain8001.class, args);
    &#125;

    /** ======================================需要添加的代码==================
     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑
     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，
     *只要在自己的项目里配置上下面的servlet就可以了
     */
    @Bean
    public ServletRegistrationBean getServlet() &#123;
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);
        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
        return registrationBean;
    &#125;
&#125;
</code></pre>
</li>
<li><p>指标说明：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Hystrix%E7%95%8C%E9%9D%A2%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Hystrix%E7%95%8C%E9%9D%A2%E5%9B%BE%E7%A4%BA%E8%AF%B4%E6%98%8E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Hystrix界面图示说明"></p>
</li>
</ul>
<hr>
</div><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><div class="story post-story"><h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><p>SpringCloud 中所集成的 Zuul 版本，采用的是 Tomcat 容器，基于 Servlet 之上的一个阻塞式处理模型，不支持任何长连接，用 Java 实现，而 JVM 本身会有第一次加载较慢的情况，使得 Zuul 的性能相对较差</p>
<p>官网：   <a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul/wiki">https://github.com/Netflix/zuul/wiki</a></p>
<hr>
<h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>SpringCloud Gateway 是 Spring Cloud 的一个全新项目，基于 Spring 5.0+Spring Boot 2.0 和 Project Reactor 等技术开发的网关，旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<ul>
<li>基于 WebFlux 框架实现，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty（异步非阻塞响应式的框架）</li>
<li>基于 Filter 链的方式提供了网关基本的功能，例如：安全、监控&#x2F;指标、限流等</li>
</ul>
<p>Gateway 的三个核心组件：</p>
<ul>
<li>Route：路由是构建网关的基本模块，由 ID、目标 URI、一系列的断言和过滤器组成，如果断言为 true 则匹配该路由</li>
<li>Predicate：断言，可以匹配 HTTP 请求中的所有内容（例如请求头或请求参数），如果请求参数与断言相匹配则进行路由</li>
<li>Filter：指 Spring 框架中的 GatewayFilter实例，使用过滤器可以在请求被路由前或之后（拦截）对请求进行修改</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Gateway%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Gateway%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Gateway工作流程"></p>
<p>核心逻辑：路由转发 + 执行过滤器链</p>
<ul>
<li>客户端向 Spring Cloud Gateway 发出请求，然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler</li>
<li>Handler 通过指定的过滤器链来将请求发送到际的服务执行业务逻辑，然后返回</li>
<li>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（pre）或之后（post）执行业务逻辑</li>
<li>Filter 在 pre 类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在 post 类型的过滤器中可以做响应内容、响应头的修改、日志的输出、流量监控等</li>
</ul>
<hr>
<h4 id="网关使用"><a href="#网关使用" class="headerlink" title="网关使用"></a>网关使用</h4><h5 id="配置方式-2"><a href="#配置方式-2" class="headerlink" title="配置方式"></a>配置方式</h5><p>Gateway 网关路由有两种配置方式，分别为通过 yml 配置和注入 Bean</p>
<ul>
<li><p>引入 pom 依赖：Gateway 不需要 spring-boot-starter-web 依赖，否在会报错，原因是底层使用的是 WebFlux 与 Web 冲突</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：</p>
<pre><code class="yaml">server:
  port: 9527

spring:
  application:
    name: cloud-gateway

eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表内
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版
</code></pre>
</li>
<li><p>主启动类（网关不需要业务类）：</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
public class GateWayMain9527 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(GateWayMain9527.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>以前访问 provider-payment8001 中的 Controller 方法，通过 localhost:8001&#x2F;payment&#x2F;get&#x2F;id 和 localhost:8001&#x2F;payment&#x2F;lb，项目不想暴露 8001 端口号，希望在 8001 外面套一层 9527 端口：</p>
<pre><code class="yaml">server:
  port: 9527

spring:
  application:
    name: cloud-gateway
## =====================新增====================
  cloud:
    gateway:
      routes:
        - id: payment_routh # payment_route    #路由的ID，没有固定规则但要求【唯一】，建议配合服务名
          uri: http://localhost:8001        #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**            # 断言，路径相匹配的进行路由

        - id: payment_routh2 # payment_route#路由的ID，没有固定规则但要求【唯一】，建议配合服务名
          uri: http://localhost:8001         #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**            # 断言，路径相匹配的进行路由
</code></pre>
<ul>
<li>uri + predicate 拼接就是具体的接口请求路径，通过 localhost:9527 映射的地址</li>
<li>predicate 断言 <a href="http://localhost:8001下面有一个">http://localhost:8001下面有一个</a> &#x2F;payment&#x2F;get&#x2F;** 的地址，如果找到了该地址就返回 true，可以用 9527 端口访问，进行端口的适配</li>
<li><code>**</code> 表示通配符，因为这是一个不确定的参数</li>
</ul>
</li>
</ul>
<hr>
<h5 id="注入Bean"><a href="#注入Bean" class="headerlink" title="注入Bean"></a>注入Bean</h5><p>通过 9527 网关访问到百度的网址 <a target="_blank" rel="noopener" href="https://www.baidu.com/%EF%BC%8C%E5%9C%A8">https://www.baidu.com/，在</a> config 包下创建一个配置类，路由规则是访问 &#x2F;baidu 跳转到百度</p>
<pre><code class="java">@Configuration
public class GatewayConfig &#123;
    // 配置了一个 id 为 path_route_cloud 的路由规则
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)&#123;
        // 构建一个路由器，这个routes相当于yml配置文件中的routes
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();
        // 路由器的id是：path_route_cloud，规则是访问/baidu ，将会转发到 https://www.baidu.com/
        routes.route(&quot;path_route_cloud&quot;,
                r -&gt; r.path(&quot;/baidu&quot;).uri(&quot; https://www.baidu.com&quot;)).build();
        return routes.build();
    &#125;
&#125;
</code></pre>
<hr>
<h5 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h5><p>Gateway 会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由和负载均衡，避免出现一个路由规则仅对应一个接口方法，当请求地址很多时需要很大的配置文件</p>
<p>application.yml 开启动态路由功能</p>
<pre><code class="yaml">spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true        # 开启从注册中心动态创建路由的功能，利用微服务名进行路由
      routes:
        - id: payment_routh1                       # 路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service        # 匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**              # 断言，路径相匹配的进行路由

        - id: payment_routh2                      #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service        #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**               # 断言，路径相匹配的进行路由
            - After=2021-09-28T19:14:51.514+08:00[Asia/Shanghai]
</code></pre>
<p>lb:&#x2F;&#x2F; 开头代表从注册中心中获取服务，后面是需要转发到的服务名称</p>
<hr>
<h4 id="断言类型"><a href="#断言类型" class="headerlink" title="断言类型"></a>断言类型</h4><p>After Route Predicate：匹配该断言时间之后的 URI 请求</p>
<ul>
<li><p>获取时间：</p>
<pre><code class="java">public class TimeTest &#123;
    public static void main(String[] args) &#123;
        ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区
        System.out.println(zbj); //2023-01-10T16:31:44.106+08:00[Asia/Shanghai]
    &#125;
&#125;
</code></pre>
</li>
<li><p>配置 yml：动态路由小结有配置</p>
</li>
<li><p>测试：正常访问成功，将时间修改到 2023-01-10T16:31:44.106+08:00[Asia&#x2F;Shanghai] 之后访问失败</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Gateway%E6%97%B6%E9%97%B4%E6%96%AD%E8%A8%80.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Gateway%E6%97%B6%E9%97%B4%E6%96%AD%E8%A8%80.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Gateway时间断言"></p>
</li>
</ul>
<p>常见断言类型：</p>
<ul>
<li><p>Before Route Predicate：匹配该断言时间之前的 URI 请求</p>
</li>
<li><p>Between Route Predicate：匹配该断言时间之间的 URI 请求</p>
<pre><code class="yaml">- Between=2022-02-02T17:45:06.206+08:00[Asia/Shanghai],2022-03-25T18:59:06.206+08:00[Asia/Shanghai]
</code></pre>
</li>
<li><p>Cookie Route Predicate：Cookie 断言，两个参数分别是 Cookie name 和正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由</p>
<pre><code class="yaml">- Cookie=username, seazean # 只有发送的请求有 cookie，而且有username=seazean这个数据才能访问，反之404
</code></pre>
</li>
<li><p>Header Route Predicate：请求头断言</p>
<pre><code class="yaml">- Header=X-Request-Id, \d+ # 请求头要有 X-Request-Id 属性，并且值为整数的正则表达式
</code></pre>
</li>
<li><p>Host Route Predicate：指定主机可以访问，可以指定多个用 <code>,</code> 分隔开</p>
<pre><code class="yaml">- Host=**.seazean.com
</code></pre>
</li>
<li><p>Method Route Predicate：请求类型断言</p>
<pre><code class="yaml">- Method=GET    # 只有 Get 请求才能访问
</code></pre>
</li>
<li><p>Path Route Predicate：路径匹配断言</p>
</li>
<li><p>Query Route Predicate：请求参数断言</p>
<pre><code class="yaml">- Query=username, \d+ # 要有参数名 username 并且值还要是整数才能路由
</code></pre>
</li>
</ul>
<hr>
<h4 id="Filter使用"><a href="#Filter使用" class="headerlink" title="Filter使用"></a>Filter使用</h4><p>Filter 链是同时满足一系列的过滤链，路由过滤器可用于修改进入的 HTTP 请求和返回的 HTTP 响应，路由过滤器只能指定路由进行使用，Spring Cloud Gateway 内置了多种路由过滤器，都由 GatewayFilter 的工厂类来产生</p>
<p>配置文件：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories</a></p>
<p>自定义全局过滤器：实现两个主要接口 GlobalFilter, Ordered</p>
<pre><code class="java">@Component
@Slf4j
public class MyLogGateWayFilter implements GlobalFilter, Ordered &#123;

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;
        log.info(&quot;*********************come in MyLogGateWayFilter:  &quot;+ new Date());
        // 取出请求参数的uname对应的值
        String uname = exchange.getRequest().getQueryParams().getFirst(&quot;uname&quot;);
        // 如果 uname 为空，就直接过滤掉，不走路由
        if(uname == null)&#123;
            log.info(&quot;************* 用户名为 NULL 非法用户 o(╥﹏╥)o&quot;);

            // 判断该请求不通过时：给一个回应，返回
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            return exchange.getResponse().setComplete();
        &#125;

        // 反之，调用下一个过滤器，也就是放行：在该环节判断通过的 exchange 放行，交给下一个 filter 判断
        return chain.filter(exchange);
    &#125;
    
    // 设置这个过滤器在Filter链中的加载顺序，数字越小，优先级越高
    @Override
    public int getOrder() &#123;
        return 0;
    &#125;
&#125;
</code></pre>
<hr>
</div><h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2><div class="story post-story"><h3 id="config-1"><a href="#config-1" class="headerlink" title="config"></a>config</h3><h4 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>SpringCloud Config 为微服务架构中的微服务提供集中化的外部配置支持（Git&#x2F;GitHub），为各个不同微服务应用的所有环境提供了一个中心化的外部配置（Config Server）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Config%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Config%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Config工作原理"></p>
<p>SpringCloud Config 分为服务端和客户端两部分</p>
<ul>
<li>服务端也称为分布式配置中心，是一个独立的微服务应用，连接配置服务器并为客户端提供获取配置信息，加密&#x2F;解密等信息访问接口</li>
<li>客户端通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动时从配置中心获取和加载配置信息，配置服务器默认采用 Git 来存储配置信息，这样既有助于对环境配置进行版本管理，也可以通过 Git 客户端来方便的管理和访问配置内容</li>
</ul>
<p>优点：</p>
<ul>
<li>集中管理配置文件</li>
<li>不同环境不同配置，动态化的配置更新，分环境部署比如 dev&#x2F;test&#x2F;prod&#x2F;beta&#x2F;release</li>
<li>运行期间动态调整配置，服务向配置中心统一拉取配置的信息，<strong>服务不需要重启即可感知到配置的变化并应用新的配置</strong></li>
<li>将配置信息以 Rest 接口的形式暴露</li>
</ul>
<p>官网： <a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/</a></p>
<hr>
<h4 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h4><p>构建 Config Server 模块</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;!--springCloud Config Server--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：</p>
<pre><code class="yaml">server:
  port: 3344

spring:
  application:
    name:  cloud-config-center #注册进Eureka服务器的微服务名
  cloud:
    config:
      server:
        git:
          # GitHub上面的git仓库名字 这里可以写https地址跟ssh地址，https地址需要配置username和 password
          uri: git@github.com:seazean/springcloud-config.git
          default-label: main
          search-paths:
            - springcloud-config    # 搜索目录
          # username: 
          # password:
      label: main   # 读取分支,以前是master

#服务注册到eureka地址
eureka:
  client:
    service-url:
    defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka #集群版
</code></pre>
<p>search-paths 表示远程仓库下有一个叫做 springcloud-config 的，label 则表示读取 main分支里面的内容</p>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
@EnableConfigServer   //开启SpringCloud的
public class ConfigCenterMain3344 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ConfigCenterMain3344.class, args);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>配置读取规则：</p>
<pre><code class="yaml">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]
/&#123;application&#125;-&#123;profile&#125;.yml
/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml
/&#123;application&#125;-&#123;profile&#125;.properties
/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties
</code></pre>
<ul>
<li>label：分支</li>
<li>name：服务名</li>
<li>profile：环境（dev&#x2F;test&#x2F;prod）</li>
</ul>
<p>比如：<a target="_blank" rel="noopener" href="http://localhost:3344/master/config-dev.yaml">http://localhost:3344/master/config-dev.yaml</a></p>
<hr>
<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><h5 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h5><p>配置客户端 Config Client，客户端从配置中心（Config Server）获取配置信息</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;!--这里就是客户端的SpringCloud config 因为是客户端所以没有server--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>bootstrap.yml：系统级配置，优先级更高，application.yml 是用户级的资源配置项</p>
<p>Spring Cloud 会创建一个 Bootstrap Context 作为 Spring 应用的 Application Context 的父上下文，初始化的时候 Bootstrap Context 负责从外部源加载配置属性并解析配置，这两个上下文共享一个从外部获取的 Environment，为了配置文件的加载顺序和分级管理，这里使用 bootstrap.yml</p>
<pre><code class="yaml">server:
  port: 3355    # 构建多个微服务，3366 3377 等

spring:
  application:
    name: config-client
  cloud:
    #Config客户端配置
    config:
      label: main     #分支名称 以前是master
      name: config     #配置文件名称
      profile: dev     #读取后缀名称   
      # main分支上config-dev.yml的配置文件被读取 http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 # 配置中心地址k

#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka
</code></pre>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
public class ConfigClientMain3355 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ConfigClientMain3355.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>业务类：将配置信息以 REST 窗口的形式暴露</p>
<pre><code class="java">@RestController
public class ConfigClientController &#123;
    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/configInfo&quot;)
    public String getConfigInfo() &#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h5 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h5><p>分布式配置的动态刷新问题，修改 GitHub 上的配置文件，Config Server 配置中心立刻响应，但是 Config Client 客户端没有任何响应，需要重启客户端</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;!--web/actuator这两个一般一起使用，写在一起--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>修改 yml，暴露监控端口：SpringBoot 的 actuator 启动端点监控 Web 端默认加载默认只有两个 info，health 可见的页面节点</p>
<pre><code class="yaml">management: 
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;         # 表示包含所有节点页面
        exclude: env,beans    # 表示排除env、beans
</code></pre>
</li>
<li><p>业务类：加 @RefreshScope 注解</p>
<pre><code class="java">@RestController
@RefreshScope
public class ConfigClientController &#123;
    // 从配置文件中取前缀为server.port的值
    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;
    // config-&#123;profile&#125;.yml
    @GetMapping(&quot;/configInfo&quot;)
    public String getConfigInfo() &#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>此时客户端还是没有刷新，需要发送 POST 请求刷新 3355：<code>curl -X POST &quot;http://localhost:3355/actuator/refresh</code></p>
<p>引出问题：</p>
<ul>
<li>在微服务多的情况下，每个微服务都需要执行一个 POST 请求，手动刷新成本太大</li>
<li>可否广播，一次通知，处处生效，大范围的实现自动刷新</li>
</ul>
<p>解决方法：Bus 总线</p>
<hr>
</div><h2 id="服务消息"><a href="#服务消息" class="headerlink" title="服务消息"></a>服务消息</h2><div class="story post-story"><h3 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h3><h4 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Spring Cloud Bus 能管理和传播分布式系统间的消息，就像分布式执行器，可用于广播状态更改、事件推送、微服务间的通信通道等</p>
<p>消息总线：在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称为消息总线</p>
<p>基本原理：ConfigClient 实例都监听 MQ 中同一个 Topic（默认 springCloudBus)，当一个服务刷新数据时，会把信息放入 Topic 中，这样其它监听同一 Topic 的服务就能得到通知，然后去更新自身的配置</p>
<hr>
<h4 id="全局广播"><a href="#全局广播" class="headerlink" title="全局广播"></a>全局广播</h4><p>利用消息总线接触一个服务端 ConfigServer 的 <code>/bus/refresh</code> 断点，从而刷新所有客户端的配置</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Bus全局广播架构.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Bus全局广播架构.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Bus全局广播架构" style="zoom:67%;">

<p>改造 ConfigClient：</p>
<ul>
<li><p>引入 MQ 的依赖：</p>
<pre><code class="xml">&lt;!--添加消息总线RabbitMQ支持--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>yml 文件添加 MQ 信息：</p>
<pre><code class="yaml">server:
  port: 3344

spring:
  application:
    name:  config-client #注册进Eureka服务器的微服务名
  cloud:
  # rabbitmq相关配置
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest

# rabbitmq相关配置,暴露bus刷新配置的端点
management:
  endpoints: # 暴露bus刷新配置的端点
    web:
      exposure:
        include: &#39;bus-refresh&#39;
</code></pre>
</li>
<li><p>只需要调用一次 <code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh</code>，可以实现全局广播</p>
</li>
</ul>
<hr>
<h4 id="定点通知"><a href="#定点通知" class="headerlink" title="定点通知"></a>定点通知</h4><p>动态刷新情况下，只通知指定的微服务，比如只通知 3355 服务，不通知 3366，指定具体某一个实例生效，而不是全部</p>
<p>公式：<code>http://localhost:port/actuator/bus-refresh/&#123;destination&#125;</code></p>
<p>&#x2F;bus&#x2F;refresh 请求不再发送到具体的服务实例上，而是发给 Config Server 并通过 destination 参数类指定需要更新配置的服务或实例</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Bus%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Bus%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Bus工作流程"></p>
<hr>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Spring Cloud Stream 是一个构建消息驱动微服务的框架，通过定义绑定器 Binder 作为中间层，实现了应用程序与消息中间件细节之间的隔离，屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</p>
<p>Stream 中的消息通信方式遵循了发布订阅模式，Binder 可以生成 Binding 用来绑定消息容器的生产者和消费者，Binding 有两种类型 Input 和 Output，Input 对应于消费者（消费者从 Stream 接收消息），Output 对应于生产者（生产者从 Stream 发布消息）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Stream%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Stream%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Stream工作流程"></p>
<ul>
<li>Binder：连接中间件</li>
<li>Channel：通道，是队列 Queue 的一种抽象，在消息通讯系统中实现存储和转发的媒介，通过 Channel 对队列进行配置</li>
<li>Source、Sink：生产者和消费者</li>
</ul>
<p>中文手册：<a target="_blank" rel="noopener" href="https://m.wang1314.com/doc/webapp/topic/20971999.html">https://m.wang1314.com/doc/webapp/topic/20971999.html</a></p>
<hr>
<h4 id="基本使用-6"><a href="#基本使用-6" class="headerlink" title="基本使用"></a>基本使用</h4><p>Binder 是应用与消息中间件之间的封装，目前实现了 Kafka 和 RabbitMQ 的 Binder，可以动态的改变消息类型（Kafka 的 Topic 和 RabbitMQ 的 Exchange），可以通过配置文件实现，常用注解如下：</p>
<ul>
<li>@Input：标识输入通道，接收的消息通过该通道进入应用程序</li>
<li>@Output：标识输出通道，发布的消息通过该通道离开应用程序</li>
<li>@StreamListener：监听队列，用于消费者队列的消息接收</li>
<li>@EnableBinding：信道 Channel 和 Exchange 绑定</li>
</ul>
<p>生产者发消息模块：</p>
<ul>
<li><p>引入 pom 依赖：RabbitMQ</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：</p>
<pre><code class="yaml">server:
  port: 8801

spring:
  application:
    name: cloud-stream-provider
  cloud:
    stream:
      binders: # 在此处配置要绑定的rabbitmq的服务信息；
        defaultRabbit: # 表示定义的名称，用于于binding整合
          type: rabbit # 消息组件类型
          environment: # 设置rabbitmq的相关的环境配置
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      bindings: # 服务的整合处理
        output: # 这个名字是一个通道的名称
          destination: studyExchange         # 表示要使用的Exchange名称定义
          content-type: application/json    # 设置消息类型，本次为json，文本则设置“text/plain”
          binder: defaultRabbit             # 设置要绑定的消息服务的具体设置

eureka:
  client: # 客户端进行Eureka注册的配置
    service-url:
      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka
  instance:
    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）
    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）
    instance-id: send-8801.com  # 在信息列表时显示主机名称
    prefer-ip-address: true     # 访问的路径变为IP地址
</code></pre>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
public class StreamMQMain8801 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(StreamMQMain8801.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>业务类：MessageChannel 的实例名必须是 output，否则无法启动</p>
<pre><code class="java">// 可以理解为定义消息的发送管道Source对应output(生产者)，Sink对应input(消费者)
@EnableBinding(Source.class)
// @Service：这里不需要，不是传统的controller调用service。这个service是和rabbitMQ打交道的
// IMessageProvider 只有一个 send 方法的接口
public class MessageProviderImpl implements IMessageProvider &#123;
    @Resource
    private MessageChannel output; // 消息的发送管道

    @Override
    public String send() &#123;
        String serial = UUID.randomUUID().toString();

        //创建消息，通过output这个管道向消息中间件发消息
        this.output.send(MessageBuilder.withPayload(serial).build());
        System.out.println(&quot;***serial: &quot; + serial);
        return serial;
    &#125;
&#125;
</code></pre>
</li>
<li><p>Controller：</p>
<pre><code class="java">@RestController
public class SendMessageController &#123;
    @Resource
    private IMessageProvider messageProvider;

    @GetMapping(value = &quot;/sendMessage&quot;)
    public String sendMessage() &#123;
        return messageProvider.send();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>消费者模块：8802 和 8803 两个消费者</p>
<ul>
<li><p>application.yml：只标注出与生产者不同的地方</p>
<pre><code class="yaml">server:
  port: 8802

spring:
  application:
    name: cloud-stream-consumer
  cloud:
    stream:
      # ...
      bindings: # 服务的整合处理
        input: # 这个名字是一个通道的名称
          # ...
          binder: &#123; defaultRabbit &#125; # 设置要绑定的消息服务的具体设置

eureka:
  # ...
  instance:
    # ...
    instance-id: receive-8802.com  # 在信息列表时显示主机名称
</code></pre>
</li>
<li><p>Controller：</p>
<pre><code class="java">@Component
@EnableBinding(Sink.class) // 理解为定义一个消息消费者的接收管道
public class ReceiveMessageListener &#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @StreamListener(Sink.INPUT) //输入源：作为一个消息监听者
    public void input(Message&lt;String&gt; message) &#123;
        // 获取到消息
        String messageStr = message.getPayload();
        System.out.println(&quot;消费者1号，-------&gt;接收到的消息：&quot; + messageStr + &quot;\t port: &quot; + serverPort);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><p>重复消费问题：生产者 8801 发送一条消息后，8802 和 8803 会同时收到 8801 的消息</p>
<p>解决方法：微服务应用放置于同一个 group 中，能够保证消息只会被其中一个应用消费一次。不同的组是可以全面消费的（重复消费），同一个组内的多个消费者会发生竞争关系，只有其中一个可以消费</p>
<pre><code class="yaml">bindings:
  input:
    destination: studyExchange
    content-type: application/json
    binder: &#123; defaultRabbit &#125;
    group: seazean    # 设置分组
</code></pre>
<p>消息持久化问题：</p>
<ul>
<li>停止 8802&#x2F;8803 并去除掉 8802 的分组 group: seazean，8801 先发送 4 条消息到 MQ</li>
<li>先启动 8802，无分组属性配置，后台没有打出来消息，消息丢失</li>
<li>再启动 8803，有分组属性配置，后台打印出来了 MQ 上的消息</li>
</ul>
<hr>
<h3 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h3><h4 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Spring Cloud Sleuth 提供了一套完整的分布式请求链路跟踪的解决方案，并且兼容支持了 zipkin</p>
<p>在微服务框架中，一个客户端发起的请求在后端系统中会经过多次不同的服务节点调用来协同产生最后的请求结果，形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败，所以需要链路追踪</p>
<p>Sleuth 官网：<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-sleuth">https://github.com/spring-cloud/spring-cloud-sleuth</a></p>
<p>zipkin 下载地址：<a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/">https://repo1.maven.org/maven2/io/zipkin/java/zipkin-server/</a></p>
<hr>
<h4 id="链路监控"><a href="#链路监控" class="headerlink" title="链路监控"></a>链路监控</h4><p>Sleuth 负责跟踪整理，zipkin 负责可视化展示</p>
<pre><code class="bash">java -jar zipkin-server-2.12.9-exec.jar # 启动 zipkin 
</code></pre>
<p>访问 <a target="_blank" rel="noopener" href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a> 展示交互界面</p>
<p>一条请求链路通过 Trace ID 唯一标识，Span 标识发起的请求信息</p>
<ul>
<li><p>Trace：类似于树结构的 Span 集合，表示一条调用链路，存在唯一 ID 标识</p>
</li>
<li><p>Span：表示调用链路来源，通俗的理解 Span 就是一次请求信息，各个 Span 通过 ParentID 关联起来</p>
</li>
</ul>
<p>服务生产者模块：</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;!--包含了sleuth+zipkin--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：</p>
<pre><code class="yaml">server:
  port: 8001

spring:
  application:
    name: cloud-payment-service
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
      #采样率值介于 0 到 1 之间，1 则表示全部采集
      probability: 1
</code></pre>
</li>
<li><p>业务类：</p>
<pre><code class="java">@GetMapping(&quot;/payment/zipkin&quot;)
public String paymentZipkin() &#123;
    return &quot;hi ,i&#39;am paymentzipkin server fall back，welcome to seazean&quot;;
&#125;
</code></pre>
</li>
</ul>
<p>服务消费者模块：</p>
<ul>
<li><p>application.yml：</p>
<pre><code class="yaml">server:
  port: 80

# 微服务名称
spring:
  application:
    name: cloud-order-service
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
      probability: 1
</code></pre>
</li>
<li><p>业务类：</p>
<pre><code class="java">@GetMapping(&quot;/comsumer/payment/zipkin&quot;)
public String paymentZipKin() &#123;
    String result = restTemplate.getForObject(&quot;http://localhost:8001&quot; + &quot;/payment/zipkin/&quot;, String.class);
    return result;
&#125;
</code></pre>
</li>
</ul>
<hr>
</div><h2 id="Alibaba"><a href="#Alibaba" class="headerlink" title="Alibaba"></a>Alibaba</h2><div class="story post-story"><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务</p>
<ul>
<li>服务限流降级：默认支持 WebServlet、WebFlux、OpenFeign、RestTemplate、Spring Cloud Gateway、Zuul、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li>服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持</li>
<li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新</li>
<li>消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力</li>
<li>分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题</li>
<li>阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务</li>
<li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行</li>
</ul>
<p>官方文档：<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p>
<p>官方手册：<a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html</a></p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><h4 id="基本介绍-18"><a href="#基本介绍-18" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Nacos 全称 Dynamic Naming and Configuration Service，一个更易于构建云原生应用的动态服务发现、配置管理和服务的管理平台，Nacos &#x3D; Eureka + Config + Bus</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p>
<p>启动命令：命令运行成功后直接访问 <a target="_blank" rel="noopener" href="http://localhost:8848/nacos%EF%BC%8C%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E9%83%BD%E6%98%AF">http://localhost:8848/nacos，默认账号密码都是</a> nacos</p>
<pre><code class="bash">startup.cmd -m standalone # standalone 代表着单机模式运行，非集群模式
</code></pre>
<p>关闭命令：</p>
<pre><code class="bash">shutdown.cmd
</code></pre>
<p>注册中心对比：C 一致性，A 可用性，P 分区容错性</p>
<table>
<thead>
<tr>
<th align="center">注册中心</th>
<th align="center">CAP 模型</th>
<th align="center">控制台管理</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Eureka</td>
<td align="center">AP</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">Zookeeper</td>
<td align="center">CP</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">Consul</td>
<td align="center">CP</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">Nacos</td>
<td align="center">AP</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<p>切换模式：<code>curl -X PUT &#39;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP</code></p>
<p>官网：<a target="_blank" rel="noopener" href="https://nacos.io/">https://nacos.io</a></p>
<hr>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>Nacos 作为服务注册中心</p>
<p>服务提供者：</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：</p>
<pre><code class="yaml">server:
  port: 9001

spring:
  application:
    name: nacos-payment-provider
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #配置Nacos地址，注册到Nacos
# 做监控需要把这个全部暴露出来
management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;
</code></pre>
</li>
<li><p>主启动类：注解是 EnableDiscoveryClient</p>
<pre><code class="java">@EnableDiscoveryClient
@SpringBootApplication
public class PaymentMain9001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain9001.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>Controller：</p>
<pre><code class="java">@RestController
public class PaymentController &#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)
    public String getPayment(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return &quot;nacos registry, serverPort: &quot; + serverPort + &quot;\t id&quot; + id;
    &#125;
&#125;
</code></pre>
</li>
<li><p>管理后台服务：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Nacos%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Nacos%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Nacos服务列表"></p>
</li>
<li><p>新建一个模块端口是 9002，其他与 9001 服务一样，nacos-payment-provider 的实例数就变为 2</p>
</li>
</ul>
<p>服务消费者：</p>
<ul>
<li><p>application.yml：</p>
<pre><code class="yaml">server:
  port: 83

spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848

# 消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)
service-url:
  nacos-user-service: http://nacos-payment-provider
</code></pre>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@SpringBootApplication
@EnableDiscoveryClient
public class OrderNacosMain83 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderNacosMain83.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>业务类：</p>
<pre><code class="java">@Configuration
public class ApplicationContextBean &#123;
    @Bean
    @LoadBalanced // 生产者集群状态下，必须添加，防止找不到实例
    public RestTemplate getRestTemplate() &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<pre><code class="java">@RestController
@Slf4j
public class OrderNacosController &#123;
    @Resource
    private RestTemplate restTemplate;
    // 从配置文件中读取 URL
    @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)
    private String serverURL;

    @GetMapping(&quot;/consumer/payment/nacos/&#123;id&#125;&quot;)
    public String paymentInfo(@PathVariable(&quot;id&quot;) Long id) &#123;
        String result = restTemplate.getForObject(serverURL + &quot;/payment/nacos/&quot; + id, String.class);
        return result;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><h5 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h5><p>把配置文件写进 Nacos，然后再用 Nacos 做 config 这样的功能，直接从 Nacos 上抓取服务的配置信息</p>
<p>在 Nacos 中，dataId 的完整格式如下 <code>$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</code></p>
<ul>
<li><code>prefix</code>：默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code> 来配置</li>
<li><code>spring.profiles.active</code>：当前环境对应的 profile，当该值为空时，dataId 的拼接格式变成 <code>$&#123;prefix&#125;.$&#123;file-extension&#125;</code></li>
<li><code>file-exetension</code>：配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置，目前只支持 properties 和 yaml 类型（不是 yml）</li>
</ul>
<p>构建流程：</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>配置两个 yml 文件：配置文件的加载是存在优先级顺序的，bootstrap 优先级高于 application</p>
<p>bootstrap.yml：全局配置</p>
<pre><code class="yaml"># nacos配置
server:
  port: 3377

spring:
  application:
    name: nacos-config-client
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yaml #指定yaml格式的配置

# $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;
</code></pre>
<p>application.yml：服务独立配置，表示服务要去配置中心找名为 nacos-config-client-dev.yaml 的文件</p>
<pre><code class="yaml">spring:
  profiles:
    active: dev # 表示开发环境
</code></pre>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@SpringBootApplication
@EnableDiscoveryClient
public class NacosConfigClientMain3377 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(NacosConfigClientMain3377.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>业务类：@RefreshScope 注解使当前类下的配置支持 Nacos 的动态刷新功能</p>
<pre><code class="java">@RestController
@RefreshScope
public class ConfigClientController &#123;
    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/config/info&quot;)
    public String getConfigInfo() &#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
</li>
<li><p>新增配置，然后访问 <a target="_blank" rel="noopener" href="http://localhost:3377/config/info">http://localhost:3377/config/info</a></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Nacos%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AE.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Nacos%E6%96%B0%E5%A2%9E%E9%85%8D%E7%BD%AE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Nacos新增配置"></p>
</li>
</ul>
<hr>
<h5 id="分类配置"><a href="#分类配置" class="headerlink" title="分类配置"></a>分类配置</h5><p>分布式开发中的多环境多项目管理问题，Namespace 用于区分部署环境，Group 和 DataID 逻辑上区分两个目标对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Nacos%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Nacos%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Nacos配置说明"></p>
<p>Namespace 默认 public，主要用来实现隔离，图示三个开发环境</p>
<p>Group 默认是 DEFAULT_GROUP，Group 可以把不同的微服务划分到同一个分组里面去</p>
<hr>
<h5 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h5><p>DataID 方案：指定 <code>spring.profile.active</code> 和配置文件的 DataID 来使不同环境下读取不同的配置</p>
<p>Group 方案：通过 Group 实现环境分区，在 config 下增加一条 Group 的配置即可</p>
<p>Namespace 方案：</p>
<pre><code class="yaml">server:
  port: 3377

spring:
  application:
    name: nacos-config-client
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yaml #指定yaml格式的配置
        group: DEV_GROUP
        namespace: 95d44530-a4a6-4ead-98c6-23d192cee298
</code></pre>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Nacos%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Nacos%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Nacos命名空间"></p>
<hr>
<h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><p>集群部署参考官方文档，Nacos 支持的三种部署模式：</p>
<ul>
<li>单机模式：用于测试和单机使用</li>
<li>集群模式：用于生产环境，确保高可用</li>
<li>多集群模式：用于多数据中心场景</li>
</ul>
<p>集群部署文档：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/v2/guide/admin/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/v2/guide/admin/cluster-mode-quick-start.html</a></p>
<p>默认 Nacos 使用嵌入式数据库 derby 实现数据的存储，重启 Nacos 后配置文件不会消失，但是多个 Nacos 节点数据存储存在一致性问题，每个 Nacos 都有独立的嵌入式数据库，所以 Nacos 采用了集中式存储的方式来支持集群化部署，目前只支持 MySQL 的存储</p>
<p>Windows 下 Nacos 切换 MySQL 存储：</p>
<ul>
<li><p>在 Nacos 安装目录的 conf 目录下找到一个名为 <code>nacos-mysql.sql</code> 的脚本并执行</p>
</li>
<li><p>在 conf 目录下找到 <code>application.properties</code>，增加如下数据</p>
<pre><code class="properties">spring.datasource.platform=mysql
 
db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true
db.user=username
db.password=password
</code></pre>
</li>
<li><p>重新启动 Nacos，可以看到是个全新的空记录界面</p>
</li>
</ul>
<p>Linux 参考：<a target="_blank" rel="noopener" href="https://www.yuque.com/mrlinxi/pxvr4g/rnahsn#dPvMy">https://www.yuque.com/mrlinxi/pxvr4g/rnahsn#dPvMy</a></p>
<hr>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><h4 id="基本介绍-19"><a href="#基本介绍-19" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件</p>
<p>Sentinel 分为两个部分：</p>
<ul>
<li>核心库（Java 客户端）不依赖任何框架&#x2F;库，能够运行于 Java 8 及以上的版本的运行时环境</li>
<li>控制台（Dashboard）主要负责管理推送规则、监控、管理机器信息等</li>
</ul>
<p>下载到本地，运行命令：<code>java -jar sentinel-dashboard-1.8.2.jar</code> （要求 Java8，且 8080 端口不能被占用），访问 <a target="_blank" rel="noopener" href="http://localhost:8080/%EF%BC%8C%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E5%9D%87%E4%B8%BA">http://localhost:8080/，账号密码均为</a> sentinel</p>
<p>官网：<a target="_blank" rel="noopener" href="https://sentinelguard.io/">https://sentinelguard.io</a></p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></p>
<hr>
<h4 id="基本使用-7"><a href="#基本使用-7" class="headerlink" title="基本使用"></a>基本使用</h4><p>构建演示工程：</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：sentinel.transport.port 端口配置会在应用对应的机器上启动一个 HTTP Server，该 Server 与 Sentinel 控制台做交互。比如 Sentinel 控制台添加了 1 个限流规则，会把规则数据 Push 给 Server 接收，Server 再将规则注册到 Sentinel 中</p>
<pre><code class="yaml">server:
  port: 8401

spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 # Nacos 服务注册中心地址【需要启动Nacos8848】
    sentinel:
      transport:
        # 配置Sentinel dashboard地址
        dashboard: localhost:8080
        # 默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口
        port: 8719

management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;
</code></pre>
</li>
<li><p>主启动类：</p>
<pre><code class="java">@EnableDiscoveryClient
@SpringBootApplication
public class SentinelMainApp8401 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SentinelMainApp8401.class, args);
    &#125;
&#125;
</code></pre>
</li>
<li><p>流量控制 Controller：</p>
<pre><code class="java">@RestController
@Slf4j
public class FlowLimitController &#123;
    @GetMapping(&quot;/testA&quot;)
    public String testA() &#123;
        return &quot;------testA&quot;;
    &#125;

    @GetMapping(&quot;/testB&quot;)
    public String testB() &#123;
        return &quot;------testB&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>Sentinel 采用懒加载机制，需要先访问 <a target="_blank" rel="noopener" href="http://localhost:8401/testA%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%8D%E8%83%BD%E7%9C%8B%E5%88%B0">http://localhost:8401/testA，控制台才能看到</a></p>
</li>
</ul>
<hr>
<h4 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h4><p>流量控制规则 FlowRule：同一个资源可以同时有多个限流规则</p>
<ul>
<li>资源名 resource：限流规则的作用对象，Demo 中为 testA</li>
<li>针对资源 limitApp：针对调用者进行限流，默认为 default 代表不区分调用来源</li>
<li>阈值类型 grade：QPS 或线程数模式</li>
<li>单机阈值 count：限流阈值</li>
<li>流控模式 strategy：调用关系限流策略<ul>
<li>直接：资源本身达到限流条件直接限流</li>
<li>关联：当关联的资源达到阈值时，限流自身</li>
<li>链路：只记录指定链路上的流量，从入口资源进来的流量</li>
</ul>
</li>
<li>流控效果 controlBehavior：<ul>
<li>快速失败：直接失败，抛出异常</li>
<li>Warm Up：冷启动，根据 codeFactory（冷加载因子，默认 3）的值，从 count&#x2F;codeFactory 开始缓慢增加，给系统预热时间</li>
<li>排队等待：匀速排队，让请求以匀速的方式通过，阈值类型必须设置为 QPS，否则无效</li>
</ul>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel增加流控规则.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel增加流控规则.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Sentinel增加流控规则" style="zoom: 40%;">

<p>通过调用 <code>SystemRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则：</p>
<pre><code class="java">private void initSystemProtectionRule() &#123;
  List&lt;SystemRule&gt; rules = new ArrayList&lt;&gt;();
  SystemRule rule = new SystemRule();
  rule.setHighestSystemLoad(10);
  rules.add(rule);
  SystemRuleManager.loadRules(rules);
&#125;
</code></pre>
<p>详细内容参考文档：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/flow-control.html">https://sentinelguard.io/zh-cn/docs/flow-control.html</a></p>
<hr>
<h4 id="降级熔断"><a href="#降级熔断" class="headerlink" title="降级熔断"></a>降级熔断</h4><p>Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）</p>
<p>Sentinel 提供以下几种熔断策略：</p>
<ul>
<li>资源名 resource：限流规则的作用对象，Demo 中为 testA</li>
<li>熔断策略 grade：<ul>
<li>慢调用比例（SLOW_REQUEST_RATIO）：以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断</li>
<li>异常比例（ERROR_RATIO）：当单位统计时长内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态，若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%</li>
<li>异常数 （ERROR_COUNT）：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态，若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断</li>
</ul>
</li>
<li>单机阈值 count：慢调用比例模式下为慢调用临界 RT；异常比例&#x2F;异常数模式下为对应的阈值</li>
<li>熔断时长 timeWindow：单位为 s</li>
<li>最小请求数 minRequestAmount：熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断，默认 5</li>
<li>统计时长 statIntervalMs：单位统计时长</li>
<li>慢调用比例阈值 slowRatioThreshold：仅慢调用比例模式有效</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel增加熔断规则.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel增加熔断规则.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Sentinel增加熔断规则" style="zoom: 67%;">

<p>注意异常降级仅针对业务异常，对 Sentinel 限流降级本身的异常 BlockException 不生效，为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常或者通过<code>@SentinelResource</code> 注解会自动统计业务异常</p>
<pre><code class="java">Entry entry = null;
try &#123;
  entry = SphU.entry(resource);

  // Write your biz code here.
  // &lt;&lt;BIZ CODE&gt;&gt;
&#125; catch (Throwable t) &#123;
  if (!BlockException.isBlockException(t)) &#123;
    Tracer.trace(t);
  &#125;
&#125; finally &#123;
  if (entry != null) &#123;
    entry.exit();
  &#125;
&#125;
</code></pre>
<p>详细内容参考文档：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">https://sentinelguard.io/zh-cn/docs/circuit-breaking.html</a></p>
<hr>
<h4 id="热点限流"><a href="#热点限流" class="headerlink" title="热点限流"></a>热点限流</h4><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流，Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel热点参数限流.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel热点参数限流.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Sentinel热点参数限流" style="zoom: 67%;">

<p>引入 @SentinelResource 注解：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/annotation-support.html">https://sentinelguard.io/zh-cn/docs/annotation-support.html</a></p>
<ul>
<li><p>value：Sentinel 资源名，默认为请求路径，这里 value 的值可以任意写，但是约定与 Restful 地址一致</p>
</li>
<li><p>blockHandler：表示触发了 Sentinel 中配置的流控规则，就会调用兜底方法 <code>del_testHotKey</code></p>
</li>
<li><p>blockHandlerClass：如果设置了该值，就会去该类中寻找 blockHandler 方法</p>
</li>
<li><p>fallback：用于在抛出异常的时候提供 fallback 处理逻辑</p>
<p>说明：fallback 对应服务降级（服务出错了需要有个兜底方法），blockHandler 对应服务熔断（服务不可用的兜底方法）</p>
</li>
</ul>
<pre><code class="java">@GetMapping(&quot;/testHotKey&quot;)
@SentinelResource(value = &quot;testHotKey&quot;, blockHandler = &quot;del_testHotKey&quot;)
public String testHotkey(@RequestParam(value = &quot;p1&quot;, required = false) String p1,
                         @RequestParam(value = &quot;p1&quot;, required = false) String p2) &#123;
    return &quot;------testHotkey&quot;;
&#125;

// 自定义的兜底方法，必须是 BlockException
public String del_testHotKey(String p1, String p2, BlockException e) &#123;
    return &quot;不用默认的兜底提示 Blocked by Sentinel(flow limiting)，自定义提示：del_testHotKeyo.&quot;;
&#125;
</code></pre>
<p>图示设置 p1 参数限流，规则是 1s 访问 1 次，当 p1&#x3D;5 时 QPS &gt; 100，只访问 p2 不会出现限流 <code>http://localhost:8401/testHotKey?p2=b</code></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel增加热点规则.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel增加热点规则.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Sentinel增加热点规则" style="zoom:50%;">

<ul>
<li>参数索引 paramIdx：热点参数的索引，图中索引 0 对应方法中的 p1 参数</li>
<li>参数例外项 paramFlowItemList：针对指定的参数值单独设置限流阈值，不受 count 阈值的限制，<strong>仅支持基本类型和字符串类型</strong></li>
</ul>
<p>说明：@SentinelResource 只管控制台配置规则问题，出现运行时异常依然会报错</p>
<p>详细内容参考文档：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html">https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html</a></p>
<hr>
<h4 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h4><p>Sentinel 系统自适应保护从整体维度对<strong>应用入口流量</strong>进行控制，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性</p>
<p>系统规则支持以下的阈值类型：</p>
<ul>
<li>Load（仅对 Linux&#x2F;Unix-like 机器生效）：当系统 load1 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护，系统容量由系统的 <code>maxQps * minRt</code> 计算得出，设定参考值一般是 <code>CPU cores * 2.5</code></li>
<li>RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒</li>
<li>线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护</li>
<li>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护</li>
<li>CPU usage：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0）</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel增加系统规则.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Sentinel增加系统规则.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Sentinel增加系统规则" style="zoom:50%;">



<p>详细内容参考文档：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html</a></p>
<hr>
<h4 id="服务调用-1"><a href="#服务调用-1" class="headerlink" title="服务调用"></a>服务调用</h4><p>消费者需要进行服务调用</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：激活 Sentinel 对 Feign 的支持</p>
<pre><code class="yaml">feign:
  sentinel:
    enabled: true
</code></pre>
</li>
<li><p>主启动类：加上 @EnableFeignClient 注解开启 OpenFeign</p>
</li>
<li><p>业务类：</p>
<pre><code class="java">// 指明调用失败的兜底方法在PaymentFallbackService，使用 fallback 方式是无法获取异常信息的，
// 如果想要获取异常信息，可以使用 fallbackFactory 参数
@FeignClient(value = &quot;nacos-payment-provider&quot;, fallback = PaymentFallbackService.class)
public interface PaymentFeignService &#123;
    // 去生产则服务中找相应的接口，方法签名一定要和生产者中 controller 的一致
    @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
<pre><code class="java">@Component   //不要忘记注解，降级方法
public class PaymentFallbackService implements PaymentFeignService &#123;
    @Override
    public CommonResult&lt;Payment&gt; paymentSQL(Long id) &#123;
        return new CommonResult&lt;&gt;(444,&quot;服务降级返回,没有该流水信息-------PaymentFallbackSe
</code></pre>
</li>
</ul>
<hr>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>配置持久化：</p>
<ul>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;
    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>添加 Nacos 数据源配置：</p>
<pre><code class="yaml">server:
  port: 8401

spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
    sentinel:
      transport:
        dashboard: localhost:8080
        port: 8719
      # 关闭默认收敛所有URL的入口context，不然链路限流不生效
      web-context-unify: false
      # filter:
        # enabled: false  # 关闭自动收敛

      #持久化配置
      datasource:
        ds1:
          nacos:
            server-addr: localhost:8848
            dataId: cloudalibaba-sentinel-service
            groupId: DEFAULT_GROUP
            data-type: json
            rule-type: flow
</code></pre>
</li>
</ul>
<hr>
<h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><h4 id="分布事物"><a href="#分布事物" class="headerlink" title="分布事物"></a>分布事物</h4><p>一个分布式事务过程，可以用分布式处理过程的一 ID + 三组件模型来描述：</p>
<ul>
<li><p>XID (Transaction ID)：全局唯一的事务 ID，在这个事务ID下的所有事务会被统一控制</p>
</li>
<li><p>TC (Transaction Coordinator)：事务协调者，维护全局和分支事务的状态，驱动全局事务提交或回滚</p>
</li>
<li><p>TM (Transaction Manager)：事务管理器，定义全局事务的范围，开始全局事务、提交或回滚全局事务</p>
</li>
<li><p>RM (Resource Manager)：资源管理器，管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</p>
</li>
</ul>
<p>典型的分布式事务流程：</p>
<ol>
<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID</li>
<li>XID 在微服务调用链路的上下文中传播（也就是在多个 TM，RM 中传播）</li>
<li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖</li>
<li>TM 向 TC 发起针对 XID 的全局提交或回滚决议</li>
<li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-分布式事务流程.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-分布式事务流程.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-分布式事务流程" style="zoom:67%;">



<hr>
<h4 id="基本配置-2"><a href="#基本配置-2" class="headerlink" title="基本配置"></a>基本配置</h4><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案</p>
<p>下载 seata-server 文件修改 conf 目录下的配置文件</p>
<ul>
<li>file.conf：自定义事务组名称、事务日志存储模式为 db、数据库连接信息</li>
</ul>
<p>  <strong>事务分组</strong>：seata 的资源逻辑，可以按微服务的需要，在应用程序（客户端）对自行定义事务分组，每组取一个名字</p>
  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Seata配置文件.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Seata配置文件.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Seata配置文件" style="zoom:50%;">

<ul>
<li><p>数据库新建库 seata，建表 db_store.sql 在 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/2.x/script/server/db">https://github.com/seata/seata/tree/2.x/script/server/db</a> 目录里面</p>
</li>
<li><p>registry.conf：指明注册中心为 Nacos，及修改 Nacos 连接信息</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Seata注册中心配置.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Seata注册中心配置.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Seata注册中心配置" style="zoom: 71%;"></li>
</ul>
<p>启动 Nacos 和 Seata，如果 DB 报错，需要把将 lib 文件夹下 mysql-connector-java-5.1.30.jar 删除，替换为自己 MySQL 连接器版本</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Seata配置成功.png" class="lazyload" data-srcset="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Cloud-Seata配置成功.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Cloud-Seata配置成功" style="zoom:80%;">



<p>官网：<a target="_blank" rel="noopener" href="https://seata.io/">https://seata.io</a></p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p>
<p>基本介绍：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
<hr>
<h4 id="基本使用-8"><a href="#基本使用-8" class="headerlink" title="基本使用"></a>基本使用</h4><p>两个注解：</p>
<ul>
<li><p>Spring 提供的本地事务：@Transactional</p>
</li>
<li><p>Seata 提供的全局事务：**@GlobalTransactional**</p>
</li>
</ul>
<p>搭建简单 Demo：</p>
<ul>
<li><p>创建 UNDO_LOG 表：SEATA AT 模式需要 <code>UNDO_LOG</code> 表，如果一个模块的事务提交了，Seata 会把提交了哪些数据记录到 undo_log 表中，如果这时 TC 通知全局事务回滚，那么 RM 就从 undo_log 表中获取之前修改了哪些资源，并根据这个表回滚</p>
<pre><code class="sql">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log
CREATE TABLE `undo_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `branch_id` bigint(20) NOT NULL,
  `xid` varchar(100) NOT NULL,
  `context` varchar(128) NOT NULL,
  `rollback_info` longblob NOT NULL,
  `log_status` int(11) NOT NULL,
  `log_created` datetime NOT NULL,
  `log_modified` datetime NOT NULL,
  `ext` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
</code></pre>
</li>
<li><p>引入 pom 依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;
    &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>application.yml：</p>
<pre><code class="yaml">spring:
  application:
    name: seata-order-service
  cloud:
    alibaba:
      seata:
        # 自定义事务组名称需要与seata-server中file.conf中配置的事务组ID对应
        # vgroup_mapping.my_test_tx_group = &quot;my_group&quot;
        tx-service-group: my_group
    nacos:
      discovery:
        server-addr: localhost:8848
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/seata_order?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=UTC
    username: root
    password: 123456
</code></pre>
</li>
<li><p>构建三个服务：</p>
<pre><code class="java">// 仓储服务
public interface StorageService &#123;
    // 扣除存储数量
    void deduct(String commodityCode, int count);
&#125;

// 订单服务
public interface OrderService &#123;
    // 创建订单
    Order create(String userId, String commodityCode, int orderCount);
&#125;

// 帐户服务
public interface AccountService &#123;
    // 从用户账户中借出
    void debit(String userId, int money);
&#125;
</code></pre>
</li>
<li><p>业务逻辑：增加 @GlobalTransactional 注解</p>
<pre><code class="java">public class OrderServiceImpl implements OrderService &#123;
    @Resource
    private OrderDAO orderDAO;
    @Resource
    private AccountService accountService;
    
    @Transactional(rollbackFor = Exception.class)
    public Order create(String userId, String commodityCode, int orderCount) &#123;
        int orderMoney = calculate(commodityCode, orderCount);
        // 账户扣钱
        accountService.debit(userId, orderMoney);

        Order order = new Order();
        order.userId = userId;
        order.commodityCode = commodityCode;
        order.count = orderCount;
        order.money = orderMoney;

        return orderDAO.insert(order);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class BusinessServiceImpl implements BusinessService &#123;
    @Resource
    private StorageService storageService;
    @Resource
    private OrderService orderService;

    // 采购，涉及多服务的分布式事务问题
    @GlobalTransactional
    @Transactional(rollbackFor = Exception.class)
    public void purchase(String userId, String commodityCode, int orderCount) &#123;
        storageService.deduct(commodityCode, orderCount);
        orderService.create(userId, commodityCode, orderCount);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<p>详细示例参考：<a target="_blank" rel="noopener" href="https://github.com/seata/seata-samples/tree/master/springcloud-nacos-seata">https://github.com/seata/seata-samples/tree/master/springcloud-nacos-seata</a></p>

</div>
  </div>
  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://dddwah11.github.io/2025/05/21/SSM/>https://dddwah11.github.io/2025/05/21/SSM/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2023-04-07T11:39:44+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Apr 7, 2023</p>
  </a>
</div>

        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://dddwah11.github.io/2025/05/21/SSM/&title= - 61分&summary="
          
          >
          
            <img src="/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://dddwah11.github.io/2025/05/21/SSM/&title= - 61分&summary="
          
          >
          
            <img src="/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=https://dddwah11.github.io/2025/05/21/SSM/&title= - 61分&summary="
          
          >
          
            <img src="/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2025/05/21/Tool/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i></p>
          <p class='content'>GitGit概述版本系统SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己...</p>
        </a>
      
      
        <a class='next' href='/2025/05/21/README/'>
          <p class='title'><i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>Java 学习笔记，记录作者从编程入门到深入学习的所有知识，每次学有所获都会更新笔记，排版布局美观整洁，希望对各位读者朋友有所帮助。
个人邮箱：&#x69;&#x6d;&#x73;&#101;&...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  

  
  <article class="post white-box reveal shadow" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2025/05/21/SSM/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    
    
    <div id="layoutHelper-comments"></div>

  </article>
  





</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile pjax" id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3API"><span class="toc-text">相关API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE"><span class="toc-text">映射配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE"><span class="toc-text">核心配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-text">#{}和${}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-text">日志文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">批量操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91"><span class="toc-text">代理开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-text">代理规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84"><span class="toc-text">结果映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A0%87%E7%AD%BE"><span class="toc-text">相关标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2"><span class="toc-text">嵌套查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-text">一对一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-text">一对多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-text">多对多</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%89%B4%E5%88%AB%E5%99%A8"><span class="toc-text">鉴别器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-text">延迟加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%8A%A0%E8%BD%BD"><span class="toc-text">两种加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#assocation"><span class="toc-text">assocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#collection"><span class="toc-text">collection</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-text">注解开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">单表操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">多表操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-text">相关注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80-1"><span class="toc-text">一对一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A-1"><span class="toc-text">一对多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A-1"><span class="toc-text">多对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%A6%82%E8%BF%B0"><span class="toc-text">缓存概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">一级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">二级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7"><span class="toc-text">相关属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-text">自定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E8%AF%AD%E5%8F%A5"><span class="toc-text">构造语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81-SQL"><span class="toc-text">动态 SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#where"><span class="toc-text">where</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if"><span class="toc-text">if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set"><span class="toc-text">set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#choose"><span class="toc-text">choose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trim"><span class="toc-text">trim</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#foreach"><span class="toc-text">foreach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E7%89%87%E6%AE%B5"><span class="toc-text">SQL片段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="toc-text">逆向工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-SQL"><span class="toc-text">构建 SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">基础语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1"><span class="toc-text">基本操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%8E%82"><span class="toc-text">获取工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BC%9A%E8%AF%9D"><span class="toc-text">获取会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86"><span class="toc-text">获取代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8CSQL"><span class="toc-text">执行SQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-text">插件使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="toc-text">插件原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6"><span class="toc-text">分页插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%93%8D%E4%BD%9C"><span class="toc-text">分页操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96"><span class="toc-text">参数获取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC"><span class="toc-text">IoC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="toc-text">基本概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE"><span class="toc-text">入门项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E5%BC%80%E5%8F%91"><span class="toc-text">XML开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bean"><span class="toc-text">bean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-text">基本属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">作用范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">创建方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Bean"><span class="toc-text">获取Bean</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DI"><span class="toc-text">DI</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">依赖注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set-%E6%B3%A8%E5%85%A5"><span class="toc-text">set 注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5"><span class="toc-text">构造注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%B3%A8%E5%85%A5"><span class="toc-text">集合注入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P"><span class="toc-text">P</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpEL"><span class="toc-text">SpEL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prop"><span class="toc-text">prop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#import"><span class="toc-text">import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90"><span class="toc-text">三方资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Druid"><span class="toc-text">Druid</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mybatis"><span class="toc-text">Mybatis</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91-1"><span class="toc-text">注解开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8"><span class="toc-text">注解驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#XML"><span class="toc-text">XML</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%AF%E6%B3%A8%E8%A7%A3"><span class="toc-text">纯注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E5%99%A8"><span class="toc-text">扫描器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-text">基本注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-bean"><span class="toc-text">设置 bean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4-1"><span class="toc-text">作用范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90"><span class="toc-text">加载资源</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="toc-text">属性注入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text">自动装配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%B3%A8%E5%85%A5"><span class="toc-text">静态注入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-text">文件读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-text">加载控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%8A%A0%E8%BD%BD"><span class="toc-text">依赖加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90"><span class="toc-text">整合资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5"><span class="toc-text">导入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Druid-1"><span class="toc-text">Druid</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Junit"><span class="toc-text">Junit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC%E5%8E%9F%E7%90%86"><span class="toc-text">IoC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-text">核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BeanFactory"><span class="toc-text">BeanFactory</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FactoryBean"><span class="toc-text">FactoryBean</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-text">数据准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8-1"><span class="toc-text">过滤器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%99%A8"><span class="toc-text">导入器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%99%A8"><span class="toc-text">注册器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-1"><span class="toc-text">基本概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">注解实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0-2"><span class="toc-text">基本概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3"><span class="toc-text">概念详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-1"><span class="toc-text">入门项目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E5%BC%80%E5%8F%91-1"><span class="toc-text">XML开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AspectJ"><span class="toc-text">AspectJ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP-1"><span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#config"><span class="toc-text">config</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pointcut"><span class="toc-text">pointcut</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aspect"><span class="toc-text">aspect</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pointcut"><span class="toc-text">Pointcut</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E5%85%A5%E7%82%B9"><span class="toc-text">切入点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">配置方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Advice"><span class="toc-text">Advice</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-text">通知类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F"><span class="toc-text">通知顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">获取数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91-2"><span class="toc-text">注解开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E6%B3%A8%E8%A7%A3"><span class="toc-text">AOP注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">启动注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#XML-1"><span class="toc-text">XML</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%AF%E6%B3%A8%E8%A7%A3-1"><span class="toc-text">纯注解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3-1"><span class="toc-text">基本注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Aspect"><span class="toc-text">Aspect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pointcut-1"><span class="toc-text">Pointcut</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Before"><span class="toc-text">Before</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#After"><span class="toc-text">After</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AfterR"><span class="toc-text">AfterR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AfterT"><span class="toc-text">AfterT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Around"><span class="toc-text">Around</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-%E5%8E%9F%E7%90%86"><span class="toc-text">AOP 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy"><span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CGLIB"><span class="toc-text">CGLIB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E9%80%89%E6%8B%A9"><span class="toc-text">代理选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%87%E5%85%A5%E6%97%B6%E6%9C%BA"><span class="toc-text">织入时机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">事务机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="toc-text">事务介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-text">传播行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E5%B1%9E%E6%80%A7"><span class="toc-text">超时属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">只读属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1"><span class="toc-text">核心对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%AF%B9%E8%B1%A1"><span class="toc-text">事务对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PTM"><span class="toc-text">PTM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Definition"><span class="toc-text">Definition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Status"><span class="toc-text">Status</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F"><span class="toc-text">编程式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F-1"><span class="toc-text">编程式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E6%94%B9%E9%80%A0"><span class="toc-text">AOP改造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="toc-text">声明式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML-2"><span class="toc-text">XML</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tx%E4%BD%BF%E7%94%A8"><span class="toc-text">tx使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tx%E9%85%8D%E7%BD%AE"><span class="toc-text">tx配置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%B3%A8%E8%A7%A3"><span class="toc-text">开启注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="toc-text">配置注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">使用注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1"><span class="toc-text">模板对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XML-4"><span class="toc-text">XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC"><span class="toc-text">IOC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8"><span class="toc-text">容器启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Bean-1"><span class="toc-text">获取Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2"><span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">四个阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-text">创建实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">循环引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1"><span class="toc-text">源码解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-2"><span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86"><span class="toc-text">注解原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-text">后置处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%80%9A%E7%9F%A5"><span class="toc-text">获取通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86"><span class="toc-text">创建代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%A2%9E%E5%BC%BA"><span class="toc-text">方法增强</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">解析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90"><span class="toc-text">标签解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90"><span class="toc-text">注解解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95"><span class="toc-text">驱动方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-text">开启事务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%BB%91%E5%AE%9A"><span class="toc-text">事务绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%88%9B%E5%BB%BA"><span class="toc-text">事务创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%87%8D%E5%85%A5"><span class="toc-text">事务重入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E6%81%A2%E5%A4%8D"><span class="toc-text">挂起恢复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%9B%9E%E6%BB%9A"><span class="toc-text">提交回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E6%96%B9%E5%BC%8F"><span class="toc-text">回滚方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="toc-text">提交方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E7%8E%B0%E5%9C%BA"><span class="toc-text">清理现场</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-1"><span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Component"><span class="toc-text">Component</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Autowired"><span class="toc-text">Autowired</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="toc-text">基本配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-2"><span class="toc-text">入门项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%8E%A7%E5%88%B6-1"><span class="toc-text">加载控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-1"><span class="toc-text">注解驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="toc-text">请求映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-2"><span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-text">请求处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E5%9E%8B"><span class="toc-text">普通类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POJO%E7%B1%BB%E5%9E%8B"><span class="toc-text">POJO类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">简单类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%86%B2%E7%AA%81"><span class="toc-text">参数冲突</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"><span class="toc-text">复杂类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">容器类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88"><span class="toc-text">数组集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">数组类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">集合类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-text">转换器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F"><span class="toc-text">日期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-1"><span class="toc-text">自定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86"><span class="toc-text">响应处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC"><span class="toc-text">页面跳转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%B7%B3%E8%BD%AC"><span class="toc-text">数据跳转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON"><span class="toc-text">JSON</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Restful"><span class="toc-text">Restful</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">访问方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%B3%A8%E8%A7%A3"><span class="toc-text">参数注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E5%8E%9F%E7%90%86"><span class="toc-text">识别原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet"><span class="toc-text">Servlet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-1"><span class="toc-text">运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84"><span class="toc-text">技术架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">组件介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-text">调度函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84-1"><span class="toc-text">请求映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%99%A8"><span class="toc-text">映射器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C"><span class="toc-text">方法执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">参数解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86-1"><span class="toc-text">响应处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE"><span class="toc-text">响应数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%AD%96%E7%95%A5"><span class="toc-text">协商策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90"><span class="toc-text">视图解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E8%A7%A3%E6%9E%90"><span class="toc-text">返回解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%B4%BE%E5%8F%91"><span class="toc-text">结果派发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="toc-text">异步调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-text">请求参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE-1"><span class="toc-text">响应数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE"><span class="toc-text">跨域访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-text">前置处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86-1"><span class="toc-text">后置处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E9%85%8D%E7%BD%AE"><span class="toc-text">拦截配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-text">拦截器链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2"><span class="toc-text">源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-2"><span class="toc-text">自定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-1"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8-1"><span class="toc-text">处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91-3"><span class="toc-text">注解开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-text">文件传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD"><span class="toc-text">上传下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E9%97%AE%E9%A2%98"><span class="toc-text">名称问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-3"><span class="toc-text">源码解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-text">实用技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E6%A1%86%E6%9E%B6"><span class="toc-text">校验框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E6%A6%82%E8%BF%B0"><span class="toc-text">校验概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%A0%A1%E9%AA%8C"><span class="toc-text">开启校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99"><span class="toc-text">校验规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-text">错误信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A7%84%E5%88%99%E6%A0%A1%E9%AA%8C"><span class="toc-text">多规则校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%A0%A1%E9%AA%8C"><span class="toc-text">嵌套校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C"><span class="toc-text">分组校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lombok"><span class="toc-text">Lombok</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="toc-text">基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Boot%E4%BB%8B%E7%BB%8D"><span class="toc-text">Boot介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-text">构建工程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-1"><span class="toc-text">自动装配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-text">依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%B3%A8%E8%A7%A3"><span class="toc-text">底层注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot"><span class="toc-text">SpringBoot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Configuration"><span class="toc-text">Configuration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-text">Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3"><span class="toc-text">条件注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">自定义注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">常用注解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImportRes"><span class="toc-text">ImportRes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-text">Properties</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-text">装配原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90"><span class="toc-text">注解分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-text">装配流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-text">事件监听</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F-1"><span class="toc-text">配置方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">文件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-text">加载顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yaml%E8%AF%AD%E6%B3%95"><span class="toc-text">yaml语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="toc-text">获取配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%8F%90%E7%A4%BA"><span class="toc-text">配置提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profile"><span class="toc-text">Profile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web%E5%BC%80%E5%8F%91"><span class="toc-text">Web开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%94%AF%E6%8C%81"><span class="toc-text">功能支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-text">静态资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="toc-text">访问规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2"><span class="toc-text">欢迎页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rest%E6%98%A0%E5%B0%84"><span class="toc-text">Rest映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8"><span class="toc-text">内嵌容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-3"><span class="toc-text">自定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E8%A7%84%E5%88%99"><span class="toc-text">定制规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E5%AE%B9%E5%99%A8"><span class="toc-text">定制容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-text">数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC"><span class="toc-text">JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-1"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">自动配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Druid-2"><span class="toc-text">Druid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis-1"><span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-1"><span class="toc-text">自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis-Plus"><span class="toc-text">MyBatis-Plus</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-3"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-2"><span class="toc-text">自动配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Junit5"><span class="toc-text">Junit5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3-1"><span class="toc-text">常用注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A8%80%E6%9C%BA%E5%88%B6"><span class="toc-text">断言机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%96%AD%E8%A8%80"><span class="toc-text">简单断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%AD%E8%A8%80"><span class="toc-text">数组断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%96%AD%E8%A8%80"><span class="toc-text">组合断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80"><span class="toc-text">异常断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E6%96%AD%E8%A8%80"><span class="toc-text">超时断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5"><span class="toc-text">快速失败</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6"><span class="toc-text">前置条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%B5%8B%E8%AF%95"><span class="toc-text">嵌套测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%B5%8B%E8%AF%95"><span class="toc-text">参数测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7"><span class="toc-text">指标监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Actuator"><span class="toc-text">Actuator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Endpoint"><span class="toc-text">Endpoint</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2"><span class="toc-text">项目部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-7"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="toc-text">服务注册</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka"><span class="toc-text">Eureka</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-8"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">消费者</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA"><span class="toc-text">集群构建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-1"><span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">负载均衡</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">服务发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4"><span class="toc-text">自我保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consul"><span class="toc-text">Consul</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-9"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-4"><span class="toc-text">基本使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-text">服务调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ribbon"><span class="toc-text">Ribbon</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-10"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">核心组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenFeign"><span class="toc-text">OpenFeign</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-11"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-5"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-text">超时问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-text">日志级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-text">服务熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hystrix"><span class="toc-text">Hystrix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-12"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-text">服务降级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%9E%84%E5%BB%BA"><span class="toc-text">案例构建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">降级操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD-1"><span class="toc-text">服务熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="toc-text">熔断类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E6%93%8D%E4%BD%9C"><span class="toc-text">熔断操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-1"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7"><span class="toc-text">服务监控</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3"><span class="toc-text">服务网关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Zuul"><span class="toc-text">Zuul</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gateway"><span class="toc-text">Gateway</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-13"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E4%BD%BF%E7%94%A8"><span class="toc-text">网关使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F-2"><span class="toc-text">配置方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5Bean"><span class="toc-text">注入Bean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-text">动态路由</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E8%A8%80%E7%B1%BB%E5%9E%8B"><span class="toc-text">断言类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Filter%E4%BD%BF%E7%94%A8"><span class="toc-text">Filter使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE"><span class="toc-text">服务配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#config-1"><span class="toc-text">config</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-14"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-2"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-1"><span class="toc-text">基本配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0"><span class="toc-text">动态刷新</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-text">服务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bus"><span class="toc-text">Bus</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-15"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%B9%BF%E6%92%AD"><span class="toc-text">全局广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E9%80%9A%E7%9F%A5"><span class="toc-text">定点通知</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream"><span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-16"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-6"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">高级特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sleuth"><span class="toc-text">Sleuth</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-17"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7"><span class="toc-text">链路监控</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alibaba"><span class="toc-text">Alibaba</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos"><span class="toc-text">Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-18"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">注册中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-text">配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="toc-text">基础配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E9%85%8D%E7%BD%AE"><span class="toc-text">分类配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE"><span class="toc-text">加载配置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84"><span class="toc-text">集群架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sentinel"><span class="toc-text">Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-19"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-7"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99"><span class="toc-text">流控规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7%E7%86%94%E6%96%AD"><span class="toc-text">降级熔断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E9%99%90%E6%B5%81"><span class="toc-text">热点限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99"><span class="toc-text">系统规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8-1"><span class="toc-text">服务调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">持久化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Seata"><span class="toc-text">Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E4%BA%8B%E7%89%A9"><span class="toc-text">分布事物</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-2"><span class="toc-text">基本配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-8"><span class="toc-text">基本使用</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>

  


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>


  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=false;
  pdata.postTitle="";
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.add("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="none";
      cover_wrapper.style.display="none";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fa-solid fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fa-solid fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/5.0.0-rc.3" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("/libs/@fortawesome/fontawesome-free/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js?time=1747798801074.js"></script>



  
  
  
  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='navigation menuNavigation-Content'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <li class='option menuOption-Content'>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copyText'>
          
          <i class='fa fa-copy fa-fw'></i> Copy Text
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copyPaste'>
          
          <i class='fa fa-paste fa-fw mR12'></i> 粘贴文本
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copySelect'>
          
          <i class='fa fa-object-ungroup fa-fw mR12'></i> 全选文本
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copyCut'>
          
          <i class='fa fa-cut fa-fw mR12'></i> 剪切文本
        </span>
        
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='searchWord'>
          
          <i class='fa fa-search fa-fw'></i> Site Search
        </span>
        
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='openTab'>
          
          <i class='fa fa-external-link-square-alt fa-fw mR12'></i> Open Link in New Tab
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copySrc'>
          
          <i class='fa fa-image fa-fw mR12'></i> Copy Image Link
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copyImg'>
          
          <i class='fa fa-images fa-fw mR12'></i> 复制图片文件
        </span>
      </li>
      
        
      
        
          <hr class="menuLoad-Content">
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://volantis.js.org/faqs/
        
        
        
        
          id="https:volantisjsorgfaqs"
        
      >
        <i class='fa fa-question fa-fw'></i> 常见问题
      </a>
    </li>
  
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://volantis.js.org/examples/
        
        
        
        
          id="https:volantisjsorgexamples"
        
      >
        <i class='fa fa-rss fa-fw'></i> 示例博客
      </a>
    </li>
  
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://volantis.js.org/contributors/
        
        
        
        
          id="https:volantisjsorgcontributors"
        
      >
        <i class='fa fa-fan fa-spin fa-fw'></i> 加入社区
      </a>
    </li>
  
        
      
        
          <hr class="menuLoad-Content">
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        
      >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        
      >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr class="menuLoad-Content">
        
      
        
          <li class='option menuOption-Content'>
            <span class='vlts-menu opt fix-cursor-default' id='printHtml'>
              <i class='fa fa-print fa-fw '></i> 打印页面
            </span>
          </li>  
        
      
        
          <li class='option menuOption-Content'>
            <span class='vlts-menu opt fix-cursor-default toggle-mode-btn' id='menuDarkBtn'>
              <i class='fa fa-moon fa-fw '></i> 暗黑模式
            </span>
          </li>
        
      
        
          <li class='option menuOption-Content'>
            <span class='vlts-menu opt fix-cursor-default' id='readingModel'>
              <i class='fa fa-book-open fa-fw '></i> 阅读模式
            </span>
          </li>  
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' 
        
        
        
        
      >
         
      </a>
    </li>
  
        
      
    </ul>
  </div>
  <script>volantis.js('/js/plugins/rightMenu.js?time=1747798801074')</script>



<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->



<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/sites.js?time=1747798801074")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/friends.js?time=1747798801074")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/contributors.js?time=1747798801074")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="/libs/flying-pages/flying-pages.min.js"></script>









  <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"}},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>





<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/")
    ? "/" || "/"
    : "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js?time=1747798801074");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event)=>{event.preventDefault();}, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    loadSearchScript().then(() => {
      SearchService.setQueryText(s);
      SearchService.search();
    });
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>








  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>












  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("/libs/swiper/swiper-bundle.min.css");
    volantis.js("/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:false})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    function findIndex(entries) {
      let index = 0;
      let entry = entries[index];
      if (entry.boundingClientRect.top > 0) {
        index = sections.indexOf(entry.target);
        return index === 0 ? 0 : index - 1;
      }
      for (; index < entries.length; index++) {
        if (entries[index].boundingClientRect.top <= 0) {
          entry = entries[index];
        } else {
          return sections.indexOf(entry.target);
        }
      }
      return sections.indexOf(entry.target);
    }

    function createIntersectionObserver(marginTop) {
      marginTop = Math.floor(marginTop + 10000);
      let intersectionObserver = new IntersectionObserver(
        (entries, observe) => {
          let scrollHeight = document.documentElement.scrollHeight;
          if (scrollHeight > marginTop) {
            observe.disconnect();
            createIntersectionObserver(scrollHeight);
            return;
          }
          let index = findIndex(entries);
          activateNavByIndex(navItems[index]);
        }, {
          rootMargin: marginTop + "px 0px -100% 0px",
          threshold: 0,
        }
      );
      sections.forEach((element) => {
        element && intersectionObserver.observe(element);
      });
    }

    createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>

<script>
  // https://web.dev/content-visibility/
  // https://www.caniuse.com/?search=content-visibility
  // https://infrequently.org/2020/12/content-visibility-scroll-fix/
  // https://infrequently.org/2020/12/resize-resilient-deferred-rendering/

  // 备注 目前已知的问题:
  // 动态修改导致的内容高度变化(例如评论框异步渲染的外部盒子高度变化) 无法提前获知, 进而导致的首次滚动条跳动无法去除 (wontfix) 事实上不使用 content-visibility 也会有跳动, 不过是比使用 content-visibility 跳动提前
  // scrollreveal 插件潜在问题 目前尚不明确

  let eqIsh = (a, b, fuzz = 2) => {
    return Math.abs(a - b) <= fuzz;
  };

  let rectNotEQ = (a, b) => {
    return !eqIsh(a.width, b.width) || !eqIsh(a.height, b.height);
  };

  // Keep a map of elements and the dimensions of
  // their place-holders, re-setting the element's
  // intrinsic size when we get updated measurements
  // from observers.
  let spaced = new WeakMap();

  // Only call this when known cheap, post layout
  let reserveSpace = (el, rect = el.getClientBoundingRect()) => {
    let old = spaced.get(el);
    // Set intrinsic size to prevent jumping on un-painting:
    //    https://drafts.csswg.org/css-sizing-4/#intrinsic-size-override
    if (!old || rectNotEQ(old, rect)) {
      spaced.set(el, rect);
      el.style["contain-intrinsic-size"] = `${rect.width}px ${rect.height}px`;
    }
  };

  let iObs = new IntersectionObserver(
    (entries, o) => {
      entries.forEach((entry) => {
        // We don't care if the element is intersecting or
        // has been laid out as our page structure ensures
        // they'll get the right width.
        reserveSpace(entry.target, entry.boundingClientRect);
      });
    },
    { rootMargin: "500px 0px 500px 0px" }
  );

  let rObs = new ResizeObserver((entries, o) => {
    entries.forEach((entry) => {
      reserveSpace(entry.target, entry.contentRect);
    });
  });

  let resizeResilientDeferredRendering = (Selector) => {
    let articles = document.querySelectorAll(Selector);

    if (articles.length) {
      articles.forEach((el) => {
        iObs.observe(el);
        rObs.observe(el);
      });

      // Workaround for Chrome bug, part 2.
      //
      // Re-enable browser management of rendering for the
      // first article after the first paint. Double-rAF
      // to ensure we get called after a layout.
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          articles[0].style["content-visibility"] = "auto";
        });
      });
    }
  };

  let contentVisibilityScrollFix = () => {
    if (!("content-visibility" in document.documentElement.style)) {
      return;
    }
    resizeResilientDeferredRendering(".post-story");
    resizeResilientDeferredRendering("article");
    resizeResilientDeferredRendering(".post-wrapper");
  };
  contentVisibilityScrollFix();
  volantis.pjax.push(contentVisibilityScrollFix);
</script>



  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"61分","url":"https://dddwah11.github.io/","logo":{"@type":"ImageObject","url":"/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"小刘","image":{"@type":"ImageObject","url":"/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://dddwah11.github.io/","sameAs":["https://github.com/volantis-x"],"description":""},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://dddwah11.github.io/","name":"61分"}},{"@type":"ListItem","position":3,"item":{"@id":"https://dddwah11.github.io/2025/05/21/SSM/","name":""}}]},{"@context":"http://schema.org","@type":"BlogPosting","headline":"","description":"","datePublished":"2025-05-20T16:25:06.362Z","dateModified":"2023-04-07T03:39:44.000Z","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https://dddwah11.github.io/2025/05/21/SSM/"},"author":{"@type":"Person","name":"小刘","image":{"@type":"ImageObject","url":"/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://dddwah11.github.io/"},"publisher":{"@type":"Organization","name":"61分","logo":{"@type":"ImageObject","url":"/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"https://dddwah11.github.io/2025/05/21/SSM/","wordCount":0,"image":{"@type":"ImageObject","url":"/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>


<!-- more -->



      
        <!-- 
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name='description']",
          "head meta[name='keywords']",
          "head meta[property^='og']",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
  <!-- Custom Files bodyEnd begin-->
  
  <!-- Custom Files bodyEnd end-->
  </body>
</html>
